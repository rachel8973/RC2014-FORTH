0001   0000             ;------------------------------------------------------------------------------
0002   0000             ; FORTH - V0
0003   0000             ;------------------------------------------------------------------------------
0004   0000             ;
0005   0000             ; This is not my source. I did not write this I only made it work on the
0006   0000             ; RC2014 so I would have something the mess around with.
0007   0000             ;
0008   0000             ; I found a simple FORTH buried in a ZIP file on the Z80 info site at ...
0009   0000             ;      http://www.z80.info/zip/z80asm.zip
0010   0000             ;
0011   0000             ; V0 - Included the source from Grant Searles simple 7 chip Z80 computer
0012   0000             ;      from here http://searle.hostei.com/grant/
0013   0000             ;      Modified the CHR_RD and CHR_WR to use the routines from INT32K.ROM
0014   0000             ;      Added a def so I can build as a ROM or RAM
0015   0000             ;      A few renames so I could build it with TASM.
0016   0000             ;
0017   0000             ;------------------------------------------------------------------------------
0018   0000             
0019   0000             #IFDEF ROM
0020   0000             #INCLUDE        "INT32K.ASM"
0001+  0000             ;==================================================================================
0002+  0000             ; Contents of this file are copyright Grant Searle
0003+  0000             ;
0004+  0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005+  0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006+  0000             ;
0007+  0000             ; http://searle.hostei.com/grant/index.html
0008+  0000             ;
0009+  0000             ; eMail: home.micros01@btinternet.com
0010+  0000             ;
0011+  0000             ; If the above don't work, please perform an Internet search to see if I have
0012+  0000             ; updated the web page hosting service.
0013+  0000             ;
0014+  0000             ;==================================================================================
0015+  0000             
0016+  0000             ; Minimum 6850 ACIA interrupt driven serial I/O to run modified NASCOM Basic 4.7
0017+  0000             ; Full input buffering with incoming data hardware handshaking
0018+  0000             ; Handshake shows full before the buffer is totally filled to allow run-on from the sender
0019+  0000             
0020+  0000             SER_BUFSIZE     .EQU     3FH
0021+  0000             SER_FULLSIZE    .EQU     30H
0022+  0000             SER_EMPTYSIZE   .EQU     5
0023+  0000             
0024+  0000             RTS_HIGH        .EQU     0D6H
0025+  0000             RTS_LOW         .EQU     096H
0026+  0000             
0027+  0000             serBuf          .EQU     $8000
0028+  0000             serInPtr        .EQU     serBuf+SER_BUFSIZE
0029+  0000             serRdPtr        .EQU     serInPtr+2
0030+  0000             serBufUsed      .EQU     serRdPtr+2
0031+  0000             basicStarted    .EQU     serBufUsed+1
0032+  0000             TEMPSTACK       .EQU     $80ED ; Top of BASIC line input buffer so is "free ram" when BASIC resets
0033+  0000             
0034+  0000             CR              .EQU     0DH
0035+  0000             LF              .EQU     0AH
0036+  0000             CS              .EQU     0CH             ; Clear screen
0037+  0000             
0038+  0000                             .ORG $0000
0039+  0000             ;------------------------------------------------------------------------------
0040+  0000             ; Reset
0041+  0000             
0042+  0000 F3          RST00           DI                       ;Disable interrupts
0043+  0001 C3 B8 00                    JP       INIT            ;Initialize Hardware and go
0044+  0004             
0045+  0004             ;------------------------------------------------------------------------------
0046+  0004             ; TX a character over RS232 
0047+  0004             
0048+  0008                             .ORG     0008H
0049+  0008 C3 9F 00    RST08            JP      TXA
0050+  000B             
0051+  000B             ;------------------------------------------------------------------------------
0052+  000B             ; RX a character over RS232 Channel A [Console], hold here until char ready.
0053+  000B             
0054+  0010                             .ORG 0010H
0055+  0010 C3 74 00    RST10            JP      RXA
0056+  0013             
0057+  0013             ;------------------------------------------------------------------------------
0058+  0013             ; Check serial status
0059+  0013             
0060+  0018                             .ORG 0018H
0061+  0018 C3 AA 00    RST18            JP      CKINCHAR
0062+  001B             
0063+  001B             ;------------------------------------------------------------------------------
0064+  001B             ; RST 38 - INTERRUPT VECTOR [ for IM 1 ]
0065+  001B             
0066+  0038                             .ORG     0038H
0067+  0038 18 00       RST38            JR      serialInt       
0068+  003A             
0069+  003A             ;------------------------------------------------------------------------------
0070+  003A F5          serialInt:      PUSH     AF
0071+  003B E5                          PUSH     HL
0072+  003C             
0073+  003C DB 80                       IN       A,($80)
0074+  003E E6 01                       AND      $01             ; Check if interupt due to read buffer full
0075+  0040 28 2D                       JR       Z,rts0          ; if not, ignore
0076+  0042             
0077+  0042 DB 81                       IN       A,($81)
0078+  0044 F5                          PUSH     AF
0079+  0045 3A 43 80                    LD       A,(serBufUsed)
0080+  0048 FE 3F                       CP       SER_BUFSIZE     ; If full then ignore
0081+  004A 20 03                       JR       NZ,notFull
0082+  004C F1                          POP      AF
0083+  004D 18 20                       JR       rts0
0084+  004F             
0085+  004F 2A 3F 80    notFull:        LD       HL,(serInPtr)
0086+  0052 23                          INC      HL
0087+  0053 7D                          LD       A,L             ; Only need to check low byte becasuse buffer<256 bytes
0088+  0054 FE 3F                       CP       (serBuf+SER_BUFSIZE) & $FF
0089+  0056 20 03                       JR       NZ, notWrap
0090+  0058 21 00 80                    LD       HL,serBuf
0091+  005B 22 3F 80    notWrap:        LD       (serInPtr),HL
0092+  005E F1                          POP      AF
0093+  005F 77                          LD       (HL),A
0094+  0060 3A 43 80                    LD       A,(serBufUsed)
0095+  0063 3C                          INC      A
0096+  0064 32 43 80                    LD       (serBufUsed),A
0097+  0067 FE 30                       CP       SER_FULLSIZE
0098+  0069 38 04                       JR       C,rts0
0099+  006B 3E D6                       LD       A,RTS_HIGH
0100+  006D D3 80                       OUT      ($80),A
0101+  006F E1          rts0:           POP      HL
0102+  0070 F1                          POP      AF
0103+  0071 FB                          EI
0104+  0072 ED 4D                       RETI
0105+  0074             
0106+  0074             ;------------------------------------------------------------------------------
0107+  0074             RXA:
0108+  0074 3A 43 80    waitForChar:    LD       A,(serBufUsed)
0109+  0077 FE 00                       CP       $00
0110+  0079 28 F9                       JR       Z, waitForChar
0111+  007B E5                          PUSH     HL
0112+  007C 2A 41 80                    LD       HL,(serRdPtr)
0113+  007F 23                          INC      HL
0114+  0080 7D                          LD       A,L             ; Only need to check low byte becasuse buffer<256 bytes
0115+  0081 FE 3F                       CP       (serBuf+SER_BUFSIZE) & $FF
0116+  0083 20 03                       JR       NZ, notRdWrap
0117+  0085 21 00 80                    LD       HL,serBuf
0118+  0088 F3          notRdWrap:      DI
0119+  0089 22 41 80                    LD       (serRdPtr),HL
0120+  008C 3A 43 80                    LD       A,(serBufUsed)
0121+  008F 3D                          DEC      A
0122+  0090 32 43 80                    LD       (serBufUsed),A
0123+  0093 FE 05                       CP       SER_EMPTYSIZE
0124+  0095 30 04                       JR       NC,rts1
0125+  0097 3E 96                       LD       A,RTS_LOW
0126+  0099 D3 80                       OUT      ($80),A
0127+  009B             rts1:
0128+  009B 7E                          LD       A,(HL)
0129+  009C FB                          EI
0130+  009D E1                          POP      HL
0131+  009E C9                          RET                      ; Char ready in A
0132+  009F             
0133+  009F             ;------------------------------------------------------------------------------
0134+  009F F5          TXA:            PUSH     AF              ; Store character
0135+  00A0 DB 80       conout1:        IN       A,($80)         ; Status byte       
0136+  00A2 CB 4F                       BIT      1,A             ; Set Zero flag if still transmitting character       
0137+  00A4 28 FA                       JR       Z,conout1       ; Loop until flag signals ready
0138+  00A6 F1                          POP      AF              ; Retrieve character
0139+  00A7 D3 81                       OUT      ($81),A         ; Output the character
0140+  00A9 C9                          RET
0141+  00AA             
0142+  00AA             ;------------------------------------------------------------------------------
0143+  00AA 3A 43 80    CKINCHAR        LD       A,(serBufUsed)
0144+  00AD FE 00                       CP       $0
0145+  00AF C9                          RET
0146+  00B0             
0147+  00B0 7E          PRINT:          LD       A,(HL)          ; Get character
0148+  00B1 B7                          OR       A               ; Is it $00 ?
0149+  00B2 C8                          RET      Z               ; Then RETurn on terminator
0150+  00B3 CF                          RST      08H             ; Print it
0151+  00B4 23                          INC      HL              ; Next Character
0152+  00B5 18 F9                       JR       PRINT           ; Continue until $00
0153+  00B7 C9                          RET
0154+  00B8             ;------------------------------------------------------------------------------
0155+  00B8             INIT:
0156+  00B8 21 ED 80                   LD        HL,TEMPSTACK    ; Temp stack
0157+  00BB F9                         LD        SP,HL           ; Set up a temporary stack
0158+  00BC 21 00 80                   LD        HL,serBuf
0159+  00BF 22 3F 80                   LD        (serInPtr),HL
0160+  00C2 22 41 80                   LD        (serRdPtr),HL
0161+  00C5 AF                         XOR       A               ;0 to accumulator
0162+  00C6 32 43 80                   LD        (serBufUsed),A
0163+  00C9 3E 96                      LD        A,RTS_LOW
0164+  00CB D3 80                      OUT       ($80),A         ; Initialise ACIA
0165+  00CD ED 56                      IM        1
0166+  00CF FB                         EI
0167+  00D0 21 09 01                   LD        HL,SIGNON1      ; Sign-on message
0168+  00D3 CD B0 00                   CALL      PRINT           ; Output string
0169+  00D6 3A 44 80                   LD        A,(basicStarted); Check the BASIC STARTED flag
0170+  00D9 FE 59                      CP        'Y'             ; to see if this is power-up
0171+  00DB 20 16                      JR        NZ,COLDSTART    ; If not BASIC started then always do cold start
0172+  00DD 21 24 01                   LD        HL,SIGNON2      ; Cold/warm message
0173+  00E0 CD B0 00                   CALL      PRINT           ; Output string
0174+  00E3             CORW:
0175+  00E3 CD 74 00                   CALL      RXA
0176+  00E6 E6 DF                      AND       %11011111       ; lower to uppercase
0177+  00E8 FE 43                      CP        'C'
0178+  00EA 20 0F                      JR        NZ, CHECKWARM
0179+  00EC CF                         RST       08H
0180+  00ED 3E 0D                      LD        A,$0D
0181+  00EF CF                         RST       08H
0182+  00F0 3E 0A                      LD        A,$0A
0183+  00F2 CF                         RST       08H
0184+  00F3 3E 59       COLDSTART:     LD        A,'Y'           ; Set the BASIC STARTED flag
0185+  00F5 32 44 80                   LD        (basicStarted),A
0186+  00F8 C3 50 01                   JP        $0150           ; Start BASIC COLD
0187+  00FB             CHECKWARM:
0188+  00FB FE 57                      CP        'W'
0189+  00FD 20 E4                      JR        NZ, CORW
0190+  00FF CF                         RST       08H
0191+  0100 3E 0D                      LD        A,$0D
0192+  0102 CF                         RST       08H
0193+  0103 3E 0A                      LD        A,$0A
0194+  0105 CF                         RST       08H
0195+  0106 C3 53 01                   JP        $0153           ; Start BASIC WARM
0196+  0109 0C          SIGNON1:       .BYTE     CS
0197+  010A 5A3830205342               .BYTE     "Z80 SBC By Grant Searle",CR,LF,0
0197+  0110 43204279204772616E7420536561726C650D0A00
0198+  0124 0D 0A       SIGNON2:       .BYTE     CR,LF
0199+  0126 436F6C64206F               .BYTE     "Cold or warm start (C or W)? ",0
0199+  012C 72207761726D207374617274202843206F722057293F2000
0200+  0144              
0021   0144             #ENDIF         ; ROM
0022   0144             
0023   0144             ;------------------------------------------------------------------------------
0024   0144             ; This is an implementation of FORTH for the Z80 that should be easily portable
0025   0144             ; to other Z80 systems. It assumes RAM from 9000h to 0FFFFh and a UART for
0026   0144             ; communication with the host or VDU.
0027   0144             
0028   0144             DATA_STACK:	.EQU	0FD80h		;Data stack grows down
0029   0144             VOCAB_BASE:	.EQU	0F000h		;Dictionary grows up from here
0030   0144             MASS_STORE:	.EQU	0FEA0h		;Mass storage buffer (default)
0031   0144             DISK_START:	.EQU	0A000h		;Pseudo disk buffer start
0032   0144             DISK_END:	.EQU	0F000h		;Pseudo disk buffer end
0033   0144             BLOCK_SIZE:	.EQU	0200h		;Pseudo disk block size
0034   0144             BUFFERS:	.EQU	0001h		;Pseudo disk buffers per block
0035   0144             
0036   0144             #IFDEF ROM
0037   0144             ;  No Monitor
0038   0150             		.ORG	150h		;Start of ROM after BIOS
0039   0150~            #ELSE
0040   0150~            MONSTART:	.EQU	0153h		;Monitor entry address
0041   0150~            		.ORG	8200h		;Start of RAM allowing for Monitor ROM
0042   0150             #ENDIF
0043   0150             
0044   0150             ; Start of FORTH code
0045   0150             
0046   0150 C3 D7 12    	JP	X_COLD
0047   0153             
0048   0153             #IFDEF ROM
0049   0153             ;  No Monitor
0050   0153             	.ORG	153h			;  WARM Start Point
0051   0153             #ENDIF
0052   0153 C3 C5 12    	JP	C_WARM
0053   0156             
0054   0156             BACKSPACE:
0055   0156 08 00       	.WORD	0008h			;Backspace chr
0056   0158             
0057   0158             WORD1:
0058   0158 80 FD       	.WORD	DATA_STACK
0059   015A             DEF_SYSADDR:
0060   015A 00 FE       	.WORD	SYSTEM
0061   015C 80 FD       	.WORD	DATA_STACK
0062   015E 1F 00       	.WORD	001Fh			;Word name length (default 31)
0063   0160 00 00       	.WORD	0000h			;Error message control number
0064   0162 00 F0       	.WORD	VOCAB_BASE		;FORGET protection
0065   0164 0B F0       	.WORD	VOCAB_BASE+0Bh		;Dictionary pointer
0066   0166 34 12       	.WORD	E_FORTH			;Most recently created vocab.
0067   0168             
0068   0168             START_TABLE:
0069   0168 81 A0       	.BYTE	81h,0A0h
0070   016A 00 F0       	.WORD	VOCAB_BASE
0071   016C 00 00       	.BYTE	00h,00h			;FLAST
0072   016E 81 A0       	.BYTE	81h,0A0h
0073   0170 5B 1B       	.WORD	W_EDITI
0074   0172 34 12       	.WORD	E_FORTH			;ELAST
0075   0174 00          	.BYTE	00h			;CRFLAG
0076   0175 00          	.BYTE	00h			;Free
0077   0176 DB 00       	IN	A,(00h)			;I/O Port input
0078   0178 C9          	RET				;routine
0079   0179 D3 00       	OUT	(00h),A			;I/O Port output
0080   017B C9          	RET				;routine
0081   017C 00 FE       	.WORD	SYSTEM 			;Return stack pointer
0082   017E A0 FE       	.WORD	MASS_STORE		;Mass storage buffer to use
0083   0180 A0 FE       	.WORD	MASS_STORE		;Storage buffer just used
0084   0182 00          	.BYTE	00h			;Interrupt flag
0085   0183 00          	.BYTE	00h			;Free
0086   0184 94 12       	.WORD	C_ABORT			;Interrupt vector
0087   0186 9F 1B       	.WORD	CF_UQTERMINAL		;C field address ?TERMINAL
0088   0188 73 1B       	.WORD	CF_UKEY			;C field address KEY
0089   018A 7E 1B       	.WORD	CF_UEMIT		;C field address EMIT
0090   018C 8C 1B       	.WORD	CF_UCR			;C field address CR
0091   018E 7D 15       	.WORD	CF_URW			;C field address R/W
0092   0190 9E 12       	.WORD	CF_UABORT		;C field address ABORT
0093   0192 20 00       	.WORD	0020h			;CHRs per input line
0094   0194 00 A0       	.WORD	DISK_START		;Pseudo disk buf start
0095   0196 00 F0       	.WORD	DISK_END		;Pseudo disk buf end
0096   0198 00 02       	.WORD	BLOCK_SIZE		;Bytes per block
0097   019A 01 00       	.WORD	BUFFERS			;Buffers per block
0098   019C             
0099   019C             NEXTS2:
0100   019C D5          	PUSH	DE
0101   019D             NEXTS1:
0102   019D E5          	PUSH	HL
0103   019E             NEXT:
0104   019E 3A 4C FE    	LD	A,(INTFLAG)		;Interrupt flag
0105   01A1 CB 7F       	BIT	7,A			;Check for interrupt
0106   01A3 28 0E       	JR	Z,NOINT			;No interrupt
0107   01A5 CB 77       	BIT	6,A			;Interrupt enabled ?
0108   01A7 20 0A       	JR	NZ,NOINT		;No interrupt
0109   01A9 2A 4E FE    	LD	HL,(INTVECT)		;Get nterrupt vector
0110   01AC 3E 40       	LD	A,40h			;Clear flag byte
0111   01AE 32 4C FE    	LD	(INTFLAG),A		;Interrupt flag into HL
0112   01B1 18 06       	JR	NEXTADDR		;JP (HL)
0113   01B3             NOINT:
0114   01B3 0A          	LD	A,(BC)			;effectively LD HL,(BC)
0115   01B4 03          	INC	BC			;
0116   01B5 6F          	LD	L,A			;
0117   01B6 0A          	LD	A,(BC)			;
0118   01B7 03          	INC	BC			;BC now points to next vector
0119   01B8 67          	LD	H,A			;HL has addr vector
0120   01B9             NEXTADDR:
0121   01B9 5E          	LD	E,(HL)			;effectively LD HL,(HL)
0122   01BA 23          	INC	HL			;
0123   01BB 56          	LD	D,(HL) 			;
0124   01BC EB          	EX	DE,HL 			;
0125   01BD E9          	JP	(HL) 			;Jump to it
0126   01BE             
0127   01BE             W_LIT:					;Puts next 2 bytes on the stack
0128   01BE 83 4C 49 D4 	.BYTE	83h,"LI",'T'+80h
0129   01C2 00 00       	.WORD	0000h			;First word in vocabulary
0130   01C4             C_LIT:
0131   01C4 C6 01       	.WORD	2+$			;Vector to code
0132   01C6 0A          	LD	A,(BC)			;Gets next word from (BC)
0133   01C7 03          	INC	BC			;then increments BC to point
0134   01C8 6F          	LD	L,A			;to the next addr. Pushes the
0135   01C9 0A          	LD	A,(BC)			;result onto the stack.
0136   01CA 03          	INC	BC			;
0137   01CB 67          	LD	H,A			;
0138   01CC C3 9D 01    	JP	NEXTS1			;Save & NEXT
0139   01CF             
0140   01CF             
0141   01CF             W_EXECUTE:				;Jump to address on stack
0142   01CF 874558454355	.BYTE	87h,"EXECUT",'E'+80h
0142   01D5 54C5
0143   01D7 BE 01       	.WORD	W_LIT
0144   01D9             C_EXECUTE:
0145   01D9 DB 01       	.WORD	2+$			;Vector to code
0146   01DB E1          	POP	HL			;Get addr off data stack
0147   01DC C3 B9 01    	JP	NEXTADDR		;Basically JP (HL)
0148   01DF             
0149   01DF             
0150   01DF             W_BRANCH:				;Add following offset to BC
0151   01DF 864252414E43	.BYTE	86h,"BRANC",'H'+80h
0151   01E5 C8
0152   01E6 CF 01       	.WORD	W_EXECUTE
0153   01E8             C_BRANCH:
0154   01E8 EA 01       	.WORD	2+$			;Vector to code
0155   01EA             X_BRANCH:
0156   01EA 60          	LD	H,B			;Next pointer into HL
0157   01EB 69          	LD	L,C			;
0158   01EC 5E          	LD	E,(HL)			;Get word offset LD DE,(HL)
0159   01ED 23          	INC	HL			;Incr to point at next byte
0160   01EE 56          	LD	D,(HL)			;
0161   01EF 2B          	DEC	HL 			;Restore HL
0162   01F0 19          	ADD	HL,DE			;Calculate new address
0163   01F1 4D          	LD	C,L			;Put it in BC
0164   01F2 44          	LD	B,H			;
0165   01F3 C3 9E 01    	JP	NEXT			;Go do it
0166   01F6             
0167   01F6             W_0BRANCH:				;Add offset to BC if stack top = 0
0168   01F6 87304252414E	.BYTE	87h,"0BRANC",'H'+80h	;Conditional branch
0168   01FC 43C8
0169   01FE DF 01       	.WORD	W_BRANCH
0170   0200             C_0BRANCH:
0171   0200 02 02       	.WORD	2+$			;Vector to code
0172   0202 E1          	POP	HL			;Get value off stack
0173   0203 7D          	LD	A,L			;Set flags
0174   0204 B4          	OR	H			;
0175   0205 28 E3       	JR	Z,X_BRANCH		;If zero then do the branch
0176   0207 03          	INC	BC			;Else dump branch address
0177   0208 03          	INC	BC			;
0178   0209 C3 9E 01    	JP	NEXT			;Continue execution
0179   020C             
0180   020C             W_LLOOP:				;Increment loop & branch if not done
0181   020C 863C4C4F4F50	.BYTE	86h,"<LOOP",'>'+80h
0181   0212 BE
0182   0213 F6 01       	.WORD	W_0BRANCH
0183   0215             C_LLOOP:
0184   0215 17 02       	.WORD	2+$			;Vector to code
0185   0217 11 01 00    	LD	DE,0001
0186   021A             C_ILOOP:
0187   021A 2A 46 FE    	LD	HL,(RPP)		;Get return stack pointer
0188   021D 7E          	LD	A,(HL)			;Add DE to value on return stack
0189   021E 83          	ADD	A,E			;
0190   021F 77          	LD	(HL),A			;
0191   0220 5F          	LD	E,A			;
0192   0221 23          	INC	HL			;
0193   0222 7E          	LD	A,(HL)			;
0194   0223 8A          	ADC	A,D			;
0195   0224 77          	LD	(HL),A			;
0196   0225 23          	INC	HL			;HL now points to limit value
0197   0226 14          	INC	D			;Get DS sign bit
0198   0227 15          	DEC	D			;
0199   0228 57          	LD	D,A			;Result now in DE
0200   0229 FA 33 02    	JP	M,DECR_LOOP		;Decrement loop so check > limit
0201   022C             					;otherwies check < limit
0202   022C 7B          	LD	A,E			;Low byte back
0203   022D 96          	SUB	(HL)			;Subtract limit low
0204   022E 7A          	LD	A,D			;High byte back
0205   022F 23          	INC	HL			;Point to limit high
0206   0230 9E          	SBC	A,(HL)			;Subtract it
0207   0231 18 05       	JR	TEST_LIMIT		;
0208   0233             DECR_LOOP:
0209   0233 7E          	LD	A,(HL)			;Get limit low
0210   0234 93          	SUB	E			;Subtract index low
0211   0235 23          	INC	HL			;Point to limit high
0212   0236 7E          	LD	A,(HL)			;Get it
0213   0237 9A          	SBC	A,D			;Subtract index high
0214   0238             TEST_LIMIT:
0215   0238 FA EA 01    	JP	M,X_BRANCH		;Not reached limit so jump
0216   023B 23          	INC	HL			;Drop index & limit from return stack
0217   023C 22 46 FE    	LD	(RPP),HL		;Save stack pointer
0218   023F 03          	INC	BC			;Skip branch offset
0219   0240 03          	INC	BC			;
0220   0241 C3 9E 01    	JP	NEXT
0221   0244             
0222   0244             W_PLOOP:				;Loop + stack & branch if not done
0223   0244 873C2B4C4F4F	.BYTE	87h,"<+LOOP",'>'+80h
0223   024A 50BE
0224   024C 0C 02       	.WORD	W_LLOOP
0225   024E             C_PLOOP:
0226   024E 50 02       	.WORD	2+$			;Vector to code
0227   0250 D1          	POP	DE			;Get value from stack
0228   0251 18 C7       	JR	C_ILOOP			;Go do loop increment
0229   0253             
0230   0253             W_LDO:					;Put start & end loop values on RPP
0231   0253 843C444FBE  	.BYTE	84h,"<DO",'>'+80h
0232   0258 44 02       	.WORD	 W_PLOOP
0233   025A             C_LDO:
0234   025A 5C 02       	.WORD	 2+$
0235   025C 2A 46 FE    	LD	HL,(RPP)		;Get return stack pointer
0236   025F 2B          	DEC	HL			;Add space for two values
0237   0260 2B          	DEC	HL			;
0238   0261 2B          	DEC	HL			;
0239   0262 2B          	DEC	HL			;
0240   0263 22 46 FE    	LD	(RPP),HL		;Save new stack pointer
0241   0266 D1          	POP	DE			;Get start value &
0242   0267 73          	LD	(HL),E			;put on return stack top
0243   0268 23          	INC	HL			;
0244   0269 72          	LD	(HL),D			;
0245   026A 23          	INC	HL			;
0246   026B D1          	POP	DE			;Get end value &
0247   026C 73          	LD	(HL),E			;put on return stack - 1
0248   026D 23          	INC	HL			;
0249   026E 72          	LD	(HL),D			;
0250   026F C3 9E 01    	JP	NEXT
0251   0272             
0252   0272             W_I:					;Copy LOOP index to data stack
0253   0272 81 C9       	.BYTE	81h,'I'+80h
0254   0274 53 02       	.WORD	 W_LDO
0255   0276             C_I:
0256   0276 78 02       	.WORD	 2+$
0257   0278             X_I:
0258   0278 2A 46 FE    	LD	HL,(RPP)		;Get return stack pointer
0259   027B             X_I2:
0260   027B 5E          	LD	E,(HL)			;Get LOOP index off return stack
0261   027C 23          	INC	HL			;
0262   027D 56          	LD	D,(HL)			;
0263   027E D5          	PUSH	DE			;Push onto data stack
0264   027F C3 9E 01    	JP	NEXT
0265   0282             
0266   0282             W_DIGIT:				;Convert digit n2 using base n1
0267   0282 8544494749D4	.BYTE	85h,"DIGI",'T'+80h
0268   0288 72 02       	.WORD	 W_I
0269   028A             C_DIGIT:
0270   028A 8C 02       	.WORD	2+$
0271   028C E1          	POP	HL			;Get base to use
0272   028D D1          	POP	DE			;Get char
0273   028E 7B          	LD	A,E			;A = char
0274   028F D6 30       	SUB	30h			;Subtract 30h
0275   0291 FA AB 02    	JP	M,NDIGIT		;
0276   0294 FE 0A       	CP	0Ah			;Greater than 9 ?
0277   0296 FA A0 02    	JP	M,LESS10		;If not then skip
0278   0299 D6 07       	SUB	07h			;Convert 'A' to 10
0279   029B FE 0A       	CP	0Ah			;Is it 10?
0280   029D FA AB 02    	JP	M,NDIGIT		;If not an error occured
0281   02A0             LESS10:
0282   02A0 BD          	CP	L			;L is 1 digit limit
0283   02A1 F2 AB 02    	JP	P,NDIGIT		;Out of range for digit
0284   02A4 5F          	LD	E,A			;Result into DE
0285   02A5 21 01 00    	LD	HL,0001			;Leave TRUE flag
0286   02A8 C3 9C 01    	JP	NEXTS2			;Save both & NEXT
0287   02AB             NDIGIT:
0288   02AB 6C          	LD	L,H			;Leave FALSE flag
0289   02AC C3 9D 01    	JP	NEXTS1			;Save & NEXT
0290   02AF             
0291   02AF             W_FIND:					;Find word & return vector,byte & flag
0292   02AF 863C46494E44	.BYTE	86h,"<FIND",'>'+80h
0292   02B5 BE
0293   02B6 82 02       	.WORD	W_DIGIT
0294   02B8             C_FIND:
0295   02B8 BA 02       	.WORD	2+$			;Vector to code
0296   02BA D1          	POP	DE			;Get pointer to next vocabulary word
0297   02BB             COMPARE:
0298   02BB E1          	POP	HL			;Copy pointer to word we're looking 4
0299   02BC E5          	PUSH	HL			;
0300   02BD 1A          	LD	A,(DE)			;Get 1st vocabulary word letter
0301   02BE AE          	XOR	(HL)			;Compare with what we've got
0302   02BF E6 3F       	AND	3Fh			;Ignore start flag
0303   02C1 20 1F       	JR	NZ,NOT_END_CHR		;No match so skip to next word
0304   02C3             MATCH_NO_END:
0305   02C3 23          	INC	HL			;Compare next chr
0306   02C4 13          	INC	DE			;
0307   02C5 1A          	LD	A,(DE)			;
0308   02C6 AE          	XOR	(HL)			;
0309   02C7 87          	ADD	A,A			;Move bit 7 to C flag
0310   02C8 20 16       	JR	NZ,NO_MATCH		;No match jump
0311   02CA 30 F7       	JR	NC,MATCH_NO_END		;Match & not last, so next chr
0312   02CC 21 05 00    	LD	HL,0005			;Offset to start of code
0313   02CF 19          	ADD	HL,DE			;HL now points to code start for word
0314   02D0 E3          	EX	(SP),HL			;Swap with value on stack
0315   02D1             NOT_WORD_BYTE:
0316   02D1 1B          	DEC	DE			;Search back for word type byte
0317   02D2 1A          	LD	A,(DE)			;
0318   02D3 B7          	OR	A			;
0319   02D4 F2 D1 02    	JP	P,NOT_WORD_BYTE		;Not yet so loop
0320   02D7 5F          	LD	E,A			;Byte into DE
0321   02D8 16 00       	LD	D,00			;
0322   02DA 21 01 00    	LD	HL,0001			;Leave TRUE flag
0323   02DD C3 9C 01    	JP	NEXTS2			;Save both & NEXT
0324   02E0             NO_MATCH:
0325   02E0 38 06       	JR	C,END_CHR		;If last chr then jump
0326   02E2             NOT_END_CHR:
0327   02E2 13          	INC	DE			;Next chr of this vocab word
0328   02E3 1A          	LD	A,(DE)			;Get it
0329   02E4 B7          	OR	A			;Set flags
0330   02E5 F2 E2 02    	JP	P,NOT_END_CHR		;Loop if not end chr
0331   02E8             END_CHR:
0332   02E8 13          	INC	DE			;Now points to next word vector
0333   02E9 EB          	EX	DE,HL			;Swap
0334   02EA 5E          	LD	E,(HL)			;Vector into DE
0335   02EB 23          	INC	HL			;
0336   02EC 56          	LD	D,(HL)			;
0337   02ED 7A          	LD	A,D			;Check it's not last (first) word
0338   02EE B3          	OR	E			;
0339   02EF 20 CA       	JR	NZ,COMPARE		;No error so loop
0340   02F1 E1          	POP	HL			;Dump pointer
0341   02F2 21 00 00    	LD	HL,0000			;Flag error
0342   02F5 C3 9D 01    	JP	NEXTS1			;Save & NEXT
0343   02F8             
0344   02F8             W_ENCLOSE:
0345   02F8 87454E434C4F	.BYTE	87h,"ENCLOS",'E'+80h
0345   02FE 53C5
0346   0300 AF 02       	.WORD	W_FIND
0347   0302             C_ENCLOSE:
0348   0302 04 03       	.WORD	2+$			;Vector to code
0349   0304 D1          	POP	DE			; get delimiter character
0350   0305 E1          	POP	HL			; get address 1
0351   0306 E5          	PUSH	HL			; duplicate it
0352   0307 7B          	LD	A,E			; delimiter char into A
0353   0308 57          	LD	D,A			; copy to D
0354   0309 1E FF       	LD	E,00FFh			; -1 for offset
0355   030B 2B          	DEC	HL			; to allow for first INCR
0356   030C             J21E6:
0357   030C 23          	INC	HL			; point to next chr
0358   030D 1C          	INC	E			; next offset
0359   030E BE          	CP	(HL)			; compare chr with (address)
0360   030F 28 FB       	JR	Z,J21E6			; loop if = delimiter chr
0361   0311 3E 0D       	LD	A,0Dh			; else set CR
0362   0313 BE          	CP	(HL)			; compare with (address)
0363   0314 7A          	LD	A,D			; restore delimiter chr
0364   0315 28 F5       	JR	Z,J21E6			; loop if it was = CR
0365   0317 16 00       	LD	D,00h			; zero high byte
0366   0319 D5          	PUSH	DE			; save offset
0367   031A 57          	LD	D,A			; restore delimiter chr
0368   031B 7E          	LD	A,(HL)			; get byte from address
0369   031C A7          	AND	A			; set the flags
0370   031D 20 09       	JR	NZ,J2202		; branch if not null
0371   031F 16 00       	LD	D,00h			; clear high byte
0372   0321 1C          	INC	E			; point to next addr
0373   0322 D5          	PUSH	DE			; save address
0374   0323 1D          	DEC	E			; point to end
0375   0324 D5          	PUSH	DE			; push address
0376   0325 C3 9E 01    	JP	NEXT			; done
0377   0328             J2202:
0378   0328 7A          	LD	A,D			; restore delimiter chr
0379   0329 23          	INC	HL			; increment address
0380   032A 1C          	INC	E			; increment offset
0381   032B BE          	CP	(HL)			; compare delimiter with (address)
0382   032C 28 10       	JR	Z,J2218			; jump if =
0383   032E 3E 0D       	LD	A,0Dh			; else get CR
0384   0330 BE          	CP	(HL)			; compare with (address)
0385   0331 28 0B       	JR	Z,J2218			; jump if =
0386   0333 7E          	LD	A,(HL)			; else get byte
0387   0334 A7          	AND	A			; set the flags
0388   0335 20 F1       	JR	NZ,J2202		; loop if not null
0389   0337 16 00       	LD	D,00h			; clear gigh byte
0390   0339 D5          	PUSH	DE			; save address
0391   033A D5          	PUSH	DE			; save address
0392   033B C3 9E 01    	JP	NEXT			; done
0393   033E             J2218:
0394   033E 16 00       	LD	D,00h			; clear high byte
0395   0340 D5          	PUSH	DE			; save address
0396   0341 1C          	INC	E			; increment offset
0397   0342 D5          	PUSH	DE			; save address
0398   0343 C3 9E 01    	JP	NEXT			; done
0399   0346             
0400   0346             W_EMIT:					;Output CHR from stack
0401   0346 84454D49D4  	.BYTE	84h,"EMI",'T'+80h
0402   034B F8 02       	.WORD	W_ENCLOSE
0403   034D             C_EMIT:
0404   034D B4 06       	.WORD	E_COLON			;Interpret following word sequence
0405   034F F4 08       	.WORD	C_UEMIT			;Put UEMIT addr on stack
0406   0351 3A 06       	.WORD	C_FETCH			;Get UEMIT code field address
0407   0353 D9 01       	.WORD	C_EXECUTE		;Jump to address on stack
0408   0355 33 07       	.WORD	C_1
0409   0357 12 08       	.WORD	C_OUT
0410   0359 15 06       	.WORD	C_PLUSSTORE
0411   035B C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
0412   035D             
0413   035D             W_KEY:					;Wait for key, value on stack
0414   035D 83 4B 45 D9 	.BYTE	83h,"KE",'Y'+80h
0415   0361 46 03       	.WORD	W_EMIT
0416   0363             C_KEY:
0417   0363 65 03       	.WORD	2+$			;Vector to code
0418   0365 2A 52 FE    	LD	HL,(UKEY)		;Get the vector
0419   0368 E9          	JP	(HL)			;Jump to it
0420   0369             
0421   0369             W_TERMINAL:
0422   0369 893F5445524D	.BYTE	89h,"?TERMINA",'L'+80h
0422   036F 494E41CC
0423   0373 5D 03       	.WORD	W_KEY
0424   0375             C_TERMINAL:
0425   0375 B4 06       	.WORD	E_COLON			;Interpret following word sequence
0426   0377 DD 08       	.WORD	C_UTERMINAL
0427   0379 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
0428   037B D9 01       	.WORD	C_EXECUTE		;Jump to address on stack
0429   037D C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
0430   037F             
0431   037F             W_CR:					    ;Output [CR][LF]
0432   037F 82 43 D2    	.BYTE	82h,'C','R'+80h
0433   0382 69 03       	.WORD	W_TERMINAL
0434   0384             C_CR:
0435   0384 B4 06       	.WORD	E_COLON			;Interpret following word sequence
0436   0386 FE 08       	.WORD	C_UCR			;Push UCR addr
0437   0388 3A 06       	.WORD	C_FETCH			;Get UCR code field addr
0438   038A D9 01       	.WORD	C_EXECUTE		;Jump to address on stack
0439   038C C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
0440   038E             
0441   038E             W_CLS:					    ;Clear screen
0442   038E 83 43 4C D3 	.BYTE	83h,"CL",'S'+80h
0443   0392 7F 03       	.WORD	W_CR
0444   0394             C_CLS:
0445   0394 B4 06       	.WORD	E_COLON			;Interpret following word sequence
0446   0396 C4 01       	.WORD	C_LIT			;Put clear screen code on stack
0447   0398 0C 00       	.WORD	000Ch			;
0448   039A 4D 03       	.WORD	C_EMIT			;Output it
0449   039C C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
0450   039E             
0451   039E             W_CMOVE:				;Move block
0452   039E 85434D4F56C5	.BYTE	85h,"CMOV",'E'+80h
0453   03A4 8E 03       	.WORD	W_CLS
0454   03A6             C_CMOVE:
0455   03A6 A8 03       	.WORD	2+$			;Vector to code
0456   03A8 69          	LD	L,C			;Save BC for now
0457   03A9 60          	LD	H,B			;
0458   03AA C1          	POP	BC			;Get no. of bytes to move
0459   03AB D1          	POP	DE			;Get destination address
0460   03AC E3          	EX	(SP),HL			;Get source address
0461   03AD 78          	LD	A,B			;Check it's not a 0 length block
0462   03AE B1          	OR	C			;
0463   03AF 28 02       	JR	Z,NO_BYTES		;If 0 length then do nothing
0464   03B1 ED B0       	LDIR				;Move block
0465   03B3             NO_BYTES:
0466   03B3 C1          	POP	BC			;Get BC back
0467   03B4 C3 9E 01    	JP	NEXT
0468   03B7             
0469   03B7             W_USTAR:				;Unsigned multiply
0470   03B7 82 55 AA    	.BYTE	82h,'U','*'+80h
0471   03BA 9E 03       	.WORD	W_CMOVE
0472   03BC             C_USTAR:
0473   03BC BE 03       	.WORD	2+$			;Vector to code
0474   03BE D1          	POP	DE			; get n2
0475   03BF E1          	POP	HL			; get n1
0476   03C0 C5          	PUSH	BC			; save BC for now
0477   03C1 4C          	LD	C,H			; save H
0478   03C2 7D          	LD	A,L			; low byte to multiply by
0479   03C3 CD DA 03    	CALL	HALF_TIMES		; HL = A * DE
0480   03C6 E5          	PUSH	HL			; save partial result
0481   03C7 67          	LD	H,A			; clear H
0482   03C8 79          	LD	A,C			; high byte to multiply by
0483   03C9 4C          	LD	C,H			; clear B
0484   03CA CD DA 03    	CALL	HALF_TIMES		; HL = A * DE
0485   03CD D1          	POP	DE			; get last partial result
0486   03CE 41          	LD	B,C			; add partial results
0487   03CF 4A          	LD	C,D			; add partial results
0488   03D0 09          	ADD	HL,BC			;
0489   03D1 CE 00       	ADC	A,00h			;
0490   03D3 55          	LD	D,L			;
0491   03D4 6C          	LD	L,H			;
0492   03D5 67          	LD	H,A			;
0493   03D6 C1          	POP	BC			; get BC back
0494   03D7 C3 9C 01    	JP	NEXTS2			; save 32 bit result & NEXT
0495   03DA             
0496   03DA             HALF_TIMES:				;
0497   03DA 21 00 00    	LD	HL,0000h		; clear partial result
0498   03DD 06 08       	LD	B,08h			; eight bits to do
0499   03DF             NEXT_BIT:
0500   03DF 29          	ADD	HL,HL			; result * 2
0501   03E0 17          	RLA				; multiply bit into C
0502   03E1 30 03       	JR	NC,NO_MUL		; branch if no multiply
0503   03E3 19          	ADD	HL,DE			; add multiplicand
0504   03E4 CE 00       	ADC	A,00h			; add in any carry
0505   03E6             NO_MUL:
0506   03E6 10 F7       	DJNZ	NEXT_BIT		; decr and loop if not done
0507   03E8 C9          	RET				;
0508   03E9             
0509   03E9             W_UMOD:					;Unsigned divide & MOD
0510   03E9 85552F4D4FC4	.BYTE	85h,"U/MO",'D'+80h
0511   03EF B7 03       	.WORD	W_USTAR
0512   03F1             C_UMOD:
0513   03F1 F3 03       	.WORD	2+$			;Vector to code
0514   03F3 21 04 00    	LD	HL,0004
0515   03F6 39          	ADD	HL,SP
0516   03F7 5E          	LD	E,(HL)
0517   03F8 71          	LD	(HL),C
0518   03F9 23          	INC	HL
0519   03FA 56          	LD	D,(HL)
0520   03FB 70          	LD	(HL),B
0521   03FC C1          	POP	BC
0522   03FD E1          	POP	HL
0523   03FE 7D          	LD	A,L
0524   03FF 91          	SUB	C
0525   0400 7C          	LD	A,H
0526   0401 98          	SBC	A,B
0527   0402 38 08       	JR	C,J22.BYTE
0528   0404 21 FF FF    	LD	HL,0FFFFh
0529   0407 11 FF FF    	LD	DE,0FFFFh
0530   040A 18 26       	JR	J2301
0531   040C             J22.BYTE:
0532   040C 3E 10       	LD	A,10h
0533   040E             J22DD:
0534   040E 29          	ADD	HL,HL
0535   040F 17          	RLA
0536   0410 EB          	EX	DE,HL
0537   0411 29          	ADD	HL,HL
0538   0412 30 02       	JR	NC,J22E5
0539   0414 13          	INC	DE
0540   0415 A7          	AND	A
0541   0416             J22E5:
0542   0416 EB          	EX	DE,HL
0543   0417 1F          	RRA
0544   0418 F5          	PUSH	AF
0545   0419 30 08       	JR	NC,J22F2
0546   041B 7D          	LD	A,L
0547   041C 91          	SUB	C
0548   041D 6F          	LD	L,A
0549   041E 7C          	LD	A,H
0550   041F 98          	SBC	A,B
0551   0420 67          	LD	H,A
0552   0421 18 0A       	JR	J22FC
0553   0423             J22F2:
0554   0423 7D          	LD	A,L
0555   0424 91          	SUB	C
0556   0425 6F          	LD	L,A
0557   0426 7C          	LD	A,H
0558   0427 98          	SBC	A,B
0559   0428 67          	LD	H,A
0560   0429 30 02       	JR	NC,J22FC
0561   042B 09          	ADD	HL,BC
0562   042C 1B          	DEC	DE
0563   042D             J22FC:
0564   042D 13          	INC	DE
0565   042E F1          	POP	AF
0566   042F 3D          	DEC	A
0567   0430 20 DC       	JR	NZ,J22DD
0568   0432             J2301:
0569   0432 C1          	POP	BC
0570   0433 E5          	PUSH	HL
0571   0434 D5          	PUSH	DE
0572   0435 C3 9E 01    	JP	NEXT
0573   0438             
0574   0438             W_AND:					;AND
0575   0438 83 41 4E C4 	.BYTE	83h,"AN",'D'+80h
0576   043C E9 03       	.WORD	W_UMOD
0577   043E             C_AND:
0578   043E 40 04       	.WORD	2+$			;Vector to code
0579   0440 D1          	POP	DE			;Get n1 off stack
0580   0441 E1          	POP	HL			;Get n2 off stack
0581   0442 7B          	LD	A,E			;AND lo bytes
0582   0443 A5          	AND	L			;
0583   0444 6F          	LD	L,A			;Result in L
0584   0445 7A          	LD	A,D			;AND hi bytes
0585   0446 A4          	AND	H			;
0586   0447 67          	LD	H,A			;Result in H
0587   0448 C3 9D 01    	JP	NEXTS1			;Save & next
0588   044B             
0589   044B             W_OR:					;OR
0590   044B 82 4F D2    	.BYTE	82h,'O','R'+80h
0591   044E 38 04       	.WORD	W_AND
0592   0450             C_OR:
0593   0450 52 04       	.WORD	2+$			;Vector to code
0594   0452 D1          	POP	DE			;Get n1 off stack
0595   0453 E1          	POP	HL			;Get n2 off stack
0596   0454 7B          	LD	A,E			;OR lo bytes
0597   0455 B5          	OR	L			;
0598   0456 6F          	LD	L,A			;Result in L
0599   0457 7A          	LD	A,D			;OR hi bytes
0600   0458 B4          	OR	H			;
0601   0459 67          	LD	H,A			;Result in H
0602   045A C3 9D 01    	JP	NEXTS1			;Save & next
0603   045D             
0604   045D             W_XOR:					;XOR
0605   045D 83 58 4F D2 	.BYTE	83h,"XO",'R'+80h
0606   0461 4B 04       	.WORD	W_OR
0607   0463             C_XOR:
0608   0463 65 04       	.WORD	2+$			;Vector to code
0609   0465 D1          	POP	DE			;Get n1 off stack
0610   0466 E1          	POP	HL			;Get n2 off stack
0611   0467 7B          	LD	A,E			;XOR lo bytes
0612   0468 AD          	XOR	L			;
0613   0469 6F          	LD	L,A			;Result in L
0614   046A 7A          	LD	A,D			;XOR hi bytes
0615   046B AC          	XOR	H			;
0616   046C 67          	LD	H,A			;Result in H
0617   046D C3 9D 01    	JP	NEXTS1			;Save & NEXT
0618   0470             
0619   0470             W_SPFETCH:				;Stack pointer onto stack
0620   0470 83 53 50 C0 	.BYTE	83h,"SP",'@'+80h
0621   0474 5D 04       	.WORD	W_XOR
0622   0476             C_SPFETCH:
0623   0476 78 04       	.WORD	2+$			;Vector to code
0624   0478 21 00 00    	LD	HL,0000			;No offset
0625   047B 39          	ADD	HL,SP			;Add SP to HL
0626   047C C3 9D 01    	JP	NEXTS1			;Save & NEXT
0627   047F             
0628   047F             W_SPSTORE:				;Set initial stack pointer value
0629   047F 83 53 50 A1 	.BYTE	83h,"SP",'!'+80h
0630   0483 70 04       	.WORD	W_SPFETCH
0631   0485             C_SPSTORE:
0632   0485 87 04       	.WORD	2+$			;Vector to code
0633   0487 2A 5A 01    	LD	HL,(DEF_SYSADDR)	;Get system base addr
0634   048A 11 06 00    	LD	DE,S0-SYSTEM		;Offset to stack pointer value (0006)
0635   048D 19          	ADD	HL,DE			;Add to base addr
0636   048E 5E          	LD	E,(HL)			;Get SP from ram
0637   048F 23          	INC	HL			;
0638   0490 56          	LD	D,(HL)			;
0639   0491 EB          	EX	DE,HL			;Put into HL
0640   0492 F9          	LD	SP,HL			;Set SP
0641   0493 C3 9E 01    	JP	NEXT
0642   0496             
0643   0496             W_RPFETCH:				;Get return stack pointer
0644   0496 83 52 50 C0 	.BYTE	83h,"RP",'@'+80h
0645   049A 7F 04       	.WORD	W_SPSTORE
0646   049C             C_RPFETCH:
0647   049C 9E 04       	.WORD	2+$			;Vector to code
0648   049E 2A 46 FE    	LD	HL,(RPP)		;Return stack pointer into HL
0649   04A1 C3 9D 01    	JP	NEXTS1			;Save & NEXT
0650   04A4             
0651   04A4             W_RPSTORE:				;Set initial return stack pointer
0652   04A4 83 52 50 A1 	.BYTE	83h,"RP",'!'+80h
0653   04A8 96 04       	.WORD	W_RPFETCH
0654   04AA             C_RPSTORE:
0655   04AA AC 04       	.WORD	2+$			;Vector to code
0656   04AC 2A 5A 01    	LD	HL,(DEF_SYSADDR)	;Get system base addr
0657   04AF 11 08 00    	LD	DE,0008			;Offset to return stack pointer value
0658   04B2 19          	ADD	HL,DE			;Add to base addr
0659   04B3 5E          	LD	E,(HL)			;Get SP from ram
0660   04B4 23          	INC	HL			;
0661   04B5 56          	LD	D,(HL)			;
0662   04B6 EB          	EX	DE,HL			;Put into HL
0663   04B7 22 46 FE    	LD	(RPP),HL		;Set return SP
0664   04BA C3 9E 01    	JP	NEXT
0665   04BD             
0666   04BD             W_STOP:					;Pop BC from return stack (=next)
0667   04BD 82 3B D3    	.BYTE	82h,';','S'+80h
0668   04C0 A4 04       	.WORD	W_RPSTORE
0669   04C2             C_STOP:
0670   04C2 C4 04       	.WORD	2+$			;Vector to code
0671   04C4             X_STOP:
0672   04C4 2A 46 FE    	LD	HL,(RPP)		;Return stack pointer to HL
0673   04C7 4E          	LD	C,(HL)			;Get low byte
0674   04C8 23          	INC	HL			;
0675   04C9 46          	LD	B,(HL)			;Get high byte
0676   04CA 23          	INC	HL			;
0677   04CB 22 46 FE    	LD	(RPP),HL		;Save stack pointer
0678   04CE C3 9E 01    	JP	NEXT
0679   04D1             
0680   04D1             W_LEAVE:				;Quit loop by making index = limit
0681   04D1 854C454156C5	.BYTE	85h,"LEAV",'E'+80h
0682   04D7 BD 04       	.WORD	W_STOP
0683   04D9             C_LEAVE:
0684   04D9 DB 04       	.WORD	2+$			;Vector to code
0685   04DB 2A 46 FE    	LD	HL,(RPP)		;Get return stack pointer
0686   04DE 5E          	LD	E,(HL)			;Get loop limit low
0687   04DF 23          	INC	HL			;
0688   04E0 56          	LD	D,(HL)			;Get loop limit high
0689   04E1 23          	INC	HL			;
0690   04E2 73          	LD	(HL),E			;Set index low to loop limit
0691   04E3 23          	INC	HL			;
0692   04E4 72          	LD	(HL),D			;Set index high to loop limit
0693   04E5 C3 9E 01    	JP	NEXT
0694   04E8             
0695   04E8             W_MOVER:				;Move from data to return stack
0696   04E8 82 3E D2    	.BYTE	82h,'>','R'+80h
0697   04EB D1 04       	.WORD	W_LEAVE
0698   04ED             C_MOVER:
0699   04ED EF 04       	.WORD	2+$			;Vector to code
0700   04EF D1          	POP	DE			;Get value
0701   04F0 2A 46 FE    	LD	HL,(RPP)		;Get return stack pointer
0702   04F3 2B          	DEC	HL			;Set new value
0703   04F4 2B          	DEC	HL			;
0704   04F5 22 46 FE    	LD	(RPP),HL		;Save it
0705   04F8 73          	LD	(HL),E			;Push low byte onto return stack
0706   04F9 23          	INC	HL			;
0707   04FA 72          	LD	(HL),D			;Push high byte onto return stack
0708   04FB C3 9E 01    	JP	NEXT
0709   04FE             
0710   04FE             W_RMOVE:				;Move word from return to data stack
0711   04FE 82 52 BE    	.BYTE	82h,'R','>'+80h
0712   0501 E8 04       	.WORD	W_MOVER
0713   0503             C_RMOVE:
0714   0503 05 05       	.WORD	2+$			;Vector to code
0715   0505 2A 46 FE    	LD	HL,(RPP)		;Get return stack pointer
0716   0508 5E          	LD	E,(HL)			;Pop word off return stack
0717   0509 23          	INC	HL			;
0718   050A 56          	LD	D,(HL)			;
0719   050B 23          	INC	HL			;
0720   050C 22 46 FE    	LD	(RPP),HL		;Save new return stack pointer
0721   050F D5          	PUSH	DE			;Push on data stack
0722   0510 C3 9E 01    	JP	NEXT
0723   0513             
0724   0513             W_RFETCH:				;Return stack top to data stack
0725   0513 82 52 C0    	.BYTE	82h,'R','@'+80h
0726   0516 FE 04       	.WORD	W_RMOVE
0727   0518             C_RFETCH:
0728   0518 78 02       	.WORD	X_I			;Return stack top to data stack
0729   051A             
0730   051A             W_0EQUALS:				;=0
0731   051A 82 30 BD    	.BYTE	82h,'0','='+80h
0732   051D 13 05       	.WORD	W_RFETCH
0733   051F             C_0EQUALS:
0734   051F 21 05       	.WORD	2+$			;Vector to code
0735   0521             X_0EQUALS:
0736   0521 E1          	POP	HL			;Get value from stack
0737   0522 7D          	LD	A,L			;set flags
0738   0523 B4          	OR	H			;
0739   0524 21 00 00    	LD	HL,0000			;Not = 0 flag
0740   0527 20 01       	JR	NZ,NO_ZERO		;
0741   0529 23          	INC	HL			;= 0 flag
0742   052A             NO_ZERO:
0743   052A C3 9D 01    	JP	NEXTS1			;Save & NEXT
0744   052D             
0745   052D             W_NOT:					;Convert flag, same as 0=
0746   052D 83 4E 4F D4 	.BYTE	83h,"NO",'T'+80h
0747   0531 1A 05       	.WORD	W_0EQUALS
0748   0533             C_NOT:
0749   0533 21 05       	.WORD	X_0EQUALS
0750   0535             
0751   0535             W_0LESS:				;Less than 0
0752   0535 82 30 BC    	.BYTE	82h,'0','<'+80h
0753   0538 2D 05       	.WORD	W_NOT
0754   053A             C_0LESS:
0755   053A 3C 05       	.WORD	2+$			;Vector to code
0756   053C E1          	POP	HL			;Get value
0757   053D 29          	ADD	HL,HL			;S bit into C
0758   053E 21 00 00    	LD	HL,0000			;Wasn't < 0 flag
0759   0541 30 01       	JR	NC,NOT_LT0		;
0760   0543 23          	INC	HL			;Was < 0 flag
0761   0544             NOT_LT0:				;
0762   0544 C3 9D 01    	JP	NEXTS1			;Save & NEXT
0763   0547             
0764   0547             W_PLUS:					;n1 + n2
0765   0547 81 AB       	.BYTE	81h,'+'+80h
0766   0549 35 05       	.WORD	W_0LESS
0767   054B             C_PLUS:
0768   054B 4D 05       	.WORD	2+$			;Vector to code
0769   054D D1          	POP	DE			;Get n2
0770   054E E1          	POP	HL			;Get n1
0771   054F 19          	ADD	HL,DE			;Add them
0772   0550 C3 9D 01    	JP	NEXTS1			;Save & NEXT
0773   0553             
0774   0553             W_DPLUS:				;32 bit add
0775   0553 82 44 AB    	.BYTE	82h,'D','+'+80h
0776   0556 47 05       	.WORD	W_PLUS
0777   0558             C_DPLUS:
0778   0558 5A 05       	.WORD	2+$			;Vector to code
0779   055A 21 06 00    	LD	HL,0006			; offset to low word
0780   055D 39          	ADD	HL,SP			; add stack pointer
0781   055E 5E          	LD	E,(HL)			; get d1 low word low byte
0782   055F 71          	LD	(HL),C			; save BC low byte
0783   0560 23          	INC	HL			; point to high byte
0784   0561 56          	LD	D,(HL)			; get d1 low word high byte
0785   0562 70          	LD	(HL),B			; save BC high byte
0786   0563 C1          	POP	BC			; get high word d2
0787   0564 E1          	POP	HL			; get low word d2
0788   0565 19          	ADD	HL,DE			; add low wor.BLOCK
0789   0566 EB          	EX	DE,HL			; save result low word in DE
0790   0567 E1          	POP	HL			; get d1 high word
0791   0568 7D          	LD	A,L			; copy d1 high word low byte
0792   0569 89          	ADC	A,C			; add d2 high word low byte
0793   056A             					; + carry from low word add
0794   056A 6F          	LD	L,A			; result from high word low byte into L
0795   056B 7C          	LD	A,H			; copy d1 high word low byte
0796   056C 88          	ADC	A,B			; add d2 high word low byte
0797   056D             					; + carry from high word low byte add
0798   056D 67          	LD	H,A			; result from high word high byte into H
0799   056E C1          	POP	BC			; restore BC
0800   056F C3 9C 01    	JP	NEXTS2			;Save 32 bit result & NEXT
0801   0572             
0802   0572             W_NEGATE:				;Form 2s complement of n
0803   0572 864E45474154	.BYTE	86h,"NEGAT",'E'+80h
0803   0578 C5
0804   0579 53 05       	.WORD	W_DPLUS
0805   057B             C_NEGATE:
0806   057B 7D 05       	.WORD	2+$			;Vector to code
0807   057D E1          	POP	HL			;Get number
0808   057E 7D          	LD	A,L			;Low byte into A
0809   057F 2F          	CPL				;Complement it
0810   0580 6F          	LD	L,A			;Back into L
0811   0581 7C          	LD	A,H			;High byte into A
0812   0582 2F          	CPL				;Complement it
0813   0583 67          	LD	H,A			;Back into H
0814   0584 23          	INC	HL			;+1
0815   0585 C3 9D 01    	JP	NEXTS1			;Save & NEXT
0816   0588             
0817   0588             W_DNEGATE:				;Form 2s complement of 32 bit n
0818   0588 87444E454741	.BYTE	87h,"DNEGAT",'E'+80h
0818   058E 54C5
0819   0590 72 05       	.WORD	W_NEGATE
0820   0592             C_DNEGATE:
0821   0592 94 05       	.WORD	2+$			;Vector to code
0822   0594 E1          	POP	HL			; get high word
0823   0595 D1          	POP	DE			; get low word
0824   0596 97          	SUB	A			; clear A
0825   0597 93          	SUB	E			; negate low word low byte
0826   0598 5F          	LD	E,A			; copy back to E
0827   0599 3E 00       	LD	A,00h			; clear A
0828   059B 9A          	SBC	A,D			; negate low word high byte
0829   059C 57          	LD	D,A			; copy back to D
0830   059D 3E 00       	LD	A,00h			; clear A
0831   059F 9D          	SBC	A,L			; negate high word low byte
0832   05A0 6F          	LD	L,A			; copy back to L
0833   05A1 3E 00       	LD	A,00h			; clear A
0834   05A3 9C          	SBC	A,H			; negate high word high byte
0835   05A4 67          	LD	H,A			; copy back to H
0836   05A5 C3 9C 01    	JP	NEXTS2			;Save 32 bit result & NEXT
0837   05A8             
0838   05A8             W_OVER:					;Copy 2nd down to top of stack
0839   05A8 844F5645D2  	.BYTE	84h,"OVE",'R'+80h
0840   05AD 88 05       	.WORD	W_DNEGATE
0841   05AF             C_OVER:
0842   05AF B1 05       	.WORD	2+$			;Vector to code
0843   05B1 D1          	POP	DE			;Get top
0844   05B2 E1          	POP	HL			;Get next
0845   05B3 E5          	PUSH	HL			;Save it back
0846   05B4 C3 9C 01    	JP	NEXTS2			;Save both & NEXT
0847   05B7             
0848   05B7             W_DROP:					;Drop top value from stack
0849   05B7 8444524FD0  	.BYTE	84h,"DRO",'P'+80h
0850   05BC A8 05       	.WORD	W_OVER
0851   05BE             C_DROP:
0852   05BE C0 05       	.WORD	2+$			;Vector to code
0853   05C0 E1          	POP	HL			;Get top value
0854   05C1 C3 9E 01    	JP	NEXT
0855   05C4             
0856   05C4             W_2DROP:				;Drop top two values from stack
0857   05C4 853244524FD0	.BYTE	85h,"2DRO",'P'+80h
0858   05CA B7 05       	.WORD	W_DROP
0859   05CC             C_2DROP:
0860   05CC CE 05       	.WORD	2+$			;Vector to code
0861   05CE E1          	POP	HL			;Get top value
0862   05CF E1          	POP	HL			;Get top value
0863   05D0 C3 9E 01    	JP	NEXT
0864   05D3             
0865   05D3             W_SWAP:					;Swap top 2 values on stack
0866   05D3 84535741D0  	.BYTE	84h,"SWA",'P'+80h
0867   05D8 C4 05       	.WORD	W_2DROP
0868   05DA             C_SWAP:
0869   05DA DC 05       	.WORD	2+$			;Vector to code
0870   05DC E1          	POP	HL			;Get top value
0871   05DD E3          	EX	(SP),HL			;Exchanhe with next down
0872   05DE C3 9D 01    	JP	NEXTS1			;Save & NEXT
0873   05E1             
0874   05E1             W_DUP:					;Duplicate top value on stack
0875   05E1 83 44 55 D0 	.BYTE	83h,"DU",'P'+80h
0876   05E5 D3 05       	.WORD	W_SWAP
0877   05E7             C_DUP:
0878   05E7 E9 05       	.WORD	2+$			;Vector to code
0879   05E9 E1          	POP	HL			;Get value off stack
0880   05EA E5          	PUSH	HL			;Copy it back
0881   05EB C3 9D 01    	JP	NEXTS1			;Save & NEXT
0882   05EE             
0883   05EE             W_2DUP:					;Dup top 2 values on stack
0884   05EE 84324455D0  	.BYTE	84h,"2DU",'P'+80h
0885   05F3 E1 05       	.WORD	W_DUP
0886   05F5             C_2DUP:
0887   05F5 F7 05       	.WORD	2+$			;Vector to code
0888   05F7 E1          	POP	HL			;Get top two values from stack
0889   05F8 D1          	POP	DE			;
0890   05F9 D5          	PUSH	DE			;Copy them back
0891   05FA E5          	PUSH	HL			;
0892   05FB C3 9C 01    	JP	NEXTS2			;Save both & NEXT
0893   05FE             
0894   05FE             W_BOUNDS:				;Convert address & n to start & end
0895   05FE 86424F554E44	.BYTE	86h,"BOUND",'S'+80h
0895   0604 D3
0896   0605 EE 05       	.WORD	W_2DUP
0897   0607             C_BOUNDS:
0898   0607 09 06       	.WORD	2+$			;Vector to code
0899   0609 E1          	POP	HL			; get n
0900   060A D1          	POP	DE			; get addr
0901   060B 19          	ADD	HL,DE			; add addr to n
0902   060C EB          	EX	DE,HL			; swap them
0903   060D C3 9C 01    	JP	NEXTS2			; save both & NEXT
0904   0610             
0905   0610             W_PLUSSTORE:				;Add n1 to addr
0906   0610 82 2B A1    	.BYTE	82h,'+','!'+80h
0907   0613 FE 05       	.WORD	W_BOUNDS
0908   0615             C_PLUSSTORE:
0909   0615 17 06       	.WORD	2+$			;Vector to code
0910   0617 E1          	POP	HL			;Get addr
0911   0618 D1          	POP	DE			;Get DE
0912   0619 7E          	LD	A,(HL)			;Add low bytes
0913   061A 83          	ADD	A,E			;
0914   061B 77          	LD	(HL),A			;Store result
0915   061C 23          	INC	HL			;Point to high byte
0916   061D 7E          	LD	A,(HL)			;Add high bytes
0917   061E 8A          	ADC	A,D			;
0918   061F 77          	LD	(HL),A			;Store result
0919   0620 C3 9E 01    	JP	NEXT
0920   0623             
0921   0623             W_TOGGLE:				;XOR (addr) with byte
0922   0623 86544F47474C	.BYTE	86h,"TOGGL",'E'+80h
0922   0629 C5
0923   062A 10 06       	.WORD	W_PLUSSTORE
0924   062C             C_TOGGLE:
0925   062C 2E 06       	.WORD	2+$			;Vector to code
0926   062E D1          	POP	DE			 	;Get byte
0927   062F E1          	POP	HL				;Get addr
0928   0630 7E          	LD	A,(HL)			;Get byte from addr
0929   0631 AB          	XOR	E				;Toggle it
0930   0632 77          	LD	(HL),A			;Save result
0931   0633 C3 9E 01    	JP	NEXT
0932   0636             
0933   0636             W_FETCH:				;Get word from addr on stack
0934   0636 81 C0       	.BYTE	81h,'@'+80h
0935   0638 23 06       	.WORD	W_TOGGLE
0936   063A             C_FETCH:
0937   063A 3C 06       	.WORD	2+$			;Vector to code
0938   063C E1          	POP	HL			;Get addr
0939   063D 5E          	LD	E,(HL)			;Get low byte
0940   063E 23          	INC	HL			;
0941   063F 56          	LD	D,(HL)			;Get high byte
0942   0640 D5          	PUSH	DE			;Save it
0943   0641 C3 9E 01    	JP	NEXT
0944   0644             
0945   0644             W_CFETCH:				;Get byte from addr on stack
0946   0644 82 43 C0    	.BYTE	82h,'C','@'+80h
0947   0647 36 06       	.WORD	W_FETCH
0948   0649             C_CFETCH:
0949   0649 4B 06       	.WORD	2+$			;Vector to code
0950   064B E1          	POP	HL			;Get addr
0951   064C 6E          	LD	L,(HL)			;Get byte
0952   064D 26 00       	LD	H,00h			;Top byte = 0
0953   064F C3 9D 01    	JP	NEXTS1			;Save & NEXT
0954   0652             
0955   0652             W_2FETCH:				;Get word from addr+2 and addr
0956   0652 82 32 C0    	.BYTE	82h,'2','@'+80h
0957   0655 44 06       	.WORD	W_CFETCH
0958   0657             C_2FETCH:
0959   0657 59 06       	.WORD	2+$			;Vector to code
0960   0659 E1          	POP	HL			;Get addr
0961   065A 11 02 00    	LD	DE,0002			;Plus 2 bytes
0962   065D 19          	ADD	HL,DE			;Get 2nd word first
0963   065E 5E          	LD	E,(HL)			;Low byte
0964   065F 23          	INC	HL			;
0965   0660 56          	LD	D,(HL)			;High byte
0966   0661 D5          	PUSH	DE			;Save it
0967   0662 11 FD FF    	LD	DE,0FFFDh		;Minus 2 bytes
0968   0665 19          	ADD	HL,DE			;Get 1st word
0969   0666 5E          	LD	E,(HL)			;Low byte
0970   0667 23          	INC	HL			;
0971   0668 56          	LD	D,(HL)			;High byte
0972   0669 D5          	PUSH	DE			;Save it
0973   066A C3 9E 01    	JP	NEXT
0974   066D             
0975   066D             W_STORE:				;Store word at addr
0976   066D 81 A1       	.BYTE	81h,'!'+80h
0977   066F 52 06       	.WORD	W_2FETCH
0978   0671             C_STORE:
0979   0671 73 06       	.WORD	2+$			;Vector to code
0980   0673 E1          	POP	HL			;Get addr
0981   0674 D1          	POP	DE			;Get word
0982   0675 73          	LD	(HL),E			;Store low byte
0983   0676 23          	INC	HL			;
0984   0677 72          	LD	(HL),D			;Store high byte
0985   0678 C3 9E 01    	JP	NEXT
0986   067B             
0987   067B             W_CSTORE:				;Store byte at addr
0988   067B 82 43 A1    	.BYTE	82h,'C','!'+80h
0989   067E 6D 06       	.WORD	W_STORE
0990   0680             C_CSTORE:
0991   0680 82 06       	.WORD	2+$			;Vector to code
0992   0682 E1          	POP	HL			;Get addr
0993   0683 D1          	POP	DE			;Get byte
0994   0684 73          	LD	(HL),E			;Save it
0995   0685 C3 9E 01    	JP	NEXT
0996   0688             
0997   0688             W_2STORE:				;Store 2 words at addr (+2)
0998   0688 82 32 A1    	.BYTE	82h,'2','!'+80h
0999   068B 7B 06       	.WORD	W_CSTORE
1000   068D             C_2STORE:
1001   068D 8F 06       	.WORD	2+$			;Vector to code
1002   068F E1          	POP	HL			;Get addr
1003   0690 D1          	POP	DE			;Get word
1004   0691 73          	LD	(HL),E			;Save low byte
1005   0692 23          	INC	HL			;
1006   0693 72          	LD	(HL),D			;Save high byte
1007   0694 23          	INC	HL			;
1008   0695 D1          	POP	DE			;Get next word
1009   0696 73          	LD	(HL),E			;Save low byte
1010   0697 23          	INC	HL			;
1011   0698 72          	LD	(HL),D			;Save high byte
1012   0699 C3 9E 01    	JP	NEXT
1013   069C             
1014   069C             W_COLON:
1015   069C 81 BA       	.BYTE	81h,':'+80h
1016   069E 88 06       	.WORD	W_2STORE
1017   06A0             C_COLON:
1018   06A0 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1019   06A2 0B 0C       	.WORD	C_QEXEC			;Error not if not in execute mode
1020   06A4 C6 0B       	.WORD	C_CSPSTORE		;Set current stack pointer value
1021   06A6 45 08       	.WORD	C_CURRENT		;Get CURRENT addr
1022   06A8 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
1023   06AA 37 08       	.WORD	C_CONTEXT		;Make CONTEXT current vocab
1024   06AC 71 06       	.WORD	C_STORE			;Store word at addr
1025   06AE AF 10       	.WORD	C_XXX1			;Puts name into dictionary
1026   06B0 90 0C       	.WORD	C_RIGHTBRKT		;Set STATE to compile
1027   06B2 E3 0C       	.WORD	C_CCODE			;Execute following machine code
1028   06B4             
1029   06B4             E_COLON:
1030   06B4 2A 46 FE    	LD	HL,(RPP)		;Get return stack pointer
1031   06B7 2B          	DEC	HL			;Put BC on return stack
1032   06B8 70          	LD	(HL),B			;
1033   06B9 2B          	DEC	HL			;
1034   06BA 71          	LD	(HL),C			;
1035   06BB 22 46 FE    	LD	(RPP),HL		;Save new pointer
1036   06BE 13          	INC	DE
1037   06BF 4B          	LD	C,E
1038   06C0 42          	LD	B,D
1039   06C1 C3 9E 01    	JP	NEXT
1040   06C4             
1041   06C4             W_SEMICOLON:				;Terminate compilation
1042   06C4 C1 BB       	.BYTE	0C1h,';'+80h
1043   06C6 9C 06       	.WORD	W_COLON
1044   06C8             C_SEMICOLON:
1045   06C8 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1046   06CA F3 0B       	.WORD	C_QCOMP			;Check we're allready compiling
1047   06CC 35 0C       	.WORD	C_WHATSTACK		;Check stack pointer, error if not ok
1048   06CE 6C 0C       	.WORD	C_COMPILE		;Compile next word into dictionary
1049   06D0 C2 04       	.WORD	C_STOP			;
1050   06D2 A5 0C       	.WORD	C_SMUDGE		;Smudge bit to O.K.
1051   06D4 82 0C       	.WORD	C_LEFTBRKT		;Set STATE to execute
1052   06D6 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1053   06D8             
1054   06D8             W_CONSTANT:
1055   06D8 88434F4E5354	.BYTE	88h,"CONSTAN",'T'+80h
1055   06DE 414ED4
1056   06E1 C4 06       	.WORD	W_SEMICOLON
1057   06E3             C_CONSTANT:
1058   06E3 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1059   06E5 AF 10       	.WORD	C_XXX1
1060   06E7 A5 0C       	.WORD	C_SMUDGE
1061   06E9 6B 0A       	.WORD	C_COMMA			;Reserve 2 bytes and save n
1062   06EB E3 0C       	.WORD	C_CCODE			;Execute following machine code
1063   06ED             
1064   06ED             X_CONSTANT:				;Put next word on stack
1065   06ED 13          	INC	DE			;Adjust pointer
1066   06EE EB          	EX	DE,HL			;Get next word
1067   06EF 5E          	LD	E,(HL)			;
1068   06F0 23          	INC	HL			;
1069   06F1 56          	LD	D,(HL)			;
1070   06F2 D5          	PUSH	DE			;Put on stack
1071   06F3 C3 9E 01    	JP	NEXT
1072   06F6             
1073   06F6             W_VARIABLE:
1074   06F6 885641524941	.BYTE	88h,"VARIABL",'E'+80h
1074   06FC 424CC5
1075   06FF D8 06       	.WORD	W_CONSTANT
1076   0701             C_VARIABLE:
1077   0701 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1078   0703 2B 07       	.WORD	C_ZERO			;Put zero on stack
1079   0705 E3 06       	.WORD	C_CONSTANT
1080   0707 E3 0C       	.WORD	C_CCODE			;Execute following machine code
1081   0709             
1082   0709             X_VARIABLE:
1083   0709 13          	INC	DE
1084   070A D5          	PUSH	DE
1085   070B C3 9E 01    	JP	NEXT
1086   070E             
1087   070E             W_USER:
1088   070E 84555345D2  	.BYTE	84h,"USE",'R'+80h
1089   0713 F6 06       	.WORD	W_VARIABLE
1090   0715             C_USER:
1091   0715 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1092   0717 E3 06       	.WORD	C_CONSTANT
1093   0719 E3 0C       	.WORD	C_CCODE			;Execute following machine code
1094   071B             
1095   071B             X_USER:
1096   071B 13          	INC	DE			;Adjust to next word
1097   071C EB          	EX	DE,HL
1098   071D 5E          	LD	E,(HL)
1099   071E 23          	INC	HL
1100   071F 56          	LD	D,(HL)
1101   0720 2A 5A 01    	LD	HL,(DEF_SYSADDR)
1102   0723 19          	ADD	HL,DE
1103   0724 C3 9D 01    	JP	NEXTS1			;Save & NEXT
1104   0727             
1105   0727             W_ZERO:					;Put zero on stack
1106   0727 81 B0       	.BYTE	81h,'0'+80h
1107   0729 0E 07       	.WORD	W_USER
1108   072B             C_ZERO:
1109   072B ED 06       	.WORD	X_CONSTANT		;Put next word on stack
1110   072D 00 00       	.WORD	0000h
1111   072F             
1112   072F             W_1:					;Put 1 on stack
1113   072F 81 B1       	.BYTE	81h,'1'+80h
1114   0731 27 07       	.WORD	W_ZERO
1115   0733             C_1:
1116   0733 ED 06       	.WORD	X_CONSTANT		;Put next word on stack
1117   0735 01 00       	.WORD	0001h
1118   0737             
1119   0737             W_2:
1120   0737 81 B2       	.BYTE	81h,'2'+80h
1121   0739 2F 07       	.WORD	W_1
1122   073B             C_2:
1123   073B ED 06       	.WORD	X_CONSTANT		;Put next word on stack
1124   073D 02 00       	.WORD	0002h
1125   073F             
1126   073F             W_3:
1127   073F 81 B3       	.BYTE	81h,'3'+80h
1128   0741 37 07       	.WORD	W_2
1129   0743             C_3:
1130   0743 ED 06       	.WORD	X_CONSTANT		;Put next word on stack
1131   0745 03 00       	.WORD	0003h
1132   0747             
1133   0747             W_BL:					;Leaves ASCII for blank on stack
1134   0747 82 42 CC    	.BYTE	82h,'B','L'+80h
1135   074A 3F 07       	.WORD	W_3
1136   074C             C_BL:
1137   074C ED 06       	.WORD	X_CONSTANT		;Put next word on stack
1138   074E 20 00       	.WORD	0020h
1139   0750             
1140   0750             W_CL:
1141   0750 83 43 2F CC 	.BYTE	83h,"C/",'L'+80h
1142   0754 47 07       	.WORD	W_BL
1143   0756             C_CL:
1144   0756 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1145   0758 98 08       	.WORD	C_UCL
1146   075A 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
1147   075C C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1148   075E             
1149   075E             W_FIRST:
1150   075E 8546495253D4	.BYTE	85h,"FIRS",'T'+80h
1151   0764 50 07       	.WORD	W_CL
1152   0766             C_FIRST:
1153   0766 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1154   0768 A5 08       	.WORD	C_UFIRST		;Put UFIRST addr on stack
1155   076A 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
1156   076C C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1157   076E             
1158   076E             W_LIMIT:
1159   076E 854C494D49D4	.BYTE	85h,"LIMI",'T'+80h
1160   0774 5E 07       	.WORD	W_FIRST
1161   0776             C_LIMIT:
1162   0776 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1163   0778 B2 08       	.WORD	C_ULIMIT		;Put ULIMIT on stack
1164   077A 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
1165   077C C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1166   077E             
1167   077E             W_BBUF:
1168   077E 85422F4255C6	.BYTE	85h,"B/BU",'F'+80h
1169   0784 6E 07       	.WORD	W_LIMIT
1170   0786             C_BBUF:
1171   0786 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1172   0788 BF 08       	.WORD	C_UBBUF
1173   078A 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
1174   078C C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1175   078E             
1176   078E             W_BSCR:
1177   078E 85422F5343D2	.BYTE	85h,"B/SC",'R'+80h
1178   0794 7E 07       	.WORD	W_BBUF
1179   0796             C_BSCR:
1180   0796 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1181   0798 CC 08       	.WORD	C_UBSCR			;Number of buffers per block
1182   079A 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
1183   079C C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1184   079E             
1185   079E             W_S0:					;Push S0 (initial data stack pointer)
1186   079E 82 53 B0    	.BYTE	82h,'S','0'+80h
1187   07A1 8E 07       	.WORD	W_BSCR
1188   07A3             C_S0:
1189   07A3 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1190   07A5 06 00       	.WORD	S0-SYSTEM
1191   07A7             
1192   07A7             W_R0:
1193   07A7 82 52 B0    	.BYTE	82h,'R','0'+80h
1194   07AA 9E 07       	.WORD	W_S0
1195   07AC             C_R0:
1196   07AC 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1197   07AE 08 00       	.WORD	R0-SYSTEM
1198   07B0             
1199   07B0             W_TIB:
1200   07B0 83 54 49 C2 	.BYTE	83h,"TI",'B'+80h
1201   07B4 A7 07       	.WORD	W_R0
1202   07B6             C_TIB:
1203   07B6 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1204   07B8 0A 00       	.WORD	TIB-SYSTEM
1205   07BA             
1206   07BA             W_WIDTH:
1207   07BA 8557494454C8	.BYTE	85h,"WIDT",'H'+80h
1208   07C0 B0 07       	.WORD	W_TIB
1209   07C2             C_WIDTH:
1210   07C2 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1211   07C4 0C 00       	.WORD	WIDTH-SYSTEM
1212   07C6             
1213   07C6             W_WARNING:				;Put WARNING addr on stack
1214   07C6 875741524E49	.BYTE	87h,"WARNIN",'G'+80h
1214   07CC 4EC7
1215   07CE BA 07       	.WORD	W_WIDTH
1216   07D0             C_WARNING:
1217   07D0 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1218   07D2 0E 00       	.WORD	WARNING-SYSTEM
1219   07D4             
1220   07D4             W_FENCE:
1221   07D4 8546454E43C5	.BYTE	85h,"FENC",'E'+80h
1222   07DA C6 07       	  	.WORD	W_WARNING
1223   07DC             C_FENCE:
1224   07DC 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1225   07DE 10 00       	.WORD	FENCE-SYSTEM
1226   07E0             
1227   07E0             W_DP:					;Dictionary pointer addr on stack
1228   07E0 82 44 D0    	.BYTE	82h,'D','P'+80h
1229   07E3 D4 07       	.WORD	W_FENCE
1230   07E5             C_DP:
1231   07E5 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1232   07E7 12 00       	.WORD	DP-SYSTEM
1233   07E9             
1234   07E9             W_VOC_LINK:
1235   07E9 88564F432D4C	.BYTE	88h,"VOC-LIN",'K'+80h
1235   07EF 494ECB
1236   07F2 E0 07       	.WORD	W_DP
1237   07F4             C_VOC_LINK:
1238   07F4 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1239   07F6 14 00       	.WORD	VOC_LINK-SYSTEM
1240   07F8             
1241   07F8             W_BLK:
1242   07F8 83 42 4C CB 	.BYTE	83h,"BL",'K'+80h
1243   07FC E9 07       	.WORD	W_VOC_LINK
1244   07FE             C_BLK:
1245   07FE 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1246   0800 16 00       	.WORD	BLK-SYSTEM
1247   0802             
1248   0802             W_TOIN:
1249   0802 83 3E 49 CE 	.BYTE	83h,">I",'N'+80h
1250   0806 F8 07       	.WORD	W_BLK
1251   0808             C_TOIN:
1252   0808 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1253   080A 18 00       	.WORD	TOIN-SYSTEM
1254   080C             
1255   080C             W_OUT:					;Put OUT buffer count addr on stack
1256   080C 83 4F 55 D4 	.BYTE	83h,"OU",'T'+80h
1257   0810 02 08       	.WORD	W_TOIN
1258   0812             C_OUT:
1259   0812 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1260   0814 1A 00       	.WORD	OUT-SYSTEM
1261   0816             
1262   0816             W_SCR:
1263   0816 83 53 43 D2 	.BYTE	83h,"SC",'R'+80h
1264   081A 0C 08       	.WORD	W_OUT
1265   081C             C_SCR:
1266   081C 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1267   081E 1C 00       	.WORD	SCR-SYSTEM
1268   0820             
1269   0820             W_OFFSET:				;Put disk block offset on stack
1270   0820 864F46465345	.BYTE	86h,"OFFSE",'T'+80h
1270   0826 D4
1271   0827 16 08       	.WORD	W_SCR
1272   0829             C_OFFSET:
1273   0829 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1274   082B 1E 00       	.WORD	OFFSET-SYSTEM
1275   082D             
1276   082D             W_CONTEXT:
1277   082D 87434F4E5445	.BYTE	87h,"CONTEX",'T'+80h
1277   0833 58D4
1278   0835 20 08       	.WORD	W_OFFSET
1279   0837             C_CONTEXT:
1280   0837 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1281   0839 20 00       	.WORD	CONTEXT-SYSTEM
1282   083B             
1283   083B             W_CURRENT:
1284   083B 874355525245	.BYTE	87h,"CURREN",'T'+80h
1284   0841 4ED4
1285   0843 2D 08       	.WORD	W_CONTEXT
1286   0845             C_CURRENT:
1287   0845 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1288   0847 22 00       	.WORD	CURRENT-SYSTEM
1289   0849             
1290   0849             W_STATE:				;Push STATE addr
1291   0849 8553544154C5	.BYTE	85h,"STAT",'E'+80h
1292   084F 3B 08       	.WORD	W_CURRENT
1293   0851             C_STATE:
1294   0851 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1295   0853 24 00       	.WORD	STATE-SYSTEM
1296   0855             
1297   0855             W_BASE:					;Put BASE addr on stack
1298   0855 84424153C5  	.BYTE	84h,"BAS",'E'+80h
1299   085A 49 08       	.WORD	W_STATE
1300   085C             C_BASE:
1301   085C 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1302   085E 26 00       	.WORD	BASE-SYSTEM
1303   0860             
1304   0860             W_DPL:
1305   0860 83 44 50 CC 	.BYTE	83h,"DP",'L'+80h
1306   0864 55 08       	.WORD	W_BASE
1307   0866             C_DPL:
1308   0866 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1309   0868 28 00       	.WORD	DPL-SYSTEM
1310   086A             
1311   086A             W_FLD:
1312   086A 83 46 4C C4 	.BYTE	83h,"FL",'D'+80h
1313   086E 60 08       	.WORD	W_DPL
1314   0870             C_FLD:
1315   0870 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1316   0872 2A 00       	.WORD	FLD-SYSTEM
1317   0874             
1318   0874             W_CSP:					;Push check stack pointer addr
1319   0874 83 43 53 D0 	.BYTE	83h,"CS",'P'+80h
1320   0878 6A 08       	.WORD	W_FLD
1321   087A             C_CSP:
1322   087A 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1323   087C 2C 00       	.WORD	CSP-SYSTEM
1324   087E             
1325   087E             W_RHASH:
1326   087E 82 52 A3    	.BYTE	82h,'R','#'+80h
1327   0881 74 08       	.WORD	W_CSP
1328   0883             C_RHASH:
1329   0883 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1330   0885 2E 00       	.WORD	RHASH-SYSTEM
1331   0887             
1332   0887             W_HLD:
1333   0887 83 48 4C C4 	.BYTE	83h,"HL",'D'+80h
1334   088B 7E 08       	.WORD	W_RHASH
1335   088D             C_HLD:
1336   088D 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1337   088F 30 00       	.WORD	HLD-SYSTEM
1338   0891             
1339   0891             W_UCL:
1340   0891 8455432FCC  	.BYTE	84h,"UC/",'L'+80h
1341   0896 87 08       	.WORD	W_HLD
1342   0898             C_UCL:
1343   0898 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1344   089A 5C 00       	.WORD	UCL-SYSTEM
1345   089C             
1346   089C             W_UFIRST:
1347   089C 865546495253	.BYTE	86h,"UFIRS",'T'+80h
1347   08A2 D4
1348   08A3 91 08       	.WORD	W_UCL
1349   08A5             C_UFIRST:
1350   08A5 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1351   08A7 5E 00       	.WORD	UFIRST-SYSTEM
1352   08A9             
1353   08A9             W_ULIMIT:
1354   08A9 86554C494D49	.BYTE	86h,"ULIMI",'T'+80h
1354   08AF D4
1355   08B0 9C 08       	.WORD	W_UFIRST
1356   08B2             C_ULIMIT:
1357   08B2 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1358   08B4 60 00       	.WORD	ULIMIT-SYSTEM
1359   08B6             
1360   08B6             W_UBBUF:
1361   08B6 8655422F4255	.BYTE	86h,"UB/BU",'F'+80h
1361   08BC C6
1362   08BD A9 08       	.WORD	W_ULIMIT
1363   08BF             C_UBBUF:
1364   08BF 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1365   08C1 62 00       	.WORD	UBBUF-SYSTEM
1366   08C3             
1367   08C3             W_UBSCR:
1368   08C3 8655422F5343	.BYTE	86h,"UB/SC",'R'+80h
1368   08C9 D2
1369   08CA B6 08       	.WORD	W_UBBUF
1370   08CC             C_UBSCR:
1371   08CC 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1372   08CE 64 00       	.WORD	UBSCR-SYSTEM
1373   08D0             
1374   08D0             W_UTERMINAL:
1375   08D0 8A553F544552	.BYTE	8Ah,"U?TERMINA",'L'+80h
1375   08D6 4D494E41CC
1376   08DB C3 08       	.WORD	W_UBSCR
1377   08DD             C_UTERMINAL:
1378   08DD 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1379   08DF 50 00       	.WORD	UTERMINAL-SYSTEM
1380   08E1             
1381   08E1             W_UKEY:					;Put UKEY addr on stack
1382   08E1 84554B45D9  	.BYTE	84h,"UKE",'Y'+80h
1383   08E6 D0 08       	.WORD	W_UTERMINAL
1384   08E8             C_UKEY:
1385   08E8 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1386   08EA 52 00       	.WORD	UKEY-SYSTEM
1387   08EC             
1388   08EC             W_UEMIT:				;Put UEMIT addr on stack
1389   08EC 8555454D49D4	.BYTE	85h,"UEMI",'T'+80h
1390   08F2 E1 08       	.WORD	W_UKEY
1391   08F4             C_UEMIT:
1392   08F4 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1393   08F6 54 00       	.WORD	UEMIT-SYSTEM
1394   08F8             
1395   08F8             W_UCR:					;Push UCR addr
1396   08F8 83 55 43 D2 	.BYTE	83h,"UC",'R'+80h
1397   08FC EC 08       	.WORD	W_UEMIT
1398   08FE             C_UCR:
1399   08FE 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1400   0900 56 00       	.WORD	UCR-SYSTEM
1401   0902             
1402   0902             W_URW:
1403   0902 8455522FD7  	.BYTE	84h,"UR/",'W'+80h
1404   0907 F8 08       	.WORD	W_UCR
1405   0909             C_URW:
1406   0909 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1407   090B 58 00       	.WORD	URW-SYSTEM
1408   090D             
1409   090D             W_UABORT:				;Put UABORT on stack
1410   090D 865541424F52	.BYTE	86h,"UABOR",'T'+80h
1410   0913 D4
1411   0914 02 09       	.WORD	W_URW
1412   0916             C_UABORT:
1413   0916 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1414   0918 5A 00       	.WORD	UABORT-SYSTEM
1415   091A             
1416   091A             W_RAF:
1417   091A 83 52 41 C6 	.BYTE	83h,"RA",'F'+80h
1418   091E 0D 09       	.WORD	W_UABORT
1419   0920             C_RAF:
1420   0920 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1421   0922 68 00       	.WORD	RAF-SYSTEM
1422   0924             
1423   0924             W_RBC:
1424   0924 83 52 42 C3 	.BYTE	83h,"RB",'C'+80h
1425   0928 1A 09       	.WORD	W_RAF
1426   092A             C_RBC:
1427   092A 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1428   092C 6A 00       	.WORD	RBC-SYSTEM
1429   092E             
1430   092E             W_RDE:
1431   092E 83 52 44 C5 	.BYTE	83h,"RD",'E'+80h
1432   0932 24 09       	.WORD	W_RBC
1433   0934             C_RDE
1434   0934 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1435   0936 6C 00       	.WORD	RDE-SYSTEM
1436   0938             
1437   0938             W_RHL:
1438   0938 83 52 48 CC 	.BYTE	83h,"RH",'L'+80h
1439   093C 2E 09       	.WORD	W_RDE
1440   093E             C_RHL:
1441   093E 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1442   0940 6E 00       	.WORD	RHL-SYSTEM
1443   0942             
1444   0942             W_RIX:
1445   0942 83 52 49 D8 	.BYTE	83h,"RI",'X'+80h
1446   0946 38 09       	.WORD	W_RHL
1447   0948             C_RIX:
1448   0948 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1449   094A 70 00       	.WORD	RIX-SYSTEM
1450   094C             
1451   094C             W_RIY:
1452   094C 83 52 49 D9 	.BYTE	83h,"RI",'Y'+80h
1453   0950 42 09       	.WORD	W_RIX
1454   0952             C_RIY:
1455   0952 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1456   0954 72 00       	.WORD	RIY-SYSTEM
1457   0956             
1458   0956             W_RAF2:
1459   0956 84524146AC  	.BYTE	84h,"RAF",2Ch+80h
1460   095B 4C 09       	.WORD	W_RIY
1461   095D             C_RAF2:
1462   095D 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1463   095F 74 00       	.WORD	RAF2-SYSTEM
1464   0961             
1465   0961             W_RBC2:
1466   0961 84524243AC  	.BYTE	84h,"RBC",2Ch+80h
1467   0966 56 09       	.WORD	W_RAF2
1468   0968             C_RBC2:
1469   0968 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1470   096A 76 00       	.WORD	RBC2-SYSTEM
1471   096C             
1472   096C             W_RDE2:
1473   096C 84524445AC  	.BYTE	84h,"RDE",2Ch+80h
1474   0971 61 09       	.WORD	W_RBC2
1475   0973             C_RDE2:
1476   0973 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1477   0975 78 00       	.WORD	RDE2-SYSTEM
1478   0977             
1479   0977             W_RHL2:
1480   0977 8452484CAC  	.BYTE	84h,"RHL",2Ch+80h
1481   097C 6C 09       	.WORD	W_RDE2
1482   097E             C_RHL2:
1483   097E 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1484   0980 7A 00       	.WORD	RHL2-SYSTEM
1485   0982             
1486   0982             W_RA:
1487   0982 82 52 C1    	.BYTE	82h,'R','A'+80h
1488   0985 77 09       	.WORD	W_RHL2
1489   0987             C_RA:
1490   0987 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1491   0989 69 00       	.WORD	RAF+1-SYSTEM
1492   098B             
1493   098B             W_RF:
1494   098B 82 52 C6    	.BYTE	82h,'R','F'+80h
1495   098E 82 09       	.WORD	W_RA
1496   0990             C_RF:
1497   0990 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1498   0992 68 00       	.WORD	RAF-SYSTEM
1499   0994             
1500   0994             W_RB:
1501   0994 82 52 C2    	.BYTE	82h,'R','B'+80h
1502   0997 8B 09       	.WORD	W_RF
1503   0999             C_RB:
1504   0999 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1505   099B 6B 00       	.WORD	RBC+1-SYSTEM
1506   099D             
1507   099D             W_RC:
1508   099D 82 52 C3    	.BYTE	82h,'R','C'+80h
1509   09A0 94 09       	.WORD	W_RB
1510   09A2             C_RC:
1511   09A2 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1512   09A4 6A 00       	.WORD	RBC-SYSTEM
1513   09A6             
1514   09A6             W_RD:
1515   09A6 82 52 C4    	.BYTE	82h,'R','D'+80h
1516   09A9 9D 09       	.WORD	W_RC
1517   09AB             C_RD:
1518   09AB 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1519   09AD 6D 00       	.WORD	RDE+1-SYSTEM
1520   09AF             
1521   09AF             W_RE:
1522   09AF 82 52 C5    	.BYTE	82h,'R','E'+80h
1523   09B2 A6 09       	.WORD	W_RD
1524   09B4             C_RE:
1525   09B4 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1526   09B6 6C 00       	.WORD	RDE-SYSTEM
1527   09B8             
1528   09B8             W_RH:
1529   09B8 82 52 C8    	.BYTE	82h,'R','H'+80h
1530   09BB AF 09       	.WORD	W_RE
1531   09BD             C_RH:
1532   09BD 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1533   09BF 6F 00       	.WORD	RHL+1-SYSTEM
1534   09C1             
1535   09C1             W_RL:
1536   09C1 82 52 CC    	.BYTE	82h,'R','L'+80h
1537   09C4 B8 09       	.WORD	W_RH
1538   09C6             C_RL:
1539   09C6 1B 07       	.WORD	X_USER			;Put next word on stack then do next
1540   09C8 6E 00       	.WORD	RHL-SYSTEM
1541   09CA             
1542   09CA             W_CALL:
1543   09CA 8443414CCC  	.BYTE	84h,"CAL",'L'+80h
1544   09CF C1 09       	.WORD	W_RL
1545   09D1             C_CALL:
1546   09D1 D3 09       	.WORD	2+$			;Vector to code
1547   09D3 E1          	POP	HL			;Address of routine CALLed
1548   09D4 D5          	PUSH	DE			;Save register
1549   09D5 C5          	PUSH	BC			;Save register
1550   09D6 3E C3       	LD	A,0C3h			;Hex code for JMP
1551   09D8 32 7D FE    	LD	(JPCODE),A		;Save it
1552   09DB 22 7E FE    	LD	(JPVECT),HL		;Save jump vector
1553   09DE 2A 68 FE    	LD	HL,(RAF)		;Get register AF
1554   09E1 E5          	PUSH	HL			;Onto stack
1555   09E2 F1          	POP	AF			;POP into AF
1556   09E3 ED 4B 6A FE 	LD	BC,(RBC)		;Get register BC
1557   09E7 ED 5B 6C FE 	LD	DE,(RDE)		;Get register DE
1558   09EB 2A 6E FE    	LD	HL,(RHL)		;Get register HL
1559   09EE DD 2A 70 FE 	LD	IX,(RIX)		;Get register IX
1560   09F2 FD 2A 72 FE 	LD	IY,(RIY)		;Get register IY
1561   09F6 CD 7D FE    	CALL	JPCODE			;Call jump to code
1562   09F9 FD 22 72 FE 	LD	(RIY),IY		;Save register IY
1563   09FD DD 22 70 FE 	LD	(RIX),IX		;Save register IX
1564   0A01 ED 43 6A FE 	LD	(RBC),BC		;Save register BC
1565   0A05 ED 53 6C FE 	LD	(RDE),DE		;Save register DE
1566   0A09 22 6E FE    	LD	(RHL),HL		;Save register HL
1567   0A0C F5          	PUSH	AF			;Save register AF
1568   0A0D E1          	POP	HL			;Into HL
1569   0A0E 22 68 FE    	LD	(RAF),HL		;Into memory
1570   0A11 C1          	POP	BC			;Restore BC
1571   0A12 D1          	POP	DE			;Restore DE
1572   0A13 C3 9E 01    	JP	NEXT			;
1573   0A16             
1574   0A16             W_1PLUS:				;1 plus
1575   0A16 82 31 AB    	.BYTE	82h,'1','+'+80h
1576   0A19 CA 09       	.WORD	W_CALL
1577   0A1B             C_1PLUS:
1578   0A1B 1D 0A       	.WORD	2+$			;Vector to code
1579   0A1D E1          	POP	HL			; get n
1580   0A1E 23          	INC	HL			; add 1
1581   0A1F C3 9D 01    	JP	NEXTS1			; save result & NEXT
1582   0A22             
1583   0A22             W_2PLUS:				;2 plus
1584   0A22 82 32 AB    	.BYTE	82h,'2','+'+80h
1585   0A25 16 0A       	.WORD	W_1PLUS
1586   0A27             C_2PLUS:
1587   0A27 29 0A       	.WORD	2+$			;Vector to code
1588   0A29 E1          	POP	HL			; get n
1589   0A2A 23          	INC	HL			; add 1
1590   0A2B 23          	INC	HL			; add 2
1591   0A2C C3 9D 01    	JP	NEXTS1			; save result & NEXT
1592   0A2F             
1593   0A2F             W_1MINUS:				;1 minus
1594   0A2F 82 31 AD    	.BYTE	82h,'1','-'+80h
1595   0A32 22 0A       	.WORD	W_2PLUS
1596   0A34             C_1MINUS:
1597   0A34 36 0A       	.WORD	2+$			;Vector to code
1598   0A36 E1          	POP	HL			; get n
1599   0A37 2B          	DEC	HL			; add 1
1600   0A38 C3 9D 01    	JP	NEXTS1			; save result & NEXT
1601   0A3B             
1602   0A3B             W_2MINUS:				;2 minus
1603   0A3B 82 32 AD    	.BYTE	82h,'2','-'+80h
1604   0A3E 2F 0A       	.WORD	W_1MINUS
1605   0A40             C_2MINUS:
1606   0A40 42 0A       	.WORD	2+$			;Vector to code
1607   0A42 E1          	POP	HL			; get n
1608   0A43 2B          	DEC	HL			; subtract 1
1609   0A44 2B          	DEC	HL			; subtract 2
1610   0A45 C3 9D 01    	JP	NEXTS1			; save result & NEXT
1611   0A48             
1612   0A48             W_HERE:					;Dictionary pointer onto stack
1613   0A48 84484552C5  	.BYTE	84h,"HER",'E'+80h
1614   0A4D 3B 0A       	.WORD	W_2MINUS
1615   0A4F             C_HERE:
1616   0A4F B4 06       	.WORD	E_COLON			;Interpret following word sequence
1617   0A51 E5 07       	.WORD	C_DP			;Dictionary pointer addr on stack
1618   0A53 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
1619   0A55 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1620   0A57             
1621   0A57             W_ALLOT:
1622   0A57 85414C4C4FD4	.BYTE	85h,"ALLO",'T'+80h
1623   0A5D 48 0A       	.WORD	W_HERE
1624   0A5F             C_ALLOT:
1625   0A5F B4 06       	.WORD	E_COLON			;Interpret following word sequence
1626   0A61 E5 07       	.WORD	C_DP			;Dictionary pointer addr on stack
1627   0A63 15 06       	.WORD	C_PLUSSTORE		;Add n1 to addr
1628   0A65 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1629   0A67             
1630   0A67             W_COMMA:				;Reserve 2 bytes and save n
1631   0A67 81 AC       	.BYTE	81h,','+80h
1632   0A69 57 0A       	.WORD	W_ALLOT
1633   0A6B             C_COMMA:
1634   0A6B B4 06       	.WORD	E_COLON			;Interpret following word sequence
1635   0A6D 4F 0A       	.WORD	C_HERE			;Next free dictionary pointer onto stack
1636   0A6F 71 06       	.WORD	C_STORE			;Store word at addr
1637   0A71 3B 07       	.WORD	C_2			;
1638   0A73 5F 0A       	.WORD	C_ALLOT			;Move pointer
1639   0A75 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1640   0A77             
1641   0A77             W_CCOMMA:
1642   0A77 82 43 AC    	.BYTE	82h,'C',','+80h
1643   0A7A 67 0A       	.WORD	W_COMMA
1644   0A7C             C_CCOMMA:
1645   0A7C B4 06       	.WORD	E_COLON			;Interpret following word sequence
1646   0A7E 4F 0A       	.WORD	C_HERE			;Dictionary pointer onto stack
1647   0A80 80 06       	.WORD	C_CSTORE		;Store byte at addr
1648   0A82 33 07       	.WORD	C_1			;Put 1 on stack
1649   0A84 5F 0A       	.WORD	C_ALLOT
1650   0A86 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1651   0A88             
1652   0A88             W_MINUS:
1653   0A88 81 AD       	.BYTE	81h,'-'+80h
1654   0A8A 77 0A       	.WORD	W_CCOMMA
1655   0A8C             C_MINUS:
1656   0A8C 8E 0A       	.WORD	2+$			;Vector to code
1657   0A8E D1          	POP	DE			; get n1
1658   0A8F E1          	POP	HL			; get n2
1659   0A90 CD 96 0A    	CALL	MINUS16			; call subtract routine
1660   0A93 C3 9D 01    	JP	NEXTS1			; save & NEXT
1661   0A96             
1662   0A96             MINUS16:
1663   0A96 7D          	LD	A,L			; gel low byte
1664   0A97 93          	SUB	E			; subtract low bytes
1665   0A98 6F          	LD	L,A			; save low byte result
1666   0A99 7C          	LD	A,H			; get high byte
1667   0A9A 9A          	SBC	A,D			; subtract high bytes
1668   0A9B 67          	LD	H,A			; save high byte result
1669   0A9C C9          	RET				;
1670   0A9D             
1671   0A9D             W_.EQUALS:
1672   0A9D 81 BD       	.BYTE	81h,'='+80h
1673   0A9F 88 0A       	.WORD	W_MINUS
1674   0AA1             C_EQUALS:
1675   0AA1 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1676   0AA3 8C 0A       	.WORD	C_MINUS
1677   0AA5 1F 05       	.WORD	C_0EQUALS		;=0
1678   0AA7 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1679   0AA9             
1680   0AA9             W_LESSTHAN:
1681   0AA9 81 BC       	.BYTE	81h,'<'+80h
1682   0AAB 9D 0A       	.WORD	W_.EQUALS
1683   0AAD             C_LESSTHAN:
1684   0AAD AF 0A       	.WORD	2+$			;Vector to code
1685   0AAF D1          	POP	DE
1686   0AB0 E1          	POP	HL
1687   0AB1 7A          	LD	A,D
1688   0AB2 AC          	XOR	H
1689   0AB3 FA B9 0A    	JP	M,J298C
1690   0AB6 CD 96 0A    	CALL	MINUS16
1691   0AB9             J298C:
1692   0AB9 24          	INC	H
1693   0ABA 25          	DEC	H
1694   0ABB FA C4 0A    	JP	M,J2997
1695   0ABE 21 00 00    	LD	HL,0000
1696   0AC1 C3 9D 01    	JP	NEXTS1			;Save & NEXT
1697   0AC4             J2997:
1698   0AC4 21 01 00    	LD	HL,0001
1699   0AC7 C3 9D 01    	JP	NEXTS1			;Save & NEXT
1700   0ACA             
1701   0ACA             W_ULESS:				;IF stack-1 < stack_top leave true flag
1702   0ACA 82 55 BC    	.BYTE	82h,'U','<'+80h
1703   0ACD A9 0A       	.WORD	W_LESSTHAN
1704   0ACF             C_ULESS:
1705   0ACF B4 06       	.WORD	E_COLON			;Interpret following word sequence
1706   0AD1 F5 05       	.WORD	C_2DUP			;Dup top 2 values on stack
1707   0AD3 63 04       	.WORD	C_XOR			;Exclusive OR them
1708   0AD5 3A 05       	.WORD	C_0LESS			;Less than 0
1709   0AD7 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
1710   0AD9 0C 00       	.WORD	B0000-$			;000Ch
1711   0ADB BE 05       	.WORD	C_DROP			;Drop top value from stack
1712   0ADD 3A 05       	.WORD	C_0LESS			;Less than 0
1713   0ADF 1F 05       	.WORD	C_0EQUALS		;=0
1714   0AE1 E8 01       	.WORD	C_BRANCH		;Add following offset to BC
1715   0AE3 06 00       	.WORD	B0001-$			;0006h
1716   0AE5             B0000:
1717   0AE5 8C 0A       	.WORD	C_MINUS
1718   0AE7 3A 05       	.WORD	C_0LESS			;Less than 0
1719   0AE9             B0001:
1720   0AE9 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1721   0AEB             
1722   0AEB             W_GREATER:
1723   0AEB 81 BE       	.BYTE	81h,'>'+80h
1724   0AED CA 0A       	.WORD	W_ULESS
1725   0AEF             C_GREATER:
1726   0AEF B4 06       	.WORD	E_COLON			;Interpret following word sequence
1727   0AF1 DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
1728   0AF3 AD 0A       	.WORD	C_LESSTHAN
1729   0AF5 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1730   0AF7             
1731   0AF7             W_ROT:					;3rd valu down to top of stack
1732   0AF7 83 52 4F D4 	.BYTE	83h,"RO",'T'+80h
1733   0AFB EB 0A       	.WORD	W_GREATER
1734   0AFD             C_ROT:
1735   0AFD FF 0A       	.WORD	2+$			;Vector to code
1736   0AFF D1          	POP	DE			;Top value
1737   0B00 E1          	POP	HL			;Next one down
1738   0B01 E3          	EX	(SP),HL			;Exchange with third
1739   0B02 C3 9C 01    	JP	NEXTS2			;Save both & NEXT
1740   0B05             
1741   0B05             W_PICK:
1742   0B05 84504943CB  	.BYTE	84h,"PIC",'K'+80h
1743   0B0A F7 0A       	.WORD	W_ROT
1744   0B0C             C_PICK:
1745   0B0C B4 06       	.WORD	E_COLON			;Interpret following word sequence
1746   0B0E E7 05       	.WORD	C_DUP			;Duplicate top value on stack
1747   0B10 4B 05       	.WORD	C_PLUS			;n1 + n2
1748   0B12 76 04       	.WORD	C_SPFETCH		;Stack pointer onto stack
1749   0B14 4B 05       	.WORD	C_PLUS			;n1 + n2
1750   0B16 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
1751   0B18 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1752   0B1A             
1753   0B1A             W_SPACE:
1754   0B1A 8553504143C5	.BYTE	85h,"SPAC",'E'+80h
1755   0B20 05 0B       	.WORD	W_PICK
1756   0B22             C_SPACE:
1757   0B22 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1758   0B24 4C 07       	.WORD	C_BL			;Leaves ASCII for space on stack
1759   0B26 4D 03       	.WORD	C_EMIT			;Output CHR from stack
1760   0B28 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1761   0B2A             
1762   0B2A             W_QUERYDUP:
1763   0B2A 843F4455D0  	.BYTE	84h,"?DU",'P'+80h
1764   0B2F 1A 0B       	.WORD	W_SPACE
1765   0B31             C_QUERYDUP:
1766   0B31 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1767   0B33 E7 05       	.WORD	C_DUP			;Duplicate top value on stack
1768   0B35 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
1769   0B37 04 00       	.WORD	B0002-$			;0004h
1770   0B39 E7 05       	.WORD	C_DUP			;Duplicate top value on stack
1771   0B3B             B0002:
1772   0B3B C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1773   0B3D             
1774   0B3D             W_TRAVERSE:
1775   0B3D 885452415645	.BYTE	88h,"TRAVERS",'E'+80h
1775   0B43 5253C5
1776   0B46 2A 0B       	.WORD	W_QUERYDUP
1777   0B48             C_TRAVERSE:
1778   0B48 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1779   0B4A DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
1780   0B4C             B0054:
1781   0B4C AF 05       	.WORD	C_OVER			;Copy 2nd down to top of stack
1782   0B4E 4B 05       	.WORD	C_PLUS			;n1 + n2
1783   0B50 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1784   0B52 7F 00       	.WORD	007Fh
1785   0B54 AF 05       	.WORD	C_OVER			;Copy 2nd down to top of stack
1786   0B56 49 06       	.WORD	C_CFETCH		;Get byte from addr on stack
1787   0B58 AD 0A       	.WORD	C_LESSTHAN
1788   0B5A 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
1789   0B5C F0 FF       	.WORD	B0054-$			;FFF0h
1790   0B5E DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
1791   0B60 BE 05       	.WORD	C_DROP			;Drop top value from stack
1792   0B62 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1793   0B64             
1794   0B64             W_LATEST:
1795   0B64 864C41544553	.BYTE	86h,"LATES",'T'+80h
1795   0B6A D4
1796   0B6B 3D 0B       	.WORD	W_TRAVERSE
1797   0B6D             C_LATEST:
1798   0B6D B4 06       	.WORD	E_COLON			;Interpret following word sequence
1799   0B6F 45 08       	.WORD	C_CURRENT
1800   0B71 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
1801   0B73 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
1802   0B75 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1803   0B77             
1804   0B77             W_LFA:
1805   0B77 83 4C 46 C1 	.BYTE	83h,"LF",'A'+80h
1806   0B7B 64 0B       	.WORD	W_LATEST
1807   0B7D             C_LFA:
1808   0B7D B4 06       	.WORD	E_COLON			;Interpret following word sequence
1809   0B7F C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1810   0B81 04 00       	.WORD	0004h
1811   0B83 8C 0A       	.WORD	C_MINUS
1812   0B85 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1813   0B87             
1814   0B87             W_CFA:
1815   0B87 83 43 46 C1 	.BYTE	83h,"CF",'A'+80h
1816   0B8B 77 0B       	.WORD	W_LFA
1817   0B8D             C_CFA:
1818   0B8D 8F 0B       	.WORD	2+$			;Vector to code
1819   0B8F E1          	POP	HL			    ; get n
1820   0B90 2B          	DEC	HL			    ; subtract 1
1821   0B91 2B          	DEC	HL			    ; subtract 2
1822   0B92 C3 9D 01    	JP	NEXTS1			; save result & NEXT
1823   0B95             W_NFA:
1824   0B95 83 4E 46 C1 	.BYTE	83h,"NF",'A'+80h
1825   0B99 87 0B       	.WORD	W_CFA
1826   0B9B             C_NFA:
1827   0B9B B4 06       	.WORD	E_COLON			;Interpret following word sequence
1828   0B9D C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1829   0B9F 05 00       	.WORD	0005h
1830   0BA1 8C 0A       	.WORD	C_MINUS
1831   0BA3 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1832   0BA5 FF FF       	.WORD	0FFFFh
1833   0BA7 48 0B       	.WORD	C_TRAVERSE
1834   0BA9 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1835   0BAB             
1836   0BAB             W_PFA:					    ;Convert NFA to PFA
1837   0BAB 83 50 46 C1 	.BYTE	83h,"PF",'A'+80h
1838   0BAF 95 0B       	.WORD	W_NFA
1839   0BB1             C_PFA:
1840   0BB1 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1841   0BB3 33 07       	.WORD	C_1			    ;Traverse up memory
1842   0BB5 48 0B       	.WORD	C_TRAVERSE		;End of name on stack
1843   0BB7 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1844   0BB9 05 00       	.WORD	0005h			;Offset to start of word code
1845   0BBB 4B 05       	.WORD	C_PLUS			;n1 + n2
1846   0BBD C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1847   0BBF             
1848   0BBF             W_CSPSTORE:
1849   0BBF 84214353D0  	.BYTE	84h,"!CS",'P'+80h
1850   0BC4 AB 0B       	.WORD	W_PFA
1851   0BC6             C_CSPSTORE:
1852   0BC6 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1853   0BC8 76 04       	.WORD	C_SPFETCH		;Stack pointer onto stack
1854   0BCA 7A 08       	.WORD	C_CSP			;Push check stack pointer addr
1855   0BCC 71 06       	.WORD	C_STORE			;Store word at addr
1856   0BCE C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1857   0BD0             
1858   0BD0             W_QERROR:
1859   0BD0 863F4552524F	.BYTE	86h,"?ERRO",'R'+80h
1859   0BD6 D2
1860   0BD7 BF 0B       	.WORD	W_CSPSTORE
1861   0BD9             C_QERROR:
1862   0BD9 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1863   0BDB DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
1864   0BDD 00 02       	.WORD	C_0BRANCH		;Branch if no error
1865   0BDF 08 00       	.WORD	B0003-$			;0008h
1866   0BE1 6A 10       	.WORD	C_ERROR
1867   0BE3 E8 01       	.WORD	C_BRANCH		;Add following offset to BC
1868   0BE5 04 00       	.WORD	B0004-$			;0004h
1869   0BE7             B0003:
1870   0BE7 BE 05       	.WORD	C_DROP			;Drop error no.
1871   0BE9             B0004:
1872   0BE9 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1873   0BEB             
1874   0BEB             W_QCOMP:				;Error if not in compile mode
1875   0BEB 853F434F4DD0	.BYTE	85h,"?COM",'P'+80h
1876   0BF1 D0 0B       	.WORD	W_QERROR
1877   0BF3             C_QCOMP:
1878   0BF3 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1879   0BF5 51 08       	.WORD	C_STATE			;Push STATE addr
1880   0BF7 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
1881   0BF9 1F 05       	.WORD	C_0EQUALS		;=0
1882   0BFB C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1883   0BFD 11 00       	.WORD	0011h			;Error message number
1884   0BFF D9 0B       	.WORD	C_QERROR		;Error if state <> 0
1885   0C01 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1886   0C03             
1887   0C03             W_QEXEC:				;Error not if not in execute mode
1888   0C03 853F455845C3	.BYTE	85h,"?EXE",'C'+80h
1889   0C09 EB 0B       	.WORD	W_QCOMP
1890   0C0B             C_QEXEC:
1891   0C0B B4 06       	.WORD	E_COLON			;Interpret following word sequence
1892   0C0D 51 08       	.WORD	C_STATE			;Push STATE addr
1893   0C0F 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
1894   0C11 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1895   0C13 12 00       	.WORD	0012h			;Error not if not in execute mode
1896   0C15 D9 0B       	.WORD	C_QERROR		;
1897   0C17 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1898   0C19             
1899   0C19             W_QPAIRS:
1900   0C19 863F50414952	.BYTE	86h,"?PAIR",'S'+80h
1900   0C1F D3
1901   0C20 03 0C       	.WORD	W_QEXEC
1902   0C22             C_QPAIRS:
1903   0C22 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1904   0C24 8C 0A       	.WORD	C_MINUS
1905   0C26 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1906   0C28 13 00       	.WORD	0013h
1907   0C2A D9 0B       	.WORD	C_QERROR
1908   0C2C C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1909   0C2E             
1910   0C2E             W_WHATSTACK:				;Check stack pointer, error if not ok
1911   0C2E 843F4353D0  	.BYTE	84h,"?CS",'P'+80h
1912   0C33 19 0C       	.WORD	W_QPAIRS
1913   0C35             C_WHATSTACK:
1914   0C35 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1915   0C37 76 04       	.WORD	C_SPFETCH		;Stack pointer onto stack
1916   0C39 7A 08       	.WORD	C_CSP			;Push check stack pointer addr
1917   0C3B 3A 06       	.WORD	C_FETCH			;Get check stack pointer
1918   0C3D 8C 0A       	.WORD	C_MINUS			;If ok then result is 0
1919   0C3F C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1920   0C41 14 00       	.WORD	0014h			;Error no if not ok
1921   0C43 D9 0B       	.WORD	C_QERROR		;Error if stack top -1 <> 0
1922   0C45 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1923   0C47             
1924   0C47             W_QLOADING:
1925   0C47 883F4C4F4144	.BYTE	88h,"?LOADIN",'G'+80h
1925   0C4D 494EC7
1926   0C50 2E 0C       	.WORD	W_WHATSTACK
1927   0C52             C_QLOADING:
1928   0C52 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1929   0C54 FE 07       	.WORD	C_BLK
1930   0C56 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
1931   0C58 1F 05       	.WORD	C_0EQUALS		;=0
1932   0C5A C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1933   0C5C 16 00       	.WORD	0016h
1934   0C5E D9 0B       	.WORD	C_QERROR
1935   0C60 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1936   0C62             
1937   0C62             W_COMPILE:
1938   0C62 87434F4D5049	.BYTE	87h,"COMPIL",'E'+80h
1938   0C68 4CC5
1939   0C6A 47 0C       	.WORD	W_QLOADING
1940   0C6C             C_COMPILE:
1941   0C6C B4 06       	.WORD	E_COLON			;Interpret following word sequence
1942   0C6E F3 0B       	.WORD	C_QCOMP			;Error if not in compile mode
1943   0C70 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
1944   0C72 E7 05       	.WORD	C_DUP			;Bump return address and put back
1945   0C74 27 0A       	.WORD	C_2PLUS			;
1946   0C76 ED 04       	.WORD	C_MOVER			;
1947   0C78 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
1948   0C7A 6B 0A       	.WORD	C_COMMA			;Reserve 2 bytes and save n
1949   0C7C C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1950   0C7E             
1951   0C7E             W_LEFTBRKT:				;Set STATE to execute
1952   0C7E 81 DB       	.BYTE	81h,'['+80h
1953   0C80 62 0C       	.WORD	W_COMPILE
1954   0C82             C_LEFTBRKT:
1955   0C82 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1956   0C84 2B 07       	.WORD	C_ZERO			;Put zero on stack
1957   0C86 51 08       	.WORD	C_STATE			;Push STATE addr
1958   0C88 71 06       	.WORD	C_STORE			;Store word at addr
1959   0C8A C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1960   0C8C             
1961   0C8C             W_RIGHTBRKT:				;Set STATE to compile
1962   0C8C 81 DD       	.BYTE	81h,']'+80h
1963   0C8E 7E 0C       	.WORD	W_LEFTBRKT
1964   0C90             C_RIGHTBRKT:
1965   0C90 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1966   0C92 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1967   0C94 C0 00       	.WORD	00C0h
1968   0C96 51 08       	.WORD	C_STATE			;Push STATE addr
1969   0C98 71 06       	.WORD	C_STORE			;Set STATE to execute
1970   0C9A C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1971   0C9C             
1972   0C9C             W_SMUDGE:
1973   0C9C 86534D554447	.BYTE	86h,"SMUDG",'E'+80h
1973   0CA2 C5
1974   0CA3 8C 0C       	.WORD	W_RIGHTBRKT
1975   0CA5             C_SMUDGE:
1976   0CA5 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1977   0CA7 6D 0B       	.WORD	C_LATEST		;Push top words NFA
1978   0CA9 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1979   0CAB 20 00       	.WORD	0020h
1980   0CAD 2C 06       	.WORD	C_TOGGLE		;XOR (addr) with byte
1981   0CAF C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1982   0CB1             
1983   0CB1             W_HEX:
1984   0CB1 83 48 45 D8 	.BYTE	83h,"HE",'X'+80h
1985   0CB5 9C 0C       	.WORD	W_SMUDGE
1986   0CB7             C_HEX:
1987   0CB7 B4 06       	.WORD	E_COLON			;Interpret following word sequence
1988   0CB9 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1989   0CBB 10 00       	.WORD	0010h
1990   0CBD 5C 08       	.WORD	C_BASE			;Put BASE addr on stack
1991   0CBF 71 06       	.WORD	C_STORE			;Store word at addr
1992   0CC1 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
1993   0CC3             
1994   0CC3             W_DECIMAL:				;Sets decimal mode
1995   0CC3 87444543494D	.BYTE	87h,"DECIMA",'L'+80h
1995   0CC9 41CC
1996   0CCB B1 0C       	.WORD	W_HEX
1997   0CCD             C_DECIMAL:
1998   0CCD B4 06       	.WORD	E_COLON			;Interpret following word sequence
1999   0CCF C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2000   0CD1 0A 00       	.WORD	000Ah			;Sets decimal value
2001   0CD3 5C 08       	.WORD	C_BASE			;Put BASE addr on stack
2002   0CD5 71 06       	.WORD	C_STORE			;Store word at addr
2003   0CD7 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2004   0CD9             
2005   0CD9             W_CCODE:				;Stop compillation & terminate word
2006   0CD9 873C3B434F44	.BYTE	87h,"<;CODE",'>'+80h
2006   0CDF 45BE
2007   0CE1 C3 0C       	.WORD	W_DECIMAL
2008   0CE3             C_CCODE:
2009   0CE3 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2010   0CE5 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
2011   0CE7 6D 0B       	.WORD	C_LATEST		;Push top words NFA
2012   0CE9 B1 0B       	.WORD	C_PFA			;Convert NFA to PFA
2013   0CEB 8D 0B       	.WORD	C_CFA			;Convert PFA to CFA
2014   0CED 71 06       	.WORD	C_STORE			;Store word at addr
2015   0CEF C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2016   0CF1             
2017   0CF1             W_SCCODE:
2018   0CF1 C53B434F44C5	.BYTE	0C5h,";COD",'E'+80h
2019   0CF7 D9 0C       	.WORD	W_CCODE
2020   0CF9             C_SCCODE:
2021   0CF9 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2022   0CFB 35 0C       	.WORD	C_WHATSTACK		;Check stack pointer, error if not ok
2023   0CFD 6C 0C       	.WORD	C_COMPILE		;Compile next word into dictionary
2024   0CFF E3 0C       	.WORD	C_CCODE
2025   0D01 82 0C       	.WORD	C_LEFTBRKT		;Set STATE to execute
2026   0D03 57 1B       	.WORD	C_TASK
2027   0D05 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2028   0D07             
2029   0D07             W_CREATE:
2030   0D07 864352454154	.BYTE	86h,"CREAT",'E'+80h
2030   0D0D C5
2031   0D0E F1 0C       	.WORD	W_SCCODE
2032   0D10             C_CREATE:
2033   0D10 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2034   0D12 2B 07       	.WORD	C_ZERO			;Put zero on stack
2035   0D14 E3 06       	.WORD	C_CONSTANT
2036   0D16 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2037   0D18             
2038   0D18             W_DOES:
2039   0D18 85444F4553BE	.BYTE	85h,"DOES",'>'+80h
2040   0D1E 07 0D       	.WORD	W_CREATE
2041   0D20             C_DOES:
2042   0D20 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2043   0D22 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
2044   0D24 6D 0B       	.WORD	C_LATEST		;Push top words NFA
2045   0D26 B1 0B       	.WORD	C_PFA			;Convert NFA to PFA
2046   0D28 71 06       	.WORD	C_STORE			;Store word at addr
2047   0D2A E3 0C       	.WORD	C_CCODE			;Execute following machine code
2048   0D2C             
2049   0D2C             X_DOES:
2050   0D2C 2A 46 FE    	LD	HL,(RPP)		;Get return stack pointer
2051   0D2F 2B          	DEC	HL			;Push next pointer
2052   0D30 70          	LD	(HL),B			;
2053   0D31 2B          	DEC	HL			;
2054   0D32 71          	LD	(HL),C			;
2055   0D33 22 46 FE    	LD	(RPP),HL
2056   0D36 13          	INC	DE
2057   0D37 EB          	EX	DE,HL
2058   0D38 4E          	LD	C,(HL)
2059   0D39 23          	INC	HL
2060   0D3A 46          	LD	B,(HL)
2061   0D3B 23          	INC	HL
2062   0D3C C3 9D 01    	JP	NEXTS1			;Save & NEXT
2063   0D3F             
2064   0D3F             W_COUNT:				;Convert string at addr to addr + length
2065   0D3F 85434F554ED4	.BYTE	85h,"COUN",'T'+80h
2066   0D45 18 0D       	.WORD	W_DOES
2067   0D47             C_COUNT:
2068   0D47 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2069   0D49 E7 05       	.WORD	C_DUP			;Duplicate address
2070   0D4B 1B 0A       	.WORD	C_1PLUS			;Add 1 (points to string start)
2071   0D4D DA 05       	.WORD	C_SWAP			;Get address back
2072   0D4F 49 06       	.WORD	C_CFETCH		;Get byte from addr on stack
2073   0D51 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2074   0D53             
2075   0D53             W_TYPE:					    ;Output n bytes from addr
2076   0D53 84545950C5  	.BYTE	84h,"TYP",'E'+80h
2077   0D58 3F 0D       	.WORD	W_COUNT
2078   0D5A             C_TYPE:
2079   0D5A B4 06       	.WORD	E_COLON			;Interpret following word sequence
2080   0D5C 31 0B       	.WORD	C_QUERYDUP		;Copy length if length <> 0
2081   0D5E 00 02       	.WORD	C_0BRANCH		;Branch if length = 0
2082   0D60 18 00       	.WORD	B0005-$			;0018h
2083   0D62 AF 05       	.WORD	C_OVER			;Copy address to stack top
2084   0D64 4B 05       	.WORD	C_PLUS			;Add to length
2085   0D66 DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
2086   0D68 5A 02       	.WORD	C_LDO			;Put start & end loop values on RPP
2087   0D6A             B004F:
2088   0D6A 76 02       	.WORD	C_I			    ;Copy LOOP index to data stack
2089   0D6C 49 06       	.WORD	C_CFETCH		;Get byte from string
2090   0D6E 4D 03       	.WORD	C_EMIT			;Output CHR from stack
2091   0D70 15 02       	.WORD	C_LLOOP			;Increment loop & branch if not done
2092   0D72 F8 FF       	.WORD	B004F-$			;FFF8h
2093   0D74 E8 01       	.WORD	C_BRANCH		;Done so branch to next
2094   0D76 04 00       	.WORD	B0006-$			;0004h
2095   0D78             B0005:
2096   0D78 BE 05       	.WORD	C_DROP			;Drop string address
2097   0D7A             B0006:
2098   0D7A C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2099   0D7C             
2100   0D7C             W_TRAILING:
2101   0D7C 892D54524149	.BYTE	89h,"-TRAILIN",'G'+80h
2101   0D82 4C494EC7
2102   0D86 53 0D       	.WORD	W_TYPE
2103   0D88             C_TRAILING:
2104   0D88 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2105   0D8A E7 05       	.WORD	C_DUP			;Duplicate top value on stack
2106   0D8C 2B 07       	.WORD	C_ZERO			;Put zero on stack
2107   0D8E 5A 02       	.WORD	C_LDO			;Put start & end loop values on RPP
2108   0D90             B0009:
2109   0D90 AF 05       	.WORD	C_OVER			;Copy 2nd down to top of stack
2110   0D92 AF 05       	.WORD	C_OVER			;Copy 2nd down to top of stack
2111   0D94 4B 05       	.WORD	C_PLUS			;n1 + n2
2112   0D96 33 07       	.WORD	C_1			;Put 1 on stack
2113   0D98 8C 0A       	.WORD	C_MINUS
2114   0D9A 49 06       	.WORD	C_CFETCH		;Get byte from addr on stack
2115   0D9C 4C 07       	.WORD	C_BL			;Leaves ASCII for space on stack
2116   0D9E 8C 0A       	.WORD	C_MINUS
2117   0DA0 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2118   0DA2 08 00       	.WORD	B0007-$			;0008h
2119   0DA4 D9 04       	.WORD	C_LEAVE			;Quit loop by making index = limit
2120   0DA6 E8 01       	.WORD	C_BRANCH		;Add following offset to BC
2121   0DA8 06 00       	.WORD	B0008-$			;0006h
2122   0DAA             B0007:
2123   0DAA 33 07       	.WORD	C_1			;Put 1 on stack
2124   0DAC 8C 0A       	.WORD	C_MINUS
2125   0DAE             B0008:
2126   0DAE 15 02       	.WORD	C_LLOOP			;Increment loop & branch if not done
2127   0DB0 E0 FF       	.WORD	B0009-$			;FFE0h
2128   0DB2 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2129   0DB4             
2130   0DB4             W_CQUOTE:				;Output following string
2131   0DB4 843C2E22BE  	.BYTE	84h,"<.",22h,'>'+80h
2132   0DB9 7C 0D       	.WORD	W_TRAILING
2133   0DBB             C_CQUOTE:
2134   0DBB B4 06       	.WORD	E_COLON			;Interpret following word sequence
2135   0DBD 18 05       	.WORD	C_RFETCH		;Copy return stack top to data stack
2136   0DBF 47 0D       	.WORD	C_COUNT			;Convert string at addr to addr + length
2137   0DC1 E7 05       	.WORD	C_DUP			;Duplicate top value on stack
2138   0DC3 1B 0A       	.WORD	C_1PLUS			;1 plus
2139   0DC5 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
2140   0DC7 4B 05       	.WORD	C_PLUS			;Add length of string +1
2141   0DC9 ED 04       	.WORD	C_MOVER			;Move value from data to return stack
2142   0DCB 5A 0D       	.WORD	C_TYPE			;Output n bytes from addr
2143   0DCD C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2144   0DCF             
2145   0DCF             W_QUOTE:				;Accept following text
2146   0DCF C2 2E A2    	.BYTE	0C2h,'.',22h+80h
2147   0DD2 B4 0D       	.WORD	W_CQUOTE
2148   0DD4             C_QUOTE:
2149   0DD4 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2150   0DD6 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2151   0DD8 22 00       	.WORD	0022h
2152   0DDA 51 08       	.WORD	C_STATE			;Push STATE addr
2153   0DDC 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2154   0DDE 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2155   0DE0 12 00       	.WORD	B000A-$			;0012h
2156   0DE2 6C 0C       	.WORD	C_COMPILE		;Compile next word into dictionary
2157   0DE4 BB 0D       	.WORD	C_CQUOTE		;
2158   0DE6 3D 0F       	.WORD	C_WORD
2159   0DE8 49 06       	.WORD	C_CFETCH		;Get byte from addr on stack
2160   0DEA 1B 0A       	.WORD	C_1PLUS			;1 plus
2161   0DEC 5F 0A       	.WORD	C_ALLOT
2162   0DEE E8 01       	.WORD	C_BRANCH		;Add following offset to BC
2163   0DF0 08 00       	.WORD	B000B-$			;0008h
2164   0DF2             B000A:
2165   0DF2 3D 0F       	.WORD	C_WORD
2166   0DF4 47 0D       	.WORD	C_COUNT			;Convert string at addr to addr + length
2167   0DF6 5A 0D       	.WORD	C_TYPE			;Output n bytes from addr
2168   0DF8             B000B:
2169   0DF8 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2170   0DFA             
2171   0DFA             W_EXPECT:
2172   0DFA 864558504543	.BYTE	86h,"EXPEC",'T'+80h
2172   0E00 D4
2173   0E01 CF 0D       	.WORD	W_QUOTE
2174   0E03             C_EXPECT:
2175   0E03 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2176   0E05 AF 05       	.WORD	C_OVER			;Copy buffer start addr
2177   0E07 4B 05       	.WORD	C_PLUS			;Add to length to give start,end
2178   0E09 AF 05       	.WORD	C_OVER			;Copy start
2179   0E0B 5A 02       	.WORD	C_LDO			;Put start & end loop values on RPP
2180   0E0D             B0012:
2181   0E0D 63 03       	.WORD	C_KEY			;Wait for key, value on stack
2182   0E0F E7 05       	.WORD	C_DUP			;Duplicate key value
2183   0E11 C4 01       	.WORD	C_LIT			;Push backspace addr
2184   0E13 56 01       	.WORD	BACKSPACE		;
2185   0E15 3A 06       	.WORD	C_FETCH			;Get backspace value
2186   0E17 A1 0A       	.WORD	C_EQUALS		;Was it backspace ?
2187   0E19 00 02       	.WORD	C_0BRANCH		;If not then jump
2188   0E1B 2A 00       	.WORD	B000C-$			;002Ah
2189   0E1D BE 05       	.WORD	C_DROP			;Drop top value from stack
2190   0E1F E7 05       	.WORD	C_DUP			;Duplicate top value on stack
2191   0E21 76 02       	.WORD	C_I			;Copy LOOP index to data stack
2192   0E23 A1 0A       	.WORD	C_EQUALS
2193   0E25 E7 05       	.WORD	C_DUP			;Duplicate top value on stack
2194   0E27 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
2195   0E29 3B 07       	.WORD	C_2
2196   0E2B 8C 0A       	.WORD	C_MINUS
2197   0E2D 4B 05       	.WORD	C_PLUS			;n1 + n2
2198   0E2F ED 04       	.WORD	C_MOVER			;Move value from data to return stack
2199   0E31 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2200   0E33 0A 00       	.WORD	B000D-$			;000Ah
2201   0E35 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2202   0E37 07 00       	.WORD	0007h
2203   0E39 E8 01       	.WORD	C_BRANCH		;Add following offset to BC
2204   0E3B 06 00       	.WORD	B000E-$			;0006h
2205   0E3D             B000D:
2206   0E3D C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2207   0E3F 08 00       	.WORD	0008h
2208   0E41             B000E:
2209   0E41 E8 01       	.WORD	C_BRANCH		;Add following offset to BC
2210   0E43 28 00       	.WORD	B000F-$			;0028h
2211   0E45             B000C:
2212   0E45 E7 05       	.WORD	C_DUP			;Duplicate key value
2213   0E47 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2214   0E49 0D 00       	.WORD	000Dh			;CR
2215   0E4B A1 0A       	.WORD	C_EQUALS		;Was it cariage return
2216   0E4D 00 02       	.WORD	C_0BRANCH		;If not then jump
2217   0E4F 0E 00       	.WORD	B0010-$			;000Eh
2218   0E51 D9 04       	.WORD	C_LEAVE			;Quit loop by making index = limit
2219   0E53 BE 05       	.WORD	C_DROP			;Drop top value from stack
2220   0E55 4C 07       	.WORD	C_BL			;Leaves ASCII for space on stack
2221   0E57 2B 07       	.WORD	C_ZERO			;Put zero on stack
2222   0E59 E8 01       	.WORD	C_BRANCH		;Add following offset to BC
2223   0E5B 04 00       	.WORD	B0011-$			;0004h
2224   0E5D             B0010:
2225   0E5D E7 05       	.WORD	C_DUP			;Duplicate key value
2226   0E5F             B0011:
2227   0E5F 76 02       	.WORD	C_I			;Copy LOOP index to data stack
2228   0E61 80 06       	.WORD	C_CSTORE		;Store byte at addr
2229   0E63 2B 07       	.WORD	C_ZERO			;Put zero on stack
2230   0E65 76 02       	.WORD	C_I			;Copy LOOP index to data stack
2231   0E67 1B 0A       	.WORD	C_1PLUS			;1 plus
2232   0E69 71 06       	.WORD	C_STORE			;Store word at addr
2233   0E6B             B000F:
2234   0E6B 4D 03       	.WORD	C_EMIT			;Output CHR from stack
2235   0E6D 15 02       	.WORD	C_LLOOP			;Increment loop & branch if not done
2236   0E6F 9E FF       	.WORD	B0012-$			;FF9Eh
2237   0E71 BE 05       	.WORD	C_DROP			;Drop top value from stack
2238   0E73 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2239   0E75             
2240   0E75             W_QUERY:
2241   0E75 8551554552D9	.BYTE	85h,"QUER",'Y'+80h
2242   0E7B FA 0D       	.WORD	W_EXPECT
2243   0E7D             C_QUERY:
2244   0E7D B4 06       	.WORD	E_COLON			;Interpret following word sequence
2245   0E7F B6 07       	.WORD	C_TIB			;Put TIB addr on stack
2246   0E81 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2247   0E83 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2248   0E85 50 00       	.WORD	0050h			;Max line length 50h
2249   0E87 03 0E       	.WORD	C_EXPECT		;Get line
2250   0E89 2B 07       	.WORD	C_ZERO			;Put zero on stack
2251   0E8B 08 08       	.WORD	C_TOIN			;Current input buffer offset
2252   0E8D 71 06       	.WORD	C_STORE			;Store word at addr
2253   0E8F C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2254   0E91             
2255   0E91             W_NULL:
2256   0E91 C1 80       	.BYTE	0C1h,80h
2257   0E93 75 0E       	.WORD	W_QUERY
2258   0E95             C_NULL:
2259   0E95 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2260   0E97 FE 07       	.WORD	C_BLK
2261   0E99 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2262   0E9B 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2263   0E9D 2A 00       	.WORD	B0013-$			;002Ah
2264   0E9F 33 07       	.WORD	C_1			;Put 1 on stack
2265   0EA1 FE 07       	.WORD	C_BLK
2266   0EA3 15 06       	.WORD	C_PLUSSTORE		;Add n1 to addr
2267   0EA5 2B 07       	.WORD	C_ZERO			;Put zero on stack
2268   0EA7 08 08       	.WORD	C_TOIN			;Current input buffer offset
2269   0EA9 71 06       	.WORD	C_STORE			;Store word at addr
2270   0EAB FE 07       	.WORD	C_BLK
2271   0EAD 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2272   0EAF 96 07       	.WORD	C_BSCR			;Number of buffers per block on stack
2273   0EB1 33 07       	.WORD	C_1			;Put 1 on stack
2274   0EB3 8C 0A       	.WORD	C_MINUS
2275   0EB5 3E 04       	.WORD	C_AND			;AND
2276   0EB7 1F 05       	.WORD	C_0EQUALS		;=0
2277   0EB9 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2278   0EBB 08 00       	.WORD	B0014-$			;0008h
2279   0EBD 0B 0C       	.WORD	C_QEXEC			;Error not if not in execute mode
2280   0EBF 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
2281   0EC1 BE 05       	.WORD	C_DROP			;Drop top value from stack
2282   0EC3             B0014:
2283   0EC3 E8 01       	.WORD	C_BRANCH		;Add following offset to BC
2284   0EC5 06 00       	.WORD	B0015-$			;0006h
2285   0EC7             B0013:
2286   0EC7 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
2287   0EC9 BE 05       	.WORD	C_DROP			;Drop top value from stack
2288   0ECB             B0015:
2289   0ECB C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2290   0ECD             
2291   0ECD             W_FILL:					;Fill with byte n bytes from addr
2292   0ECD 8446494CCC  	.BYTE	84h,"FIL",'L'+80h
2293   0ED2 91 0E       	.WORD	W_NULL
2294   0ED4             C_FILL:
2295   0ED4 D6 0E       	.WORD	2+$			;Vector to code
2296   0ED6 69          	LD	L,C			;Save BC for now
2297   0ED7 60          	LD	H,B			;
2298   0ED8 D1          	POP	DE			; get byte
2299   0ED9 C1          	POP	BC			; get n
2300   0EDA E3          	EX	(SP),HL			; get addr and save BC
2301   0EDB EB          	EX	DE,HL			;
2302   0EDC             NEXT_BYTE:
2303   0EDC 78          	LD	A,B			;Test count
2304   0EDD B1          	OR	C			;
2305   0EDE 28 06       	JR	Z,NO_COUNT		;If 0 we're done
2306   0EE0 7D          	LD	A,L			;Byte into A
2307   0EE1 12          	LD	(DE),A			;Save byte
2308   0EE2 13          	INC	DE			;Next addr
2309   0EE3 0B          	DEC	BC			;Decr count
2310   0EE4 18 F6       	JR	NEXT_BYTE		;Loop
2311   0EE6             NO_COUNT:
2312   0EE6 C1          	POP	BC			;Get BC back
2313   0EE7 C3 9E 01    	JP	NEXT
2314   0EEA             
2315   0EEA             W_ERASE:				;Fill addr & length from stack with 0
2316   0EEA 8545524153C5	.BYTE	85h,"ERAS",'E'+80h
2317   0EF0 CD 0E       	.WORD	W_FILL
2318   0EF2             C_ERASE:
2319   0EF2 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2320   0EF4 2B 07       	.WORD	C_ZERO			;Put zero on stack
2321   0EF6 D4 0E       	.WORD	C_FILL			;Fill with byte n bytes from addr
2322   0EF8 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2323   0EFA             
2324   0EFA             W_BLANKS:				;Fill addr & length from stack with [SP]
2325   0EFA 86424C414E4B	.BYTE	86h,"BLANK",'S'+80h
2325   0F00 D3
2326   0F01 EA 0E       	.WORD	W_ERASE
2327   0F03             C_BLANKS:
2328   0F03 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2329   0F05 4C 07       	.WORD	C_BL			;Leaves ASCII for space on stack
2330   0F07 D4 0E       	.WORD	C_FILL			;Fill with byte n bytes from addr
2331   0F09 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2332   0F0B             
2333   0F0B             W_HOLD:
2334   0F0B 84484F4CC4  	.BYTE	84h,"HOL",'D'+80h
2335   0F10 FA 0E       	.WORD	W_BLANKS
2336   0F12             C_HOLD:
2337   0F12 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2338   0F14 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2339   0F16 FF FF       	.WORD	0FFFFh
2340   0F18 8D 08       	.WORD	C_HLD
2341   0F1A 15 06       	.WORD	C_PLUSSTORE		;Add n1 to addr
2342   0F1C 8D 08       	.WORD	C_HLD
2343   0F1E 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2344   0F20 80 06       	.WORD	C_CSTORE		;Store byte at addr
2345   0F22 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2346   0F24             
2347   0F24             W_PAD:
2348   0F24 83 50 41 C4 	.BYTE	83h,"PA",'D'+80h
2349   0F28 0B 0F       	.WORD	W_HOLD
2350   0F2A             C_PAD:
2351   0F2A B4 06       	.WORD	E_COLON			;Interpret following word sequence
2352   0F2C 4F 0A       	.WORD	C_HERE			;Dictionary pointer onto stack
2353   0F2E C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2354   0F30 44 00       	.WORD	0044h
2355   0F32 4B 05       	.WORD	C_PLUS			;n1 + n2
2356   0F34 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2357   0F36             
2358   0F36             W_WORD:
2359   0F36 84574F52C4  	.BYTE	84h,"WOR",'D'+80h
2360   0F3B 24 0F       	.WORD	W_PAD
2361   0F3D             C_WORD:
2362   0F3D B4 06       	.WORD	E_COLON			;Interpret following word sequence
2363   0F3F FE 07       	.WORD	C_BLK
2364   0F41 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2365   0F43 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2366   0F45 0C 00       	.WORD	B0016-$			;000Ch
2367   0F47 FE 07       	.WORD	C_BLK
2368   0F49 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2369   0F4B 55 15       	.WORD	C_BLOCK
2370   0F4D E8 01       	.WORD	C_BRANCH		;Add following offset to BC
2371   0F4F 06 00       	.WORD	B0017-$			;0006h
2372   0F51             B0016:
2373   0F51 B6 07       	.WORD	C_TIB
2374   0F53 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2375   0F55             B0017:
2376   0F55 08 08       	.WORD	C_TOIN			;Current input buffer offset
2377   0F57 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2378   0F59 4B 05       	.WORD	C_PLUS			;n1 + n2
2379   0F5B DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
2380   0F5D 02 03       	.WORD	C_ENCLOSE
2381   0F5F 4F 0A       	.WORD	C_HERE			;Dictionary pointer onto stack
2382   0F61 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2383   0F63 22 00       	.WORD	0022h
2384   0F65 03 0F       	.WORD	C_BLANKS
2385   0F67 08 08       	.WORD	C_TOIN			;Current input buffer offset
2386   0F69 15 06       	.WORD	C_PLUSSTORE		;Add n1 to addr
2387   0F6B AF 05       	.WORD	C_OVER			;Copy 2nd down to top of stack
2388   0F6D 8C 0A       	.WORD	C_MINUS
2389   0F6F ED 04       	.WORD	C_MOVER			;Move value from data to return stack
2390   0F71 18 05       	.WORD	C_RFETCH		;Return stack top to data stack
2391   0F73 4F 0A       	.WORD	C_HERE			;Dictionary pointer onto stack
2392   0F75 80 06       	.WORD	C_CSTORE		;Store byte at addr
2393   0F77 4B 05       	.WORD	C_PLUS			;n1 + n2
2394   0F79 4F 0A       	.WORD	C_HERE			;Dictionary pointer onto stack
2395   0F7B 1B 0A       	.WORD	C_1PLUS			;1 plus
2396   0F7D 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
2397   0F7F A6 03       	.WORD	C_CMOVE			;Move block
2398   0F81 4F 0A       	.WORD	C_HERE			;Dictionary pointer onto stack
2399   0F83 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2400   0F85             
2401   0F85             W_CONVERT:
2402   0F85 87434F4E5645	.BYTE	87h,"CONVER",'T'+80h
2402   0F8B 52D4
2403   0F8D 36 0F       	.WORD	W_WORD
2404   0F8F             C_CONVERT:
2405   0F8F B4 06       	.WORD	E_COLON			;Interpret following word sequence
2406   0F91             B001A:
2407   0F91 1B 0A       	.WORD	C_1PLUS			;1 plus
2408   0F93 E7 05       	.WORD	C_DUP			;Duplicate top value on stack
2409   0F95 ED 04       	.WORD	C_MOVER			;Move value from data to return stack
2410   0F97 49 06       	.WORD	C_CFETCH		;Get byte from addr on stack
2411   0F99 5C 08       	.WORD	C_BASE			;Put BASE addr on stack
2412   0F9B 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2413   0F9D 8A 02       	.WORD	C_DIGIT			;Convert digit n2 using base n1
2414   0F9F 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2415   0FA1 2C 00       	.WORD	B0018-$			;002Ch
2416   0FA3 DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
2417   0FA5 5C 08       	.WORD	C_BASE			;Put BASE addr on stack
2418   0FA7 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2419   0FA9 BC 03       	.WORD	C_USTAR
2420   0FAB BE 05       	.WORD	C_DROP			;Drop top value from stack
2421   0FAD FD 0A       	.WORD	C_ROT			;3rd value down to top of stack
2422   0FAF 5C 08       	.WORD	C_BASE			;Put BASE addr on stack
2423   0FB1 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2424   0FB3 BC 03       	.WORD	C_USTAR
2425   0FB5 58 05       	.WORD	C_DPLUS
2426   0FB7 66 08       	.WORD	C_DPL
2427   0FB9 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2428   0FBB 1B 0A       	.WORD	C_1PLUS			;1 plus
2429   0FBD 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2430   0FBF 08 00       	.WORD	B0019-$			;0008h
2431   0FC1 33 07       	.WORD	C_1			;Put 1 on stack
2432   0FC3 66 08       	.WORD	C_DPL
2433   0FC5 15 06       	.WORD	C_PLUSSTORE		;Add n1 to addr
2434   0FC7             B0019:
2435   0FC7 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
2436   0FC9 E8 01       	.WORD	C_BRANCH		;Add following offset to BC
2437   0FCB C6 FF       	.WORD	B001A-$			;FFC6h
2438   0FCD             B0018:
2439   0FCD 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
2440   0FCF C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2441   0FD1             
2442   0FD1             W_NUMBER:
2443   0FD1 864E554D4245	.BYTE	86h,"NUMBE",'R'+80h
2443   0FD7 D2
2444   0FD8 85 0F       	.WORD	W_CONVERT
2445   0FDA             C_NUMBER:
2446   0FDA B4 06       	.WORD	E_COLON			;Interpret following word sequence
2447   0FDC 2B 07       	.WORD	C_ZERO			;Put zero on stack
2448   0FDE 2B 07       	.WORD	C_ZERO			;Put zero on stack
2449   0FE0 FD 0A       	.WORD	C_ROT			;3rd value down to top of stack
2450   0FE2 E7 05       	.WORD	C_DUP			;Duplicate top value on stack
2451   0FE4 1B 0A       	.WORD	C_1PLUS			;1 plus
2452   0FE6 49 06       	.WORD	C_CFETCH		;Get byte from addr on stack
2453   0FE8 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2454   0FEA 2D 00       	.WORD	002Dh			;'-'
2455   0FEC A1 0A       	.WORD	C_EQUALS		;Is first chr = '-'
2456   0FEE E7 05       	.WORD	C_DUP			;Duplicate negative flag
2457   0FF0 ED 04       	.WORD	C_MOVER			;Move value from data to return stack
2458   0FF2 4B 05       	.WORD	C_PLUS			;n1 + n2
2459   0FF4 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2460   0FF6 FF FF       	.WORD	0FFFFh			; -1
2461   0FF8             B001C:
2462   0FF8 66 08       	.WORD	C_DPL
2463   0FFA 71 06       	.WORD	C_STORE			;Store word at addr
2464   0FFC 8F 0F       	.WORD	C_CONVERT
2465   0FFE E7 05       	.WORD	C_DUP			;Duplicate top value on stack
2466   1000 49 06       	.WORD	C_CFETCH		;Get byte from addr on stack
2467   1002 4C 07       	.WORD	C_BL			;Leaves ASCII for space on stack
2468   1004 8C 0A       	.WORD	C_MINUS
2469   1006 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2470   1008 16 00       	.WORD	B001B-$			;0016h
2471   100A E7 05       	.WORD	C_DUP			;Duplicate top value on stack
2472   100C 49 06       	.WORD	C_CFETCH		;Get byte from addr on stack
2473   100E C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2474   1010 2E 00       	.WORD	002Eh			;'.'
2475   1012 8C 0A       	.WORD	C_MINUS
2476   1014 2B 07       	.WORD	C_ZERO			;Put zero on stack
2477   1016 D9 0B       	.WORD	C_QERROR
2478   1018 2B 07       	.WORD	C_ZERO			;Put zero on stack
2479   101A E8 01       	.WORD	C_BRANCH		;Add following offset to BC
2480   101C DC FF       	.WORD	B001C-$			;FFDCh
2481   101E             B001B:
2482   101E BE 05       	.WORD	C_DROP			;Drop top value from stack
2483   1020 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
2484   1022 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2485   1024 04 00       	.WORD	B001D-$			;0004h
2486   1026 92 05       	.WORD	C_DNEGATE
2487   1028             B001D:
2488   1028 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2489   102A             
2490   102A             W_MFIND:
2491   102A 852D46494EC4	.BYTE	85h,"-FIN",'D'+80h
2492   1030 D1 0F       	.WORD	W_NUMBER
2493   1032             C_MFIND:
2494   1032 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2495   1034 4C 07       	.WORD	C_BL			;Leaves ASCII for space on stack
2496   1036 3D 0F       	.WORD	C_WORD
2497   1038 37 08       	.WORD	C_CONTEXT
2498   103A 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2499   103C 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2500   103E B8 02       	.WORD	C_FIND			;Find word & return vector,byte & flag
2501   1040 E7 05       	.WORD	C_DUP			;Duplicate top value on stack
2502   1042 1F 05       	.WORD	C_0EQUALS		;=0
2503   1044 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2504   1046 0A 00       	.WORD	B001E-$			;000Ah
2505   1048 BE 05       	.WORD	C_DROP			;Drop top value from stack
2506   104A 4F 0A       	.WORD	C_HERE			;Dictionary pointer onto stack
2507   104C 6D 0B       	.WORD	C_LATEST		;Push top words NFA
2508   104E B8 02       	.WORD	C_FIND			;Find word & return vector,byte & flag
2509   1050             B001E:
2510   1050 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2511   1052             
2512   1052             W_CABORT:
2513   1052 873C41424F52	.BYTE	87h,"<ABORT",'>'+80h
2513   1058 54BE
2514   105A 2A 10       	.WORD	W_MFIND
2515   105C             C_CABORT:
2516   105C B4 06       	.WORD	E_COLON			;Interpret following word sequence
2517   105E 94 12       	.WORD	C_ABORT
2518   1060 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2519   1062             
2520   1062             W_ERROR:
2521   1062 854552524FD2	.BYTE	85h,"ERRO",'R'+80h
2522   1068 52 10       	.WORD	W_CABORT
2523   106A             C_ERROR:
2524   106A B4 06       	.WORD	E_COLON			;Interpret following word sequence
2525   106C D0 07       	.WORD	C_WARNING		;Put WARNING addr on stack
2526   106E 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2527   1070 3A 05       	.WORD	C_0LESS			;Less than 0 leaves true
2528   1072 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2529   1074 04 00       	.WORD	B001F-$			;0004h
2530   1076 5C 10       	.WORD	C_CABORT
2531   1078             B001F:
2532   1078 4F 0A       	.WORD	C_HERE			;Dictionary pointer onto stack
2533   107A 47 0D       	.WORD	C_COUNT			;Convert string at addr to addr + length
2534   107C 5A 0D       	.WORD	C_TYPE			;Output n bytes from addr
2535   107E BB 0D       	.WORD	C_CQUOTE		;Output following string
2536   1080 02          	.BYTE	S_END7-S_START7
2537   1081             S_START7:
2538   1081 3F 20       	.BYTE	"? "		;
2539   1083             S_END7:
2540   1083 9B 14       	.WORD	C_MESSAGE		;Output message
2541   1085 85 04       	.WORD	C_SPSTORE		;Set initial stack pointer value
2542   1087 FE 07       	.WORD	C_BLK
2543   1089 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2544   108B 31 0B       	.WORD	C_QUERYDUP
2545   108D 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2546   108F 08 00       	.WORD	B0020-$			;0008h
2547   1091 08 08       	.WORD	C_TOIN			;Current input buffer offset
2548   1093 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2549   1095 DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
2550   1097             B0020:
2551   1097 67 12       	.WORD	C_QUIT
2552   1099             
2553   1099             W_ID:					;Print definition name from name field addr
2554   1099 83 49 44 AE 	.BYTE	83h,"ID",'.'+80h
2555   109D 62 10       	.WORD	W_ERROR
2556   109F             C_ID:
2557   109F B4 06       	.WORD	E_COLON			;Interpret following word sequence
2558   10A1 47 0D       	.WORD	C_COUNT			;Convert string at addr to addr + length
2559   10A3 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2560   10A5 1F 00       	.WORD	001Fh			;Max length is 1Fh
2561   10A7 3E 04       	.WORD	C_AND			;AND lenght with 1Fh
2562   10A9 5A 0D       	.WORD	C_TYPE			;Output n bytes from addr
2563   10AB 22 0B       	.WORD	C_SPACE			;Output space
2564   10AD C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2565   10AF             
2566   10AF             C_XXX1:
2567   10AF B4 06       	.WORD	E_COLON			;Interpret following word sequence
2568   10B1 32 10       	.WORD	C_MFIND			;Find name returns PFA,length,true or false
2569   10B3 00 02       	.WORD	C_0BRANCH		;Branch if name not found
2570   10B5 10 00       	.WORD	B0021-$			;0010h
2571   10B7 BE 05       	.WORD	C_DROP			;Drop length
2572   10B9 9B 0B       	.WORD	C_NFA			;Convert PFA to NFA
2573   10BB 9F 10       	.WORD	C_ID			;Print definition name from name field addr
2574   10BD C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2575   10BF 04 00       	.WORD	0004h			;Message 4, name defined twice
2576   10C1 9B 14       	.WORD	C_MESSAGE		;Output message
2577   10C3 22 0B       	.WORD	C_SPACE			;Output space
2578   10C5             B0021:
2579   10C5 4F 0A       	.WORD	C_HERE			;Dictionary pointer onto stack
2580   10C7 E7 05       	.WORD	C_DUP			;Duplicate top value on stack
2581   10C9 49 06       	.WORD	C_CFETCH		;Get byte from addr on stack
2582   10CB C2 07       	.WORD	C_WIDTH
2583   10CD 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2584   10CF 78 13       	.WORD	C_MIN
2585   10D1 1B 0A       	.WORD	C_1PLUS			;1 plus
2586   10D3 5F 0A       	.WORD	C_ALLOT			;Which ever is smallest width or namelength
2587   10D5 E7 05       	.WORD	C_DUP			;Duplicate top value on stack
2588   10D7 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2589   10D9 A0 00       	.WORD	00A0h
2590   10DB 2C 06       	.WORD	C_TOGGLE		;XOR (addr) with byte
2591   10DD 4F 0A       	.WORD	C_HERE			;Dictionary pointer onto stack
2592   10DF 33 07       	.WORD	C_1			;Put 1 on stack
2593   10E1 8C 0A       	.WORD	C_MINUS
2594   10E3 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2595   10E5 80 00       	.WORD	0080h
2596   10E7 2C 06       	.WORD	C_TOGGLE		;XOR (addr) with byte
2597   10E9 6D 0B       	.WORD	C_LATEST		;Push top words NFA
2598   10EB 6B 0A       	.WORD	C_COMMA			;Reserve 2 bytes and save n
2599   10ED 45 08       	.WORD	C_CURRENT
2600   10EF 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2601   10F1 71 06       	.WORD	C_STORE			;Store word at addr
2602   10F3 4F 0A       	.WORD	C_HERE			;Dictionary pointer onto stack
2603   10F5 27 0A       	.WORD	C_2PLUS			;2 plus
2604   10F7 6B 0A       	.WORD	C_COMMA			;Reserve 2 bytes and save n
2605   10F9 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2606   10FB             
2607   10FB             W_CCOMPILE:
2608   10FB 895B434F4D50	.BYTE	89h,"[COMPILE",']'+80h
2608   1101 494C45DD
2609   1105 99 10       	.WORD	W_ID
2610   1107             C_CCOMPILE:
2611   1107 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2612   1109 32 10       	.WORD	C_MFIND
2613   110B 1F 05       	.WORD	C_0EQUALS		;=0
2614   110D 2B 07       	.WORD	C_ZERO			;Put zero on stack
2615   110F D9 0B       	.WORD	C_QERROR
2616   1111 BE 05       	.WORD	C_DROP			;Drop top value from stack
2617   1113 8D 0B       	.WORD	C_CFA			;Convert PFA to CFA
2618   1115 6B 0A       	.WORD	C_COMMA			;Reserve 2 bytes and save n
2619   1117 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2620   1119             
2621   1119             W_LITERAL:
2622   1119 C74C49544552	.BYTE	0C7h,"LITERA",'L'+80h
2622   111F 41CC
2623   1121 FB 10       	.WORD	W_CCOMPILE
2624   1123             C_LITERAL:
2625   1123 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2626   1125 51 08       	.WORD	C_STATE			;Push STATE addr
2627   1127 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2628   1129 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2629   112B 08 00       	.WORD	B0022-$			;0008h
2630   112D 6C 0C       	.WORD	C_COMPILE		;Compile next word into dictionary
2631   112F C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2632   1131 6B 0A       	.WORD	C_COMMA			;Reserve 2 bytes and save n
2633   1133             B0022:
2634   1133 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2635   1135             
2636   1135             W_DLITERAL:
2637   1135 C8444C495445	.BYTE	0C8h,"DLITERA",'L'+80h
2637   113B 5241CC
2638   113E 19 11       	.WORD	W_LITERAL
2639   1140             C_DLITERAL:
2640   1140 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2641   1142 51 08       	.WORD	C_STATE			;Push STATE addr
2642   1144 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2643   1146 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2644   1148 08 00       	.WORD	B0023-$			;0008h
2645   114A DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
2646   114C 23 11       	.WORD	C_LITERAL
2647   114E 23 11       	.WORD	C_LITERAL
2648   1150             B0023:
2649   1150 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2650   1152             
2651   1152             W_QSTACK:
2652   1152 863F53544143	.BYTE	86h,"?STAC",'K'+80h
2652   1158 CB
2653   1159 35 11       	.WORD	W_DLITERAL
2654   115B             C_QSTACK:
2655   115B B4 06       	.WORD	E_COLON			;Interpret following word sequence
2656   115D 76 04       	.WORD	C_SPFETCH		;Stack pointer onto stack
2657   115F A3 07       	.WORD	C_S0			;Push S0 (initial data stack pointer)
2658   1161 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2659   1163 DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
2660   1165 CF 0A       	.WORD	C_ULESS			;IF stack-1 < stack_top leave true flag
2661   1167 33 07       	.WORD	C_1			;Put 1 on stack
2662   1169 D9 0B       	.WORD	C_QERROR
2663   116B 76 04       	.WORD	C_SPFETCH		;Stack pointer onto stack
2664   116D 4F 0A       	.WORD	C_HERE			;Dictionary pointer onto stack
2665   116F C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2666   1171 80 00       	.WORD	0080h
2667   1173 4B 05       	.WORD	C_PLUS			;n1 + n2
2668   1175 CF 0A       	.WORD	C_ULESS			;IF stack-1 < stack_top leave true flag
2669   1177 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2670   1179 07 00       	.WORD	0007h
2671   117B D9 0B       	.WORD	C_QERROR
2672   117D C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2673   117F             
2674   117F             W_INTERPRET:
2675   117F 89494E544552	.BYTE	89h,"INTERPRE",'T'+80h
2675   1185 505245D4
2676   1189 52 11       	.WORD	W_QSTACK
2677   118B             C_INTERPRET:
2678   118B B4 06       	.WORD	E_COLON			;Interpret following word sequence
2679   118D             B002A:
2680   118D 32 10       	.WORD	C_MFIND			;Find name returns PFA,length,true or false
2681   118F 00 02       	.WORD	C_0BRANCH		;Branch if name not found
2682   1191 1E 00       	.WORD	NO_NAME-$		;
2683   1193 51 08       	.WORD	C_STATE			;STATE addr on stack
2684   1195 3A 06       	.WORD	C_FETCH			;Get STATE
2685   1197 AD 0A       	.WORD	C_LESSTHAN		;Is it quit compile word ?
2686   1199 00 02       	.WORD	C_0BRANCH		;If so then branch
2687   119B 0A 00       	.WORD	B0025-$			;
2688   119D 8D 0B       	.WORD	C_CFA			;Convert PFA to CFA
2689   119F 6B 0A       	.WORD	C_COMMA			;Reserve 2 bytes and save n
2690   11A1 E8 01       	.WORD	C_BRANCH		;Add following offset to BC
2691   11A3 06 00       	.WORD	B0026-$			;
2692   11A5             B0025:
2693   11A5 8D 0B       	.WORD	C_CFA			;Convert PFA to CFA
2694   11A7 D9 01       	.WORD	C_EXECUTE		;Jump to address on stack
2695   11A9             B0026:
2696   11A9 5B 11       	.WORD	C_QSTACK		;Error message if stack underflow
2697   11AB E8 01       	.WORD	C_BRANCH		;Add following offset to BC
2698   11AD 1C 00       	.WORD	B0027-$			;
2699   11AF             NO_NAME:
2700   11AF 4F 0A       	.WORD	C_HERE			;Dictionary pointer onto stack
2701   11B1 DA 0F       	.WORD	C_NUMBER		;Convert string at addr to double
2702   11B3 66 08       	.WORD	C_DPL			;
2703   11B5 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2704   11B7 1B 0A       	.WORD	C_1PLUS			;1 plus
2705   11B9 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2706   11BB 08 00       	.WORD	B0028-$			;
2707   11BD 40 11       	.WORD	C_DLITERAL
2708   11BF E8 01       	.WORD	C_BRANCH		;Add following offset to BC
2709   11C1 06 00       	.WORD	B0029-$			;
2710   11C3             B0028:
2711   11C3 BE 05       	.WORD	C_DROP			;Drop top value from stack
2712   11C5 23 11       	.WORD	C_LITERAL
2713   11C7             B0029:
2714   11C7 5B 11       	.WORD	C_QSTACK		;Error message if stack underflow
2715   11C9             B0027:
2716   11C9 E8 01       	.WORD	C_BRANCH		;Add following offset to BC
2717   11CB C2 FF       	.WORD	B002A-$			;FFC2h
2718   11CD             
2719   11CD             W_IMMEDIATE:
2720   11CD 89494D4D4544	.BYTE	89h,"IMMEDIAT",'E'+80h
2720   11D3 494154C5
2721   11D7 7F 11       	.WORD	W_INTERPRET
2722   11D9             C_IMMEDIATE:
2723   11D9 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2724   11DB 6D 0B       	.WORD	C_LATEST		;Push top words NFA
2725   11DD C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2726   11DF 40 00       	.WORD	0040h
2727   11E1 2C 06       	.WORD	C_TOGGLE		;XOR (addr) with byte
2728   11E3 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2729   11E5             
2730   11E5             W_VOCABULARY:
2731   11E5 8A564F434142	.BYTE	8Ah,"VOCABULAR",'Y'+80h
2731   11EB 554C4152D9
2732   11F0 CD 11       	.WORD	W_IMMEDIATE
2733   11F2             C_VOCABULARY:
2734   11F2 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2735   11F4 10 0D       	.WORD	C_CREATE
2736   11F6 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2737   11F8 81 A0       	.WORD	0A081h
2738   11FA 6B 0A       	.WORD	C_COMMA			;Reserve 2 bytes and save n
2739   11FC 45 08       	.WORD	C_CURRENT
2740   11FE 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2741   1200 8D 0B       	.WORD	C_CFA			;Convert PFA to CFA
2742   1202 6B 0A       	.WORD	C_COMMA			;Reserve 2 bytes and save n
2743   1204 4F 0A       	.WORD	C_HERE			;Dictionary pointer onto stack
2744   1206 F4 07       	.WORD	C_VOC_LINK
2745   1208 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2746   120A 6B 0A       	.WORD	C_COMMA			;Reserve 2 bytes and save n
2747   120C F4 07       	.WORD	C_VOC_LINK
2748   120E 71 06       	.WORD	C_STORE			;Store word at addr
2749   1210 20 0D       	.WORD	C_DOES
2750   1212 27 0A       	.WORD	C_2PLUS			;2 plus
2751   1214 37 08       	.WORD	C_CONTEXT
2752   1216 71 06       	.WORD	C_STORE			;Store word at addr
2753   1218 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2754   121A             
2755   121A             C_LINK:
2756   121A 27 0A       	.WORD	C_2PLUS			;2 plus
2757   121C 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2758   121E 37 08       	.WORD	C_CONTEXT
2759   1220 71 06       	.WORD	C_STORE			;Store word at addr
2760   1222 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2761   1224             
2762   1224             W_FORTH:
2763   1224 C5464F5254C8	.BYTE	0C5h,"FORT",'H'+80h
2764   122A E5 11       	.WORD	W_VOCABULARY
2765   122C             C_FORTH:
2766   122C 2C 0D       	.WORD	X_DOES
2767   122E 1A 12       	.WORD	C_LINK
2768   1230             
2769   1230 81 20       	.BYTE	81h," "+80h
2770   1232 34 FE       	.WORD	FLAST+2
2771   1234             E_FORTH:
2772   1234 00 00       	.WORD	0000h
2773   1236             
2774   1236             W_DEFINITIONS:				;Set CURRENT as CONTEXT vocabulary
2775   1236 8B444546494E	.BYTE	8Bh,"DEFINITION",'S'+80h
2775   123C 4954494F4ED3
2776   1242 24 12       	.WORD	W_FORTH
2777   1244             C_DEFINITIONS:
2778   1244 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2779   1246 37 08       	.WORD	C_CONTEXT		;Get CONTEXT addr
2780   1248 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2781   124A 45 08       	.WORD	C_CURRENT		;Get CURRENT addr
2782   124C 71 06       	.WORD	C_STORE			;Set CURRENT as the context vocabulary
2783   124E C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2784   1250             
2785   1250             W_OPENBRKT:
2786   1250 C1 A8       	.BYTE	0C1h,'('+80h
2787   1252 36 12       	.WORD	W_DEFINITIONS
2788   1254             C_OPENBRKT:
2789   1254 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2790   1256 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2791   1258 29 00       	.WORD	0029h
2792   125A 3D 0F       	.WORD	C_WORD
2793   125C BE 05       	.WORD	C_DROP			;Drop top value from stack
2794   125E C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2795   1260             
2796   1260             ;		This it the last thing ever executed and is the interpreter
2797   1260             ;		outer loop. This NEVER quits.
2798   1260             
2799   1260             W_QUIT:
2800   1260 84515549D4  	.BYTE	84h,"QUI",'T'+80h
2801   1265 50 12       	.WORD	W_OPENBRKT
2802   1267             C_QUIT:
2803   1267 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2804   1269 2B 07       	.WORD	C_ZERO			;Put zero on stack
2805   126B FE 07       	.WORD	C_BLK			;Get current BLK pointer
2806   126D 71 06       	.WORD	C_STORE			;Set BLK to 0
2807   126F 82 0C       	.WORD	C_LEFTBRKT		;Set STATE to execute
2808   1271             B002C:
2809   1271 AA 04       	.WORD	C_RPSTORE		;Set initial return stack pointer
2810   1273 84 03       	.WORD	C_CR			;Output [CR][LF]
2811   1275 7D 0E       	.WORD	C_QUERY			;Get string from input, ends in CR
2812   1277 8B 11       	.WORD	C_INTERPRET		;Interpret input stream
2813   1279 51 08       	.WORD	C_STATE			;Push STATE addr
2814   127B 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2815   127D 1F 05       	.WORD	C_0EQUALS		;=0
2816   127F 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2817   1281 07 00       	.WORD	S_END8-$		;0007h
2818   1283 BB 0D       	.WORD	C_CQUOTE		;Output following string
2819   1285 02          	.BYTE	S_END8-S_START8
2820   1286             S_START8:
2821   1286 4F 4B       	.BYTE	"OK"
2822   1288             S_END8:
2823   1288 E8 01       	.WORD	C_BRANCH		;Add following offset to BC
2824   128A E7 FF       	.WORD	B002C-$			;FFE7h
2825   128C             
2826   128C             W_ABORT:
2827   128C 8541424F52D4	.BYTE	85h,"ABOR",'T'+80h
2828   1292 60 12       	.WORD	W_QUIT
2829   1294             C_ABORT:
2830   1294 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2831   1296 16 09       	.WORD	C_UABORT		;Put UABORT on stack
2832   1298 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
2833   129A D9 01       	.WORD	C_EXECUTE		;Jump to address on stack
2834   129C C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2835   129E             
2836   129E             CF_UABORT:
2837   129E B4 06       	.WORD	E_COLON			;Interpret following word sequence
2838   12A0 85 04       	.WORD	C_SPSTORE		;Set initial stack pointer value
2839   12A2 CD 0C       	.WORD	C_DECIMAL		;Sets decimal mode
2840   12A4 5B 11       	.WORD	C_QSTACK		;Error message if stack underflow
2841   12A6 84 03       	.WORD	C_CR			;Output [CR][LF]
2842   12A8 BB 0D       	.WORD	C_CQUOTE		;Output following string
2843   12AA 0D          	.BYTE	S_END1-S_START1		;String length
2844   12AB             S_START1:
2845   12AB 2A205A383020	.BYTE	"* Z80 FORTH *"
2845   12B1 464F525448202A
2846   12B8             S_END1:
2847   12B8 2C 12       	.WORD	C_FORTH
2848   12BA 44 12       	.WORD	C_DEFINITIONS		;Set CURRENT as CONTEXT vocabulary
2849   12BC 67 12       	.WORD	C_QUIT
2850   12BE             
2851   12BE             W_WARM:
2852   12BE 84574152CD  	.BYTE	84h,"WAR",'M'+80h
2853   12C3 8C 12       	.WORD	W_ABORT
2854   12C5             C_WARM:
2855   12C5 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2856   12C7 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2857   12C9 58 01       	.WORD	WORD1			;Start of detault table
2858   12CB C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2859   12CD 06 FE       	.WORD	S0			;S0 addr
2860   12CF C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2861   12D1 10 00       	.WORD	START_TABLE-WORD1	;(000Ch) Table length
2862   12D3 A6 03       	.WORD	C_CMOVE			;Move block
2863   12D5 94 12       	.WORD	C_ABORT
2864   12D7             
2865   12D7             X_COLD:
2866   12D7             
2867   12D7 21 68 01    	LD	HL,START_TABLE	        ;Copy table to ram
2868   12DA 11 32 FE    	LD	DE,FLAST		        ;Where the table's going
2869   12DD 01 34 00    	LD	BC,NEXTS2-START_TABLE	;Bytes to copy
2870   12E0 ED B0       	LDIR				   ;
2871   12E2 21 50 1B    	LD	HL,W_TASK		   ; Copy TASK to ram
2872   12E5 11 00 F0    	LD	DE,VOCAB_BASE	   ; Where it's going
2873   12E8 01 0B 00    	LD	BC,W_TASKEND-W_TASK;Bytes to copy
2874   12EB ED B0       	LDIR				   ;
2875   12ED 01 F7 12    	LD	BC,FIRSTWORD	   ;BC to first forth word
2876   12F0 2A 58 01    	LD	HL,(WORD1)		;Get stack pointer
2877   12F3 F9          	LD	SP,HL			;Set it
2878   12F4 C3 9E 01    	JP	NEXT
2879   12F7             
2880   12F7             FIRSTWORD:
2881   12F7 02 13       	.WORD	C_COLD
2882   12F9             
2883   12F9             W_COLD:
2884   12F9 84434F4CC4  	.BYTE	84h,"COL",'D'+80h
2885   12FE BE 12       	.WORD	W_WARM
2886   1300 D7 12       	.WORD	X_COLD
2887   1302             C_COLD:
2888   1302 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2889   1304 30 15       	.WORD	C_EBUFFERS		;Clear pseudo disk buffer
2890   1306 2B 07       	.WORD	C_ZERO			;Put zero on stack
2891   1308 29 08       	.WORD	C_OFFSET		;Put disk block offset on stack
2892   130A 71 06       	.WORD	C_STORE			;Clear disk block offset
2893   130C C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2894   130E 58 01       	.WORD	WORD1			;Start of default table
2895   1310 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2896   1312 06 FE       	.WORD	S0			;S0 addr
2897   1314 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2898   1316 10 00       	.WORD	START_TABLE-WORD1	;Block length on stack (0010h)
2899   1318 A6 03       	.WORD	C_CMOVE			;Move block
2900   131A 94 12       	.WORD	C_ABORT
2901   131C             
2902   131C             W_SINGTODUB:				;Change single number to double
2903   131C 84532D3EC4  	.BYTE	84h,"S->",'D'+80h
2904   1321 F9 12       	.WORD	W_COLD
2905   1323             C_SINGTODUB:
2906   1323 25 13       	.WORD	2+$			;Vector to code
2907   1325 D1          	POP	DE			;Get number
2908   1326 21 00 00    	LD	HL,0000h		;Assume +ve extend
2909   1329 7A          	LD	A,D			;Check sign
2910   132A E6 80       	AND	80h			;
2911   132C 28 01       	JR	Z,IS_POS		;Really +ve so jump
2912   132E 2B          	DEC	HL			;Make -ve extension
2913   132F             IS_POS:
2914   132F C3 9C 01    	JP	NEXTS2			;Save both & NEXT
2915   1332             
2916   1332             W_PLUSMINUS:
2917   1332 82 2B AD    	.BYTE	82h,'+','-'+80h
2918   1335 1C 13       	.WORD	W_SINGTODUB
2919   1337             C_PLUSMINUS:
2920   1337 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2921   1339 3A 05       	.WORD	C_0LESS			;Less than 0
2922   133B 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2923   133D 04 00       	.WORD	B002D-$			;0004h
2924   133F 7B 05       	.WORD	C_NEGATE		;Form 2s complement of n
2925   1341             B002D:
2926   1341 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2927   1343             
2928   1343             W_DPLUSMINUS:				;Add sign of n to double
2929   1343 83 44 2B AD 	.BYTE	83h,"D+",'-'+80h
2930   1347 32 13       	.WORD	W_PLUSMINUS
2931   1349             C_DPLUSMINUS:
2932   1349 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2933   134B 3A 05       	.WORD	C_0LESS			;Less than 0
2934   134D 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2935   134F 04 00       	.WORD	B002E-$			;0004h
2936   1351 92 05       	.WORD	C_DNEGATE
2937   1353             B002E:
2938   1353 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2939   1355             
2940   1355             W_ABS:
2941   1355 83 41 42 D3 	.BYTE	83h,"AB",'S'+80h
2942   1359 43 13       	.WORD	W_DPLUSMINUS
2943   135B             C_ABS:
2944   135B B4 06       	.WORD	E_COLON			;Interpret following word sequence
2945   135D E7 05       	.WORD	C_DUP			;Duplicate top value on stack
2946   135F 37 13       	.WORD	C_PLUSMINUS
2947   1361 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2948   1363             
2949   1363             W_DABS:
2950   1363 84444142D3  	.BYTE	84h,"DAB",'S'+80h
2951   1368 55 13       	.WORD	W_ABS
2952   136A             C_DABS:
2953   136A B4 06       	.WORD	E_COLON			;Interpret following word sequence
2954   136C E7 05       	.WORD	C_DUP			;Duplicate top value on stack
2955   136E 49 13       	.WORD	C_DPLUSMINUS		;Add sign of n to double
2956   1370 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2957   1372             
2958   1372             W_MIN:
2959   1372 83 4D 49 CE 	.BYTE	83h,"MI",'N'+80h
2960   1376 63 13       	.WORD	W_DABS
2961   1378             C_MIN:
2962   1378 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2963   137A F5 05       	.WORD	C_2DUP			;Dup top 2 values on stack
2964   137C EF 0A       	.WORD	C_GREATER
2965   137E 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2966   1380 04 00       	.WORD	B002F-$			;0004h
2967   1382 DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
2968   1384             B002F:
2969   1384 BE 05       	.WORD	C_DROP			;Drop top value from stack
2970   1386 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2971   1388             
2972   1388             W_MAX:
2973   1388 83 4D 41 D8 	.BYTE	83h,"MA",'X'+80h
2974   138C 72 13       	.WORD	W_MIN
2975   138E             C_MAX:
2976   138E B4 06       	.WORD	E_COLON			;Interpret following word sequence
2977   1390 F5 05       	.WORD	C_2DUP			;Dup top 2 values on stack
2978   1392 AD 0A       	.WORD	C_LESSTHAN
2979   1394 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2980   1396 04 00       	.WORD	B0030-$			;0004h
2981   1398 DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
2982   139A             B0030:
2983   139A BE 05       	.WORD	C_DROP			;Drop top value from stack
2984   139C C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
2985   139E             
2986   139E             W_MTIMES:
2987   139E 82 4D AA    	.BYTE	82h,'M','*'+80h
2988   13A1 88 13       	.WORD	W_MAX
2989   13A3             C_MTIMES:
2990   13A3 B4 06       	.WORD	E_COLON			;Interpret following word sequence
2991   13A5 F5 05       	.WORD	C_2DUP			;Dup top 2 values on stack
2992   13A7 63 04       	.WORD	C_XOR			;Works out sign of result
2993   13A9 ED 04       	.WORD	C_MOVER			;Move value from data to return stack
2994   13AB 5B 13       	.WORD	C_ABS
2995   13AD DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
2996   13AF 5B 13       	.WORD	C_ABS
2997   13B1 BC 03       	.WORD	C_USTAR
2998   13B3 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
2999   13B5 49 13       	.WORD	C_DPLUSMINUS		;Add sign of n to double
3000   13B7 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3001   13B9             
3002   13B9             W_MDIV:
3003   13B9 82 4D AF    	.BYTE	82h,'M','/'+80h
3004   13BC 9E 13       	.WORD	W_MTIMES
3005   13BE             C_MDIV:
3006   13BE B4 06       	.WORD	E_COLON			;Interpret following word sequence
3007   13C0 AF 05       	.WORD	C_OVER			;Copy 2nd down to top of stack
3008   13C2 ED 04       	.WORD	C_MOVER			;Move value from data to return stack
3009   13C4 ED 04       	.WORD	C_MOVER			;Move value from data to return stack
3010   13C6 6A 13       	.WORD	C_DABS
3011   13C8 18 05       	.WORD	C_RFETCH		;Return stack top to data stack
3012   13CA 5B 13       	.WORD	C_ABS
3013   13CC F1 03       	.WORD	C_UMOD			;Unsigned divide & MOD
3014   13CE 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
3015   13D0 18 05       	.WORD	C_RFETCH		;Return stack top to data stack
3016   13D2 63 04       	.WORD	C_XOR			;XOR
3017   13D4 37 13       	.WORD	C_PLUSMINUS
3018   13D6 DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
3019   13D8 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
3020   13DA 37 13       	.WORD	C_PLUSMINUS
3021   13DC DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
3022   13DE C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3023   13E0             
3024   13E0             W_TIMES:
3025   13E0 81 AA       	.BYTE	81h,'*'+80h
3026   13E2 B9 13       	.WORD	W_MDIV
3027   13E4             C_TIMES:
3028   13E4 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3029   13E6 A3 13       	.WORD	C_MTIMES
3030   13E8 BE 05       	.WORD	C_DROP			;Drop top value from stack
3031   13EA C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3032   13EC             
3033   13EC             W_DIVMOD:
3034   13EC 842F4D4FC4  	.BYTE	84h,"/MO",'D'+80h
3035   13F1 E0 13       	.WORD	W_TIMES
3036   13F3             C_DIVMOD:
3037   13F3 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3038   13F5 ED 04       	.WORD	C_MOVER			;Move value from data to return stack
3039   13F7 23 13       	.WORD	C_SINGTODUB		;Change single number to double
3040   13F9 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
3041   13FB BE 13       	.WORD	C_MDIV
3042   13FD C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3043   13FF             
3044   13FF             W_DIV:
3045   13FF 81 AF       	.BYTE	81h,'/'+80h
3046   1401 EC 13       	.WORD	W_DIVMOD
3047   1403             C_DIV:
3048   1403 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3049   1405 F3 13       	.WORD	C_DIVMOD
3050   1407 DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
3051   1409 BE 05       	.WORD	C_DROP			;Drop top value from stack
3052   140B C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3053   140D             
3054   140D             W_MOD:
3055   140D 83 4D 4F C4 	.BYTE	83h,"MO",'D'+80h
3056   1411 FF 13       	.WORD	W_DIV
3057   1413             C_MOD:
3058   1413 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3059   1415 F3 13       	.WORD	C_DIVMOD
3060   1417 BE 05       	.WORD	C_DROP			;Drop top value from stack
3061   1419 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3062   141B             
3063   141B             W_TIMESDIVMOD:
3064   141B 852A2F4D4FC4	.BYTE	85h,"*/MO",'D'+80h
3065   1421 0D 14       	.WORD	W_MOD
3066   1423             C_TIMESDIVMOD:
3067   1423 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3068   1425 ED 04       	.WORD	C_MOVER			;Move value from data to return stack
3069   1427 A3 13       	.WORD	C_MTIMES
3070   1429 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
3071   142B BE 13       	.WORD	C_MDIV
3072   142D C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3073   142F             
3074   142F             W_TIMESDIV:
3075   142F 82 2A AF    	.BYTE	82h,'*','/'+80h
3076   1432 1B 14       	.WORD	W_TIMESDIVMOD
3077   1434             C_TIMESDIV:
3078   1434 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3079   1436 23 14       	.WORD	C_TIMESDIVMOD
3080   1438 DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
3081   143A BE 05       	.WORD	C_DROP			;Drop top value from stack
3082   143C C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3083   143E             
3084   143E             W_MDIVMOD:
3085   143E 854D2F4D4FC4	.BYTE	85h,"M/MO",'D'+80h
3086   1444 2F 14       	.WORD	W_TIMESDIV
3087   1446             C_MDIVMOD:
3088   1446 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3089   1448 ED 04       	.WORD	C_MOVER			;Move value from data to return stack
3090   144A 2B 07       	.WORD	C_ZERO			;Put zero on stack
3091   144C 18 05       	.WORD	C_RFETCH		;Return stack top to data stack
3092   144E F1 03       	.WORD	C_UMOD			;Unsigned divide & MOD
3093   1450 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
3094   1452 DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
3095   1454 ED 04       	.WORD	C_MOVER			;Move value from data to return stack
3096   1456 F1 03       	.WORD	C_UMOD			;Unsigned divide & MOD
3097   1458 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
3098   145A C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3099   145C             
3100   145C             W_CLINE:
3101   145C 863C4C494E45	.BYTE	86h,"<LINE",'>'+80h
3101   1462 BE
3102   1463 3E 14       	.WORD	W_MDIVMOD
3103   1465             C_CLINE:
3104   1465 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3105   1467 ED 04       	.WORD	C_MOVER			;Move value from data to return stack
3106   1469 56 07       	.WORD	C_CL			;Put characters/line on stack
3107   146B 86 07       	.WORD	C_BBUF			;Put bytes per block on stack
3108   146D 23 14       	.WORD	C_TIMESDIVMOD
3109   146F 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
3110   1471 96 07       	.WORD	C_BSCR			;Number of buffers per block on stack
3111   1473 E4 13       	.WORD	C_TIMES
3112   1475 4B 05       	.WORD	C_PLUS			;n1 + n2
3113   1477 55 15       	.WORD	C_BLOCK
3114   1479 4B 05       	.WORD	C_PLUS			;n1 + n2
3115   147B 56 07       	.WORD	C_CL			;Put characters/line on stack
3116   147D C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3117   147F             
3118   147F             W_DOTLINE:
3119   147F 852E4C494EC5	.BYTE	85h,".LIN",'E'+80h
3120   1485 5C 14       	.WORD	W_CLINE
3121   1487             C_DOTLINE:
3122   1487 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3123   1489 65 14       	.WORD	C_CLINE
3124   148B 88 0D       	.WORD	C_TRAILING
3125   148D 5A 0D       	.WORD	C_TYPE			;Output n bytes from addr
3126   148F C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3127   1491             
3128   1491             W_MESSAGE:
3129   1491 874D45535341	.BYTE	87h,"MESSAG",'E'+80h
3129   1497 47C5
3130   1499 7F 14       	.WORD	W_DOTLINE
3131   149B             C_MESSAGE:
3132   149B B4 06       	.WORD	E_COLON			;Interpret following word sequence
3133   149D D0 07       	.WORD	C_WARNING		;Put WARNING addr on stack
3134   149F 3A 06       	.WORD	C_FETCH			;Get WARNING value
3135   14A1 00 02       	.WORD	C_0BRANCH		;If WARNING = 0 output MSG # n
3136   14A3 1E 00       	.WORD	B0031-$			;001Eh
3137   14A5 31 0B       	.WORD	C_QUERYDUP
3138   14A7 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3139   14A9 14 00       	.WORD	B0032-$			;0014h
3140   14AB C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3141   14AD 04 00       	.WORD	0004h
3142   14AF 29 08       	.WORD	C_OFFSET		;Put disk block offset on stack
3143   14B1 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
3144   14B3 96 07       	.WORD	C_BSCR			;Number of buffers per block on stack
3145   14B5 03 14       	.WORD	C_DIV
3146   14B7 8C 0A       	.WORD	C_MINUS
3147   14B9 87 14       	.WORD	C_DOTLINE		;Output line from screen
3148   14BB 22 0B       	.WORD	C_SPACE			;Output space
3149   14BD             B0032:
3150   14BD E8 01       	.WORD	C_BRANCH		;Add following offset to BC
3151   14BF 0D 00       	.WORD	B0033-$			;000Dh
3152   14C1             B0031:
3153   14C1 BB 0D       	.WORD	C_CQUOTE		;Output following string
3154   14C3 06          		.BYTE	S_END2-S_START2
3155   14C4             S_START2:
3156   14C4 4D5347202320	.BYTE	"MSG # "
3157   14CA             S_END2:
3158   14CA 88 18       	.WORD	C_DOT
3159   14CC             B0033:
3160   14CC C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3161   14CE             
3162   14CE             W_PORTIN:				;Fetch data from port
3163   14CE 82 50 C0    	.BYTE	82h,'P','@'+80h
3164   14D1 91 14       	.WORD	W_MESSAGE
3165   14D3             C_PORTIN:
3166   14D3 D5 14       	.WORD	2+$			;Vector to code
3167   14D5 D1          	POP	DE			;Get port addr
3168   14D6 21 41 FE    	LD	HL,PAT+1		;Save in port in code
3169   14D9 73          	LD	(HL),E			;
3170   14DA CD 40 FE    	CALL	PAT			;Call port in routine
3171   14DD 6F          	LD	L,A			;Save result
3172   14DE 26 00       	LD	H,00h			;
3173   14E0 C3 9D 01    	JP	NEXTS1			;Save & NEXT
3174   14E3             
3175   14E3             W_PORTOUT:				;Save data to port
3176   14E3 82 50 A1    	.BYTE	82h,'P','!'+80h
3177   14E6 CE 14       	.WORD	W_PORTIN
3178   14E8             C_PORTOUT:
3179   14E8 EA 14       	.WORD	2+$			;Vector to code
3180   14EA D1          	POP	DE			;Get port addr
3181   14EB 21 44 FE    	LD	HL,PST+1		;Save in port out code
3182   14EE 73          	LD	(HL),E			;
3183   14EF E1          	POP	HL			;
3184   14F0 7D          	LD	A,L			;Byte to A
3185   14F1 CD 43 FE    	CALL	PST			;Call port out routine
3186   14F4 C3 9E 01    	JP	NEXT
3187   14F7             
3188   14F7             W_USE:
3189   14F7 83 55 53 C5 	.BYTE	83h,"US",'E'+80h
3190   14FB E3 14       	.WORD	W_PORTOUT
3191   14FD             C_USE:
3192   14FD 1B 07       	.WORD	X_USER			;Put next word on stack then do next
3193   14FF 48 00       	.WORD	USE-SYSTEM
3194   1501             
3195   1501             W_PREV:
3196   1501 84505245D6  	.BYTE	84h,"PRE",'V'+80h
3197   1506 F7 14       	.WORD	W_USE
3198   1508             C_PREV:
3199   1508 1B 07       	.WORD	X_USER			;Put next word on stack then do next
3200   150A 4A 00       	.WORD	PREV-SYSTEM
3201   150C             
3202   150C             W_PLUSBUF:
3203   150C 842B4255C6  	.BYTE	84h,"+BU",'F'+80h
3204   1511 01 15       	.WORD	W_PREV
3205   1513             C_PLUSBUF:
3206   1513 9E 01       	.WORD	NEXT
3207   1515             
3208   1515             W_UPDATE:
3209   1515 865550444154	.BYTE	86h,"UPDAT",'E'+80h
3209   151B C5
3210   151C 0C 15       	.WORD	W_PLUSBUF
3211   151E             C_UPDATE:
3212   151E 9E 01       	.WORD	NEXT
3213   1520             
3214   1520             W_EBUFFERS:				;Clear pseudo disk buffer
3215   1520 8D454D505459	.BYTE	8Dh,"EMPTY-BUFFER",'S'+80h
3215   1526 2D425546464552D3
3216   152E 15 15       	.WORD	W_UPDATE
3217   1530             C_EBUFFERS:
3218   1530 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3219   1532 66 07       	.WORD	C_FIRST			;Start of pseudo disk onto stack
3220   1534 76 07       	.WORD	C_LIMIT			;End of pseudo disk onto stack
3221   1536 AF 05       	.WORD	C_OVER			;Start to top of stack
3222   1538 8C 0A       	.WORD	C_MINUS			;Work out buffer length
3223   153A F2 0E       	.WORD	C_ERASE			;Fill addr & length from stack with 0
3224   153C C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3225   153E             
3226   153E             W_BUFFER:
3227   153E 864255464645	.BYTE	86h,"BUFFE",'R'+80h
3227   1544 D2
3228   1545 20 15       	.WORD	W_EBUFFERS
3229   1547             C_BUFFER:
3230   1547 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3231   1549 55 15       	.WORD	C_BLOCK
3232   154B C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3233   154D             
3234   154D             W_BLOCK:				;Put address of block n (+ offset) on stack
3235   154D 85424C4F43CB	.BYTE	85h,"BLOC",'K'+80h
3236   1553 3E 15       	.WORD	W_BUFFER
3237   1555             C_BLOCK:
3238   1555 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3239   1557 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3240   1559 B1 FF       	.WORD	DISK_END/BLOCK_SIZE-DISK_START/BLOCK_SIZE
3241   155B             					;Max number of blocks
3242   155B 13 14       	.WORD	C_MOD			;MOD to max number
3243   155D 29 08       	.WORD	C_OFFSET		;Put address of disk block offset on stack
3244   155F 3A 06       	.WORD	C_FETCH			;Get disk block offset
3245   1561 4B 05       	.WORD	C_PLUS			;Add offset to block #
3246   1563 86 07       	.WORD	C_BBUF			;Put bytes per block on stack
3247   1565 E4 13       	.WORD	C_TIMES			;Bytes times block number
3248   1567 66 07       	.WORD	C_FIRST			;Put address of first block on stack
3249   1569 4B 05       	.WORD	C_PLUS			;Add address of first to byte offset
3250   156B C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3251   156D             
3252   156D             W_RW:
3253   156D 83 52 2F D7 	.BYTE	83h,"R/",'W'+80h
3254   1571 4D 15       	.WORD	W_BLOCK
3255   1573             C_RW:
3256   1573 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3257   1575 09 09       	.WORD	C_URW			;
3258   1577 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
3259   1579 D9 01       	.WORD	C_EXECUTE		;Jump to address on stack
3260   157B C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3261   157D             CF_URW:
3262   157D B4 06       	.WORD	E_COLON			;Interpret following word sequence
3263   157F BE 05       	.WORD	C_DROP			;Drop top value from stack
3264   1581 BE 05       	.WORD	C_DROP			;Drop top value from stack
3265   1583 BE 05       	.WORD	C_DROP			;Drop top value from stack
3266   1585 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3267   1587             
3268   1587             W_FLUSH:
3269   1587 85464C5553C8	.BYTE	85h,"FLUS",'H'+80h
3270   158D 6D 15       	.WORD	W_RW
3271   158F             C_FLUSH:
3272   158F B4 06       	.WORD	E_COLON			;Interpret following word sequence
3273   1591 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3274   1593             
3275   1593             W_DUMP:
3276   1593 8444554DD0  	.BYTE	84h,"DUM",'P'+80h
3277   1598 87 15       	.WORD	W_FLUSH
3278   159A             C_DUMP:
3279   159A B4 06       	.WORD	E_COLON			;Interpret following word sequence
3280   159C 2B 07       	.WORD	C_ZERO			;Put zero on stack
3281   159E 5A 02       	.WORD	C_LDO			;Put start & end loop values on RPP
3282   15A0             B0051:
3283   15A0 84 03       	.WORD	C_CR			;Output [CR][LF]
3284   15A2 E7 05       	.WORD	C_DUP			;Duplicate top value on stack
3285   15A4 2B 07       	.WORD	C_ZERO			;Put zero on stack
3286   15A6 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3287   15A8 05 00       	.WORD	0005h
3288   15AA 46 18       	.WORD	C_DDOTR
3289   15AC 22 0B       	.WORD	C_SPACE			;Output space
3290   15AE C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3291   15B0 04 00       	.WORD	0004h
3292   15B2 DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
3293   15B4 AF 05       	.WORD	C_OVER			;Copy 2nd down to top of stack
3294   15B6 2B 07       	.WORD	C_ZERO			;Put zero on stack
3295   15B8 5A 02       	.WORD	C_LDO			;Put start & end loop values on RPP
3296   15BA             B0050:
3297   15BA E7 05       	.WORD	C_DUP			;Duplicate top value on stack
3298   15BC 49 06       	.WORD	C_CFETCH		;Get byte from addr on stack
3299   15BE 43 07       	.WORD	C_3
3300   15C0 69 18       	.WORD	C_DOTR
3301   15C2 1B 0A       	.WORD	C_1PLUS			;1 plus
3302   15C4 15 02       	.WORD	C_LLOOP			;Increment loop & branch if not done
3303   15C6 F4 FF       	.WORD	B0050-$			;FFF4h
3304   15C8 DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
3305   15CA 4E 02       	.WORD	C_PLOOP			;Loop + stack & branch if not done
3306   15CC D4 FF       	.WORD	B0051-$			;FFD4h
3307   15CE BE 05       	.WORD	C_DROP			;Drop top value from stack
3308   15D0 84 03       	.WORD	C_CR			;Output [CR][LF]
3309   15D2 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3310   15D4             
3311   15D4             W_LOAD:
3312   15D4 844C4F41C4  	.BYTE	84h,"LOA",'D'+80h
3313   15D9 93 15       	.WORD	W_DUMP
3314   15DB             C_LOAD:
3315   15DB B4 06       	.WORD	E_COLON			;Interpret following word sequence
3316   15DD FE 07       	.WORD	C_BLK			;Get current block number (0 = keyboard)
3317   15DF 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
3318   15E1 ED 04       	.WORD	C_MOVER			;Save it for now
3319   15E3 08 08       	.WORD	C_TOIN			;Current input buffer offset
3320   15E5 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
3321   15E7 ED 04       	.WORD	C_MOVER			;Save it for now
3322   15E9 2B 07       	.WORD	C_ZERO			;Put zero on stack
3323   15EB 08 08       	.WORD	C_TOIN			;Current input buffer offset
3324   15ED 71 06       	.WORD	C_STORE			;Set to zero
3325   15EF 96 07       	.WORD	C_BSCR			;Number of buffers per block on stack
3326   15F1 E4 13       	.WORD	C_TIMES			;Multiply block to load by buffers/block
3327   15F3 FE 07       	.WORD	C_BLK			;Get BLK pointer
3328   15F5 71 06       	.WORD	C_STORE			;Make load block current input stream
3329   15F7 8B 11       	.WORD	C_INTERPRET		;Interpret input stream
3330   15F9 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
3331   15FB 08 08       	.WORD	C_TOIN			;Current input buffer offset
3332   15FD 71 06       	.WORD	C_STORE			;Store word at addr
3333   15FF 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
3334   1601 FE 07       	.WORD	C_BLK			;Current block
3335   1603 71 06       	.WORD	C_STORE			;Store word at addr
3336   1605 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3337   1607             
3338   1607             W_NEXTSCREEN:
3339   1607 C3 2D 2D BE 	.BYTE	0C3h,"--",'>'+80h
3340   160B D4 15       	.WORD	W_LOAD
3341   160D             C_NEXTSCREEN:
3342   160D B4 06       	.WORD	E_COLON			;Interpret following word sequence
3343   160F 52 0C       	.WORD	C_QLOADING
3344   1611 2B 07       	.WORD	C_ZERO			;Put zero on stack
3345   1613 08 08       	.WORD	C_TOIN			;Current input buffer offset
3346   1615 71 06       	.WORD	C_STORE			;Store word at addr
3347   1617 96 07       	.WORD	C_BSCR			;Number of buffers per block on stack
3348   1619 FE 07       	.WORD	C_BLK
3349   161B 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
3350   161D AF 05       	.WORD	C_OVER			;Copy 2nd down to top of stack
3351   161F 13 14       	.WORD	C_MOD
3352   1621 8C 0A       	.WORD	C_MINUS
3353   1623 FE 07       	.WORD	C_BLK
3354   1625 15 06       	.WORD	C_PLUSSTORE		;Add n1 to addr
3355   1627 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3356   1629             
3357   1629             W_TICK:
3358   1629 81 AC       	.BYTE	81h,2Ch+80h
3359   162B 07 16       	.WORD	W_NEXTSCREEN
3360   162D             C_TICK:
3361   162D B4 06       	.WORD	E_COLON			;Interpret following word sequence
3362   162F 32 10       	.WORD	C_MFIND			;Find name returns PFA,length,true or false
3363   1631 1F 05       	.WORD	C_0EQUALS		;=0
3364   1633 2B 07       	.WORD	C_ZERO			;Put zero on stack
3365   1635 D9 0B       	.WORD	C_QERROR
3366   1637 BE 05       	.WORD	C_DROP			;Drop top value from stack
3367   1639 23 11       	.WORD	C_LITERAL
3368   163B C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3369   163D             
3370   163D             W_FORGET:
3371   163D 86464F524745	.BYTE	86h,"FORGE",'T'+80h
3371   1643 D4
3372   1644 29 16       	.WORD	W_TICK
3373   1646             C_FORGET:
3374   1646 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3375   1648 45 08       	.WORD	C_CURRENT
3376   164A 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
3377   164C 37 08       	.WORD	C_CONTEXT
3378   164E 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
3379   1650 8C 0A       	.WORD	C_MINUS
3380   1652 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3381   1654 18 00       	.WORD	0018h
3382   1656 D9 0B       	.WORD	C_QERROR
3383   1658 2D 16       	.WORD	C_TICK
3384   165A E7 05       	.WORD	C_DUP			;Duplicate top value on stack
3385   165C DC 07       	.WORD	C_FENCE
3386   165E 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
3387   1660 AD 0A       	.WORD	C_LESSTHAN
3388   1662 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3389   1664 15 00       	.WORD	0015h
3390   1666 D9 0B       	.WORD	C_QERROR
3391   1668 E7 05       	.WORD	C_DUP			;Duplicate top value on stack
3392   166A 9B 0B       	.WORD	C_NFA			;Convert PFA to NFA
3393   166C E5 07       	.WORD	C_DP			;Dictionary pointer addr on stack
3394   166E 71 06       	.WORD	C_STORE			;Store word at addr
3395   1670 7D 0B       	.WORD	C_LFA
3396   1672 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
3397   1674 37 08       	.WORD	C_CONTEXT
3398   1676 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
3399   1678 71 06       	.WORD	C_STORE			;Store word at addr
3400   167A C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3401   167C             
3402   167C             W_BACK:
3403   167C 84424143CB  	.BYTE	84h,"BAC",'K'+80h
3404   1681 3D 16       	.WORD	W_FORGET
3405   1683             C_BACK:
3406   1683 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3407   1685 4F 0A       	.WORD	C_HERE			;Dictionary pointer onto stack
3408   1687 8C 0A       	.WORD	C_MINUS
3409   1689 6B 0A       	.WORD	C_COMMA			;Reserve 2 bytes and save n
3410   168B C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3411   168D             
3412   168D             W_BEGIN:
3413   168D C542454749CE	.BYTE	0C5h,"BEGI",'N'+80h
3414   1693 7C 16       	.WORD	W_BACK
3415   1695             C_BEGIN:
3416   1695 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3417   1697 F3 0B       	.WORD	C_QCOMP			;Error if not in compile mode
3418   1699 4F 0A       	.WORD	C_HERE			;Dictionary pointer onto stack
3419   169B 33 07       	.WORD	C_1			;Put 1 on stack
3420   169D C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3421   169F             
3422   169F             W_ENDIF:
3423   169F C5454E4449C6	.BYTE	0C5h,"ENDI",'F'+80h
3424   16A5 8D 16       	.WORD	W_BEGIN
3425   16A7             C_ENDIF:
3426   16A7 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3427   16A9 F3 0B       	.WORD	C_QCOMP			;Error if not in compile mode
3428   16AB 3B 07       	.WORD	C_2
3429   16AD 22 0C       	.WORD	C_QPAIRS
3430   16AF 4F 0A       	.WORD	C_HERE			;Dictionary pointer onto stack
3431   16B1 AF 05       	.WORD	C_OVER			;Copy 2nd down to top of stack
3432   16B3 8C 0A       	.WORD	C_MINUS
3433   16B5 DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
3434   16B7 71 06       	.WORD	C_STORE			;Store word at addr
3435   16B9 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3436   16BB             
3437   16BB             W_THEN:
3438   16BB C4544845CE  	.BYTE	0C4h,"THE",'N'+80h
3439   16C0 9F 16       	.WORD	W_ENDIF
3440   16C2             C_THEN:
3441   16C2 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3442   16C4 A7 16       	.WORD	C_ENDIF
3443   16C6 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3444   16C8             
3445   16C8             W_DO:
3446   16C8 C2 44 CF    	.BYTE	0C2h,'D','O'+80h
3447   16CB BB 16       	.WORD	W_THEN
3448   16CD             C_DO:
3449   16CD B4 06       	.WORD	E_COLON			;Interpret following word sequence
3450   16CF 6C 0C       	.WORD	C_COMPILE		;Compile next word into dictionary
3451   16D1 5A 02       	.WORD	C_LDO			;Put start & end loop values on RPP
3452   16D3 4F 0A       	.WORD	C_HERE			;Dictionary pointer onto stack
3453   16D5 43 07       	.WORD	C_3
3454   16D7 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3455   16D9             
3456   16D9             W_LOOP:
3457   16D9 C44C4F4FD0  	.BYTE	0C4h,"LOO",'P'+80h
3458   16DE C8 16       	.WORD	W_DO
3459   16E0             C_LOOP:
3460   16E0 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3461   16E2 43 07       	.WORD	C_3
3462   16E4 22 0C       	.WORD	C_QPAIRS
3463   16E6 6C 0C       	.WORD	C_COMPILE		;Compile next word into dictionary
3464   16E8 15 02       	.WORD	C_LLOOP			;Increment loop & branch if not done
3465   16EA 83 16       	.WORD	C_BACK
3466   16EC C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3467   16EE             
3468   16EE             W_PLUSLOOP:
3469   16EE C52B4C4F4FD0	.BYTE	0C5h,"+LOO",'P'+80h
3470   16F4 D9 16       	.WORD	W_LOOP
3471   16F6             C_PLUSLOOP:
3472   16F6 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3473   16F8 43 07       	.WORD	C_3
3474   16FA 22 0C       	.WORD	C_QPAIRS
3475   16FC 6C 0C       	.WORD	C_COMPILE		;Compile next word into dictionary
3476   16FE 4E 02       	.WORD	C_PLOOP			;Loop + stack & branch if not done
3477   1700 83 16       	.WORD	C_BACK
3478   1702 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3479   1704             
3480   1704             W_UNTIL:
3481   1704 C5554E5449CC	.BYTE	0C5h,"UNTI",'L'+80h
3482   170A EE 16       	.WORD	W_PLUSLOOP
3483   170C             C_UNTIL:
3484   170C B4 06       	.WORD	E_COLON			;Interpret following word sequence
3485   170E 33 07       	.WORD	C_1			;Put 1 on stack
3486   1710 22 0C       	.WORD	C_QPAIRS
3487   1712 6C 0C       	.WORD	C_COMPILE		;Compile next word into dictionary
3488   1714 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3489   1716 83 16       	.WORD	C_BACK
3490   1718 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3491   171A             
3492   171A             W_END:
3493   171A C3 45 4E C4 	.BYTE	0C3h,"EN",'D'+80h
3494   171E 04 17       	.WORD	W_UNTIL
3495   1720             C_END:
3496   1720 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3497   1722 0C 17       	.WORD	C_UNTIL
3498   1724 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3499   1726             
3500   1726             W_AGAIN:
3501   1726 C541474149CE	.BYTE	0C5h,"AGAI",'N'+80h
3502   172C 1A 17       	.WORD	W_END
3503   172E             C_AGAIN:
3504   172E B4 06       	.WORD	E_COLON			;Interpret following word sequence
3505   1730 33 07       	.WORD	C_1			;Put 1 on stack
3506   1732 22 0C       	.WORD	C_QPAIRS
3507   1734 6C 0C       	.WORD	C_COMPILE		;Compile next word into dictionary
3508   1736 E8 01       	.WORD	C_BRANCH		;Add following offset to BC
3509   1738 83 16       	.WORD	C_BACK
3510   173A C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3511   173C             
3512   173C             W_REPEAT:
3513   173C C65245504541	.BYTE	0C6h,"REPEA",'T'+80h
3513   1742 D4
3514   1743 26 17       	.WORD	W_AGAIN
3515   1745             C_REPEAT:
3516   1745 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3517   1747 ED 04       	.WORD	C_MOVER			;Move value from data to return stack
3518   1749 ED 04       	.WORD	C_MOVER			;Move value from data to return stack
3519   174B 2E 17       	.WORD	C_AGAIN
3520   174D 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
3521   174F 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
3522   1751 3B 07       	.WORD	C_2
3523   1753 8C 0A       	.WORD	C_MINUS
3524   1755 A7 16       	.WORD	C_ENDIF
3525   1757 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3526   1759             
3527   1759             W_IF:
3528   1759 C2 49 C6    	.BYTE	0C2h,'I','F'+80h
3529   175C 3C 17       	.WORD	W_REPEAT
3530   175E             C_IF:
3531   175E B4 06       	.WORD	E_COLON			;Interpret following word sequence
3532   1760 6C 0C       	.WORD	C_COMPILE		;Compile next word into dictionary
3533   1762 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3534   1764 4F 0A       	.WORD	C_HERE			;Dictionary pointer onto stack
3535   1766 2B 07       	.WORD	C_ZERO			;Put zero on stack
3536   1768 6B 0A       	.WORD	C_COMMA			;Reserve 2 bytes and save n
3537   176A 3B 07       	.WORD	C_2
3538   176C C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3539   176E             
3540   176E             W_ELSE:
3541   176E C4454C53C5  	.BYTE	0C4h,"ELS",'E'+80h
3542   1773 59 17       	.WORD	W_IF
3543   1775             C_ELSE:
3544   1775 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3545   1777 3B 07       	.WORD	C_2
3546   1779 22 0C       	.WORD	C_QPAIRS
3547   177B 6C 0C       	.WORD	C_COMPILE		;Compile next word into dictionary
3548   177D E8 01       	.WORD	C_BRANCH		;Add following offset to BC
3549   177F 4F 0A       	.WORD	C_HERE			;Dictionary pointer onto stack
3550   1781 2B 07       	.WORD	C_ZERO			;Put zero on stack
3551   1783 6B 0A       	.WORD	C_COMMA			;Reserve 2 bytes and save n
3552   1785 DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
3553   1787 3B 07       	.WORD	C_2
3554   1789 A7 16       	.WORD	C_ENDIF
3555   178B 3B 07       	.WORD	C_2
3556   178D C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3557   178F             
3558   178F             W_WHILE:
3559   178F C55748494CC5	.BYTE	0C5h,"WHIL",'E'+80h
3560   1795 6E 17       	.WORD	W_ELSE
3561   1797             C_WHILE:
3562   1797 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3563   1799 5E 17       	.WORD	C_IF
3564   179B 27 0A       	.WORD	C_2PLUS			;2 plus
3565   179D C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3566   179F             
3567   179F             W_SPACES:
3568   179F 865350414345	.BYTE	86h,"SPACE",'S'+80h
3568   17A5 D3
3569   17A6 8F 17       	.WORD	W_WHILE
3570   17A8             C_SPACES:
3571   17A8 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3572   17AA 2B 07       	.WORD	C_ZERO			;Put zero on stack
3573   17AC 8E 13       	.WORD	C_MAX
3574   17AE 31 0B       	.WORD	C_QUERYDUP
3575   17B0 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3576   17B2 0C 00       	.WORD	B0034-$			;000Ch
3577   17B4 2B 07       	.WORD	C_ZERO			;Put zero on stack
3578   17B6 5A 02       	.WORD	C_LDO			;Put start & end loop values on RPP
3579   17B8             B0035:
3580   17B8 22 0B       	.WORD	C_SPACE			;Output space
3581   17BA 15 02       	.WORD	C_LLOOP			;Increment loop & branch if not done
3582   17BC FC FF       	.WORD	B0035-$			;FFFCh
3583   17BE             B0034:
3584   17BE C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3585   17C0             
3586   17C0             W_LESSHARP:
3587   17C0 82 3C A3    	.BYTE	82h,'<','#'+80h
3588   17C3 9F 17       	.WORD	W_SPACES
3589   17C5             C_LESSHARP:
3590   17C5 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3591   17C7 2A 0F       	.WORD	C_PAD			;Save intermediate string address
3592   17C9 8D 08       	.WORD	C_HLD
3593   17CB 71 06       	.WORD	C_STORE			;Store word at addr
3594   17CD C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3595   17CF             
3596   17CF             W_SHARPGT:
3597   17CF 82 23 BE    	.BYTE	82h,'#','>'+80h
3598   17D2 C0 17       	.WORD	W_LESSHARP
3599   17D4             C_SHARPGT:
3600   17D4 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3601   17D6 BE 05       	.WORD	C_DROP			;Drop top value from stack
3602   17D8 BE 05       	.WORD	C_DROP			;Drop top value from stack
3603   17DA 8D 08       	.WORD	C_HLD
3604   17DC 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
3605   17DE 2A 0F       	.WORD	C_PAD			;Save intermediate string address
3606   17E0 AF 05       	.WORD	C_OVER			;Copy 2nd down to top of stack
3607   17E2 8C 0A       	.WORD	C_MINUS
3608   17E4 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3609   17E6             
3610   17E6             W_SIGN:
3611   17E6 84534947CE  	.BYTE	84h,"SIG",'N'+80h
3612   17EB CF 17       	.WORD	W_SHARPGT
3613   17ED             C_SIGN:
3614   17ED B4 06       	.WORD	E_COLON			;Interpret following word sequence
3615   17EF FD 0A       	.WORD	C_ROT			;3rd valu down to top of stack
3616   17F1 3A 05       	.WORD	C_0LESS			;Less than 0
3617   17F3 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3618   17F5 08 00       	.WORD	B0036-$			;0008h
3619   17F7 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3620   17F9 2D 00       	.WORD	002Dh
3621   17FB 12 0F       	.WORD	C_HOLD
3622   17FD             B0036:
3623   17FD C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3624   17FF             
3625   17FF             W_SHARP:
3626   17FF 81 A3       	.BYTE	81h,'#'+80h
3627   1801 E6 17       	.WORD	W_SIGN
3628   1803             C_SHARP:
3629   1803 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3630   1805 5C 08       	.WORD	C_BASE			;Put BASE addr on stack
3631   1807 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
3632   1809 46 14       	.WORD	C_MDIVMOD
3633   180B FD 0A       	.WORD	C_ROT			;3rd valu down to top of stack
3634   180D C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3635   180F 09 00       	.WORD	0009h
3636   1811 AF 05       	.WORD	C_OVER			;Copy 2nd down to top of stack
3637   1813 AD 0A       	.WORD	C_LESSTHAN
3638   1815 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3639   1817 08 00       	.WORD	B0037-$			;0008h
3640   1819 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3641   181B 07 00       	.WORD	0007h
3642   181D 4B 05       	.WORD	C_PLUS			;n1 + n2
3643   181F             B0037:
3644   181F C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3645   1821 30 00       	.WORD	0030h
3646   1823 4B 05       	.WORD	C_PLUS			;n1 + n2
3647   1825 12 0F       	.WORD	C_HOLD
3648   1827 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3649   1829             
3650   1829             W_SHARPS:
3651   1829 82 23 D3    	.BYTE	82h,'#','S'+80h
3652   182C FF 17       	.WORD	W_SHARP
3653   182E             C_SHARPS:
3654   182E B4 06       	.WORD	E_COLON			;Interpret following word sequence
3655   1830             B0038:
3656   1830 03 18       	.WORD	C_SHARP
3657   1832 AF 05       	.WORD	C_OVER			;Copy 2nd down to top of stack
3658   1834 AF 05       	.WORD	C_OVER			;Copy 2nd down to top of stack
3659   1836 50 04       	.WORD	C_OR			;OR
3660   1838 1F 05       	.WORD	C_0EQUALS		;=0
3661   183A 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3662   183C F4 FF       	.WORD	B0038-$			;FFF4h
3663   183E C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3664   1840             
3665   1840             W_DDOTR:
3666   1840 83 44 2E D2 	.BYTE	83h,"D.",'R'+80h
3667   1844 29 18       	.WORD	W_SHARPS
3668   1846             C_DDOTR:
3669   1846 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3670   1848 ED 04       	.WORD	C_MOVER			;Move value from data to return stack
3671   184A DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
3672   184C AF 05       	.WORD	C_OVER			;Copy 2nd down to top of stack
3673   184E 6A 13       	.WORD	C_DABS
3674   1850 C5 17       	.WORD	C_LESSHARP
3675   1852 2E 18       	.WORD	C_SHARPS
3676   1854 ED 17       	.WORD	C_SIGN
3677   1856 D4 17       	.WORD	C_SHARPGT
3678   1858 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
3679   185A AF 05       	.WORD	C_OVER			;Copy 2nd down to top of stack
3680   185C 8C 0A       	.WORD	C_MINUS
3681   185E A8 17       	.WORD	C_SPACES
3682   1860 5A 0D       	.WORD	C_TYPE			;Output n bytes from addr
3683   1862 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3684   1864             
3685   1864             W_DOTR:
3686   1864 82 2E D2    	.BYTE	82h,'.','R'+80h
3687   1867 40 18       	.WORD	W_DDOTR
3688   1869             C_DOTR:
3689   1869 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3690   186B ED 04       	.WORD	C_MOVER			;Move value from data to return stack
3691   186D 23 13       	.WORD	C_SINGTODUB		;Change single number to double
3692   186F 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
3693   1871 46 18       	.WORD	C_DDOTR
3694   1873 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3695   1875             
3696   1875             W_DDOT:
3697   1875 82 44 AE    	.BYTE	82h,'D','.'+80h
3698   1878 64 18       	.WORD	W_DOTR
3699   187A             C_DDOT:
3700   187A B4 06       	.WORD	E_COLON			;Interpret following word sequence
3701   187C 2B 07       	.WORD	C_ZERO			;Put zero on stack
3702   187E 46 18       	.WORD	C_DDOTR
3703   1880 22 0B       	.WORD	C_SPACE			;Output space
3704   1882 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3705   1884             
3706   1884             W_DOT:
3707   1884 81 AE       	.BYTE	81h,'.'+80h
3708   1886 75 18       	.WORD	W_DDOT
3709   1888             C_DOT:
3710   1888 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3711   188A 23 13       	.WORD	C_SINGTODUB		;Change single number to double
3712   188C 7A 18       	.WORD	C_DDOT
3713   188E C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3714   1890             
3715   1890             W_QUESTION:
3716   1890 81 BF       	.BYTE	81h,'?'+80h
3717   1892 84 18       	.WORD	W_DOT
3718   1894             C_QUESTION:
3719   1894 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3720   1896 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
3721   1898 88 18       	.WORD	C_DOT
3722   189A C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3723   189C             
3724   189C             W_UDOT:					;Output as unsigned value
3725   189C 82 55 AE    	.BYTE	82h,'U','.'+80h
3726   189F 90 18       	.WORD	W_QUESTION
3727   18A1             C_UDOT:
3728   18A1 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3729   18A3 2B 07       	.WORD	C_ZERO			;Put zero on stack
3730   18A5 7A 18       	.WORD	C_DDOT			;Output double value
3731   18A7 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3732   18A9             
3733   18A9             W_VLIST:
3734   18A9 85564C4953D4	.BYTE	85h,"VLIS",'T'+80h
3735   18AF 9C 18       	.WORD	W_UDOT
3736   18B1             C_VLIST:
3737   18B1 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3738   18B3 37 08       	.WORD	C_CONTEXT		;Leave vocab pointer on stack
3739   18B5 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
3740   18B7 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
3741   18B9 84 03       	.WORD	C_CR			;Output [CR][LF]
3742   18BB             B0039:
3743   18BB E7 05       	.WORD	C_DUP			;Duplicate top value on stack
3744   18BD B1 0B       	.WORD	C_PFA			;Convert NFA to PFA
3745   18BF DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
3746   18C1 9F 10       	.WORD	C_ID			;Print definition name from name field addr
3747   18C3 7D 0B       	.WORD	C_LFA			;Convert param addr to link addr
3748   18C5 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
3749   18C7 E7 05       	.WORD	C_DUP			;Duplicate top value on stack
3750   18C9 1F 05       	.WORD	C_0EQUALS		;=0
3751   18CB 75 03       	.WORD	C_TERMINAL		;Check for break key
3752   18CD 50 04       	.WORD	C_OR			;OR
3753   18CF 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3754   18D1 EA FF       	.WORD	B0039-$			;FFE2h
3755   18D3 BE 05       	.WORD	C_DROP			;Drop top value from stack
3756   18D5 84 03       	.WORD	C_CR			;Output [CR][LF]
3757   18D7 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3758   18D9             
3759   18D9             W_LIST:
3760   18D9 844C4953D4  	.BYTE	84h,"LIS",'T'+80h
3761   18DE A9 18       	.WORD	W_VLIST
3762   18E0             C_LIST:
3763   18E0 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3764   18E2 5C 08       	.WORD	C_BASE			;Put BASE addr on stack
3765   18E4 3A 06       	.WORD	C_FETCH			;Put current base on stack
3766   18E6 DA 05       	.WORD	C_SWAP			;Get number of list screen to top
3767   18E8 CD 0C       	.WORD	C_DECIMAL		;Sets decimal mode
3768   18EA 84 03       	.WORD	C_CR			;Output [CR][LF]
3769   18EC E7 05       	.WORD	C_DUP			;Duplicate top value on stack
3770   18EE 1C 08       	.WORD	C_SCR			;Set most recently listed
3771   18F0 71 06       	.WORD	C_STORE			;Store word at addr
3772   18F2 BB 0D       	.WORD	C_CQUOTE		;Output following string
3773   18F4 06          	.BYTE	S_END3-S_START3
3774   18F5             S_START3:
3775   18F5 534352202320	.BYTE	"SCR # "
3776   18FB             S_END3:
3777   18FB 88 18       	.WORD	C_DOT			;Output the screen number
3778   18FD C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3779   18FF 10 00       	.WORD	0010h			;16 lines to do
3780   1901 2B 07       	.WORD	C_ZERO			;From 0 to 15
3781   1903 5A 02       	.WORD	C_LDO			;Put start & end loop values on RPP
3782   1905             DO_LINE:
3783   1905 84 03       	.WORD	C_CR			;Output [CR][LF]
3784   1907 76 02       	.WORD	C_I		    	;Line number onto data stack
3785   1909 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3786   190B 03 00       	.WORD	0003h			;Fromat right justified 3 characters
3787   190D 69 18       	.WORD	C_DOTR			;Output formatted
3788   190F 22 0B       	.WORD	C_SPACE			;Output space
3789   1911 76 02       	.WORD	C_I		     	;Line number onto data stack
3790   1913 1C 08       	.WORD	C_SCR			;Get screen number
3791   1915 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
3792   1917 87 14       	.WORD	C_DOTLINE		;Output line from screen
3793   1919 75 03       	.WORD	C_TERMINAL		;Check for break key
3794   191B 00 02       	.WORD	C_0BRANCH		;Jump if no break key
3795   191D 04 00       	.WORD	NO_BRK-$		;
3796   191F D9 04       	.WORD	C_LEAVE			;Else set loop index to limit (quit loop)
3797   1921             NO_BRK:
3798   1921 15 02       	.WORD	C_LLOOP			;Increment loop & branch if not done
3799   1923 E2 FF       	.WORD	DO_LINE-$		;
3800   1925 84 03       	.WORD	C_CR			;Output [CR][LF]
3801   1927 5C 08       	.WORD	C_BASE			;Put BASE addr on stack
3802   1929 71 06       	.WORD	C_STORE			;Restore original base
3803   192B C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3804   192D             
3805   192D             W_INDEX:
3806   192D 85494E4445D8	.BYTE	85h,"INDE",'X'+80h
3807   1933 D9 18       	.WORD	W_LIST
3808   1935             C_INDEX:
3809   1935 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3810   1937 1B 0A       	.WORD	C_1PLUS			;1 plus
3811   1939 DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
3812   193B 5A 02       	.WORD	C_LDO			;Put start & end loop values on RPP
3813   193D             B003D:
3814   193D 84 03       	.WORD	C_CR			;Output [CR][LF]
3815   193F 76 02       	.WORD	C_I			;Copy LOOP index to data stack
3816   1941 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3817   1943 03 00       	.WORD	0003h
3818   1945 69 18       	.WORD	C_DOTR
3819   1947 22 0B       	.WORD	C_SPACE			;Output space
3820   1949 2B 07       	.WORD	C_ZERO			;Put zero on stack
3821   194B 76 02       	.WORD	C_I			;Copy LOOP index to data stack
3822   194D 87 14       	.WORD	C_DOTLINE		;Output line from screen
3823   194F 75 03       	.WORD	C_TERMINAL		;Check for break key
3824   1951 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3825   1953 04 00       	.WORD	B003C-$			;0004h
3826   1955 D9 04       	.WORD	C_LEAVE			;Quit loop by making index = limit
3827   1957             B003C:
3828   1957 15 02       	.WORD	C_LLOOP			;Increment loop & branch if not done
3829   1959 E4 FF       	.WORD	B003D-$			;FFE4h
3830   195B 84 03       	.WORD	C_CR			;Output [CR][LF]
3831   195D C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3832   195F             
3833   195F             W_INT:
3834   195F C43B494ED4  	.BYTE	0C4h,";IN",'T'+80h
3835   1964 2D 19       	.WORD	W_INDEX
3836   1966             C_INT:
3837   1966 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3838   1968 35 0C       	.WORD	C_WHATSTACK		;Check stack pointer, error if not ok
3839   196A 6C 0C       	.WORD	C_COMPILE		;Compile next word into dictionary
3840   196C 74 19       	.WORD	X_INT
3841   196E 82 0C       	.WORD	C_LEFTBRKT		;Set STATE to execute
3842   1970 A5 0C       	.WORD	C_SMUDGE
3843   1972 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3844   1974             
3845   1974             X_INT:
3846   1974 76 19       	.WORD	2+$			;Vector to code
3847   1976 21 4C FE    	LD	HL,INTFLAG
3848   1979 CB B6       	RES	6,(HL)
3849   197B FB          	EI
3850   197C C3 C4 04    	JP	X_STOP
3851   197F             
3852   197F             W_INTFLAG:
3853   197F 87494E54464C	.BYTE	87h,"INTFLA",'G'+80h
3853   1985 41C7
3854   1987 5F 19       	.WORD	W_INT
3855   1989             C_INTFLAG:
3856   1989 1B 07       	.WORD	X_USER			;Put next word on stack then do next
3857   198B 4C 00       	.WORD	INTFLAG-SYSTEM
3858   198D             
3859   198D             W_INTVECT:
3860   198D 87494E545645	.BYTE	87h,"INTVEC",'T'+80h
3860   1993 43D4
3861   1995 7F 19       	.WORD	W_INTFLAG
3862   1997             C_INTVECT:
3863   1997 1B 07       	.WORD	X_USER			;Put next word on stack then do next
3864   1999 4E 00       	.WORD	INTVECT-SYSTEM
3865   199B             
3866   199B             W_CPU:
3867   199B 842E4350D5  	.BYTE	84h,".CP",'U'+80h
3868   19A0 8D 19       	.WORD	W_INTVECT
3869   19A2             C_CPU:
3870   19A2 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3871   19A4 BB 0D       	.WORD	C_CQUOTE		;Output following string
3872   19A6 04          	.BYTE	S_END4-S_START4
3873   19A7             S_START4:
3874   19A7 5A 38 30 20 	.BYTE	"Z80 "
3875   19AB             S_END4:
3876   19AB C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3877   19AD             
3878   19AD             W_2SWAP:
3879   19AD 8532535741D0	.BYTE	85h,"2SWA",'P'+80h
3880   19B3 9B 19       	.WORD	W_CPU
3881   19B5             C_2SWAP:
3882   19B5 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3883   19B7 FD 0A       	.WORD	C_ROT			;3rd valu down to top of stack
3884   19B9 ED 04       	.WORD	C_MOVER			;Move value from data to return stack
3885   19BB FD 0A       	.WORD	C_ROT			;3rd valu down to top of stack
3886   19BD 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
3887   19BF C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3888   19C1             
3889   19C1             W_2OVER:
3890   19C1 85324F5645D2	.BYTE	85h,"2OVE",'R'+80h
3891   19C7 AD 19       	.WORD	W_2SWAP
3892   19C9             C_2OVER:
3893   19C9 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3894   19CB ED 04       	.WORD	C_MOVER			;Move value from data to return stack
3895   19CD ED 04       	.WORD	C_MOVER			;Move value from data to return stack
3896   19CF F5 05       	.WORD	C_2DUP			;Dup top 2 values on stack
3897   19D1 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
3898   19D3 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
3899   19D5 B5 19       	.WORD	C_2SWAP
3900   19D7 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3901   19D9             
3902   19D9             W_EXIT:
3903   19D9 84455849D4  	.BYTE	84h,"EXI",'T'+80h
3904   19DE C1 19       	.WORD	W_2OVER
3905   19E0             C_EXIT:
3906   19E0 C4 04       	.WORD	X_STOP
3907   19E2             
3908   19E2             W_J:					;Push outer loop value on stack
3909   19E2 81 CA       	.BYTE	81h,'J'+80h
3910   19E4 D9 19       	.WORD	W_EXIT
3911   19E6             C_J:
3912   19E6 E8 19       	.WORD	2+$			;Vector to code
3913   19E8 2A 46 FE    	LD	HL,(RPP)		;Get return stack pointer
3914   19EB 23          	INC	HL			;Skip inner loop values
3915   19EC 23          	INC	HL			;
3916   19ED 23          	INC	HL			;
3917   19EE 23          	INC	HL			;
3918   19EF C3 7B 02    	JP	X_I2
3919   19F2             
3920   19F2             W_ROLL:
3921   19F2 84524F4CCC  	.BYTE	84h,"ROL",'L'+80h
3922   19F7 E2 19       	.WORD	W_J
3923   19F9             C_ROLL:
3924   19F9 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3925   19FB E7 05       	.WORD	C_DUP			;Duplicate top value on stack
3926   19FD 2B 07       	.WORD	C_ZERO			;Put zero on stack
3927   19FF EF 0A       	.WORD	C_GREATER
3928   1A01 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3929   1A03 2C 00       	.WORD	B003E-$			;002Ch
3930   1A05 E7 05       	.WORD	C_DUP			;Duplicate top value on stack
3931   1A07 ED 04       	.WORD	C_MOVER			;Move value from data to return stack
3932   1A09 0C 0B       	.WORD	C_PICK
3933   1A0B 03 05       	.WORD	C_RMOVE			;Move word from return to data stack
3934   1A0D 2B 07       	.WORD	C_ZERO			;Put zero on stack
3935   1A0F DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
3936   1A11 5A 02       	.WORD	C_LDO			;Put start & end loop values on RPP
3937   1A13             B003F:
3938   1A13 76 04       	.WORD	C_SPFETCH		;Stack pointer onto stack
3939   1A15 76 02       	.WORD	C_I			;Copy LOOP index to data stack
3940   1A17 E7 05       	.WORD	C_DUP			;Duplicate top value on stack
3941   1A19 4B 05       	.WORD	C_PLUS			;n1 + n2
3942   1A1B 4B 05       	.WORD	C_PLUS			;n1 + n2
3943   1A1D E7 05       	.WORD	C_DUP			;Duplicate top value on stack
3944   1A1F 40 0A       	.WORD	C_2MINUS		;2 minus
3945   1A21 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
3946   1A23 DA 05       	.WORD	C_SWAP			;Swap top 2 values on stack
3947   1A25 71 06       	.WORD	C_STORE			;Store word at addr
3948   1A27 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3949   1A29 FF FF       	.WORD	0FFFFh
3950   1A2B 4E 02       	.WORD	C_PLOOP			;Loop + stack & branch if not done
3951   1A2D E6 FF       	.WORD	B003F-$			;FFE6h
3952   1A2F             B003E:
3953   1A2F BE 05       	.WORD	C_DROP			;Drop top value from stack
3954   1A31 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3955   1A33             
3956   1A33             W_DEPTH:
3957   1A33 8544455054C8	.BYTE	85h,"DEPT",'H'+80h
3958   1A39 F2 19       	.WORD	W_ROLL
3959   1A3B             C_DEPTH:
3960   1A3B B4 06       	.WORD	E_COLON			;Interpret following word sequence
3961   1A3D A3 07       	.WORD	C_S0			;Push S0 (initial data stack pointer)
3962   1A3F 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
3963   1A41 76 04       	.WORD	C_SPFETCH		;Stack pointer onto stack
3964   1A43 8C 0A       	.WORD	C_MINUS
3965   1A45 3B 07       	.WORD	C_2
3966   1A47 03 14       	.WORD	C_DIV
3967   1A49 34 0A       	.WORD	C_1MINUS		;1 minus
3968   1A4B C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3969   1A4D             
3970   1A4D             W_DLESSTHAN:
3971   1A4D 82 44 BC    	.BYTE	82h,'D','<'+80h
3972   1A50 33 1A       	.WORD	W_DEPTH
3973   1A52             C_DLESSTHAN:
3974   1A52 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3975   1A54 FD 0A       	.WORD	C_ROT			;3rd valu down to top of stack
3976   1A56 F5 05       	.WORD	C_2DUP			;Dup top 2 values on stack
3977   1A58 A1 0A       	.WORD	C_EQUALS
3978   1A5A 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3979   1A5C 0A 00       	.WORD	B0040-$			;000Ah
3980   1A5E CC 05       	.WORD	C_2DROP			;Drop top two values from stack
3981   1A60 CF 0A       	.WORD	C_ULESS			;IF stack-1 < stack_top leave true flag
3982   1A62 E8 01       	.WORD	C_BRANCH		;Add following offset to BC
3983   1A64 08 00       	.WORD	B0041-$			;0008h
3984   1A66             B0040:
3985   1A66 B5 19       	.WORD	C_2SWAP
3986   1A68 CC 05       	.WORD	C_2DROP			;Drop top two values from stack
3987   1A6A EF 0A       	.WORD	C_GREATER
3988   1A6C             B0041:
3989   1A6C C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3990   1A6E             
3991   1A6E             W_0GREATER:
3992   1A6E 82 30 BE    	.BYTE	82h,'0','>'+80h
3993   1A71 4D 1A       	.WORD	W_DLESSTHAN
3994   1A73             C_0GREATER:
3995   1A73 B4 06       	.WORD	E_COLON			;Interpret following word sequence
3996   1A75 2B 07       	.WORD	C_ZERO			;Put zero on stack
3997   1A77 EF 0A       	.WORD	C_GREATER
3998   1A79 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
3999   1A7B             
4000   1A7B             W_DOTS:
4001   1A7B 82 2E D3    	.BYTE	82h,'.','S'+80h
4002   1A7E 6E 1A       	.WORD	W_0GREATER
4003   1A80             C_DOTS
4004   1A80 B4 06       	.WORD	E_COLON			;Interpret following word sequence
4005   1A82 84 03       	.WORD	C_CR			;Output [CR][LF]
4006   1A84 3B 1A       	.WORD	C_DEPTH
4007   1A86 00 02       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
4008   1A88 20 00       	.WORD	B0042-$			;0020h
4009   1A8A 76 04       	.WORD	C_SPFETCH		;Stack pointer onto stack
4010   1A8C 40 0A       	.WORD	C_2MINUS		;2 minus
4011   1A8E A3 07       	.WORD	C_S0			;Push S0 (initial data stack pointer)
4012   1A90 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
4013   1A92 40 0A       	.WORD	C_2MINUS		;2 minus
4014   1A94 5A 02       	.WORD	C_LDO			;Put start & end loop values on RPP
4015   1A96             B0043:
4016   1A96 76 02       	.WORD	C_I			;Copy LOOP index to data stack
4017   1A98 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
4018   1A9A 88 18       	.WORD	C_DOT
4019   1A9C C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
4020   1A9E FE FF       	.WORD	0FFFEh
4021   1AA0 4E 02       	.WORD	C_PLOOP			;Loop + stack & branch if not done
4022   1AA2 F4 FF       	.WORD	B0043-$			;FFF4h
4023   1AA4 E8 01       	.WORD	C_BRANCH		;Add following offset to BC
4024   1AA6 11 00       	.WORD	S_END5-$		;0011h
4025   1AA8             B0042:
4026   1AA8 BB 0D       	.WORD	C_CQUOTE		;Output following string
4027   1AAA 0C          	.BYTE	S_END5-S_START5
4028   1AAB             S_START5:
4029   1AAB 535441434B20	.BYTE	"STACK EMPTY "
4029   1AB1 454D50545920
4030   1AB7             S_END5:
4031   1AB7 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
4032   1AB9             
4033   1AB9             W_CODE:
4034   1AB9 84434F44C5  	.BYTE	84h,"COD",'E'+80h
4035   1ABE 7B 1A       	.WORD	W_DOTS
4036   1AC0             C_CODE:
4037   1AC0 B4 06       	.WORD	E_COLON			;Interpret following word sequence
4038   1AC2 0B 0C       	.WORD	C_QEXEC			;Error not if not in execute mode
4039   1AC4 AF 10       	.WORD	C_XXX1
4040   1AC6 85 04       	.WORD	C_SPSTORE		;Set initial stack pointer value
4041   1AC8 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
4042   1ACA             
4043   1ACA             W_ENDCODE:
4044   1ACA 88454E442D43	.BYTE	88h,"END-COD",'E'+80h
4044   1AD0 4F44C5
4045   1AD3 B9 1A       	.WORD	W_CODE
4046   1AD5             C_ENDCODE:
4047   1AD5 B4 06       	.WORD	E_COLON			;Interpret following word sequence
4048   1AD7 45 08       	.WORD	C_CURRENT
4049   1AD9 3A 06       	.WORD	C_FETCH			;Get word from addr on stack
4050   1ADB 37 08       	.WORD	C_CONTEXT
4051   1ADD 71 06       	.WORD	C_STORE			;Store word at addr
4052   1ADF 0B 0C       	.WORD	C_QEXEC			;Error not if not in execute mode
4053   1AE1 35 0C       	.WORD	C_WHATSTACK		;Check stack pointer, error if not ok
4054   1AE3 A5 0C       	.WORD	C_SMUDGE
4055   1AE5 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
4056   1AE7             
4057   1AE7             W_NEXT:
4058   1AE7 C44E4558D4  	.BYTE	0C4h,"NEX",'T'+80h
4059   1AEC CA 1A       	.WORD	W_ENDCODE
4060   1AEE             C_NEXT:
4061   1AEE B4 06       	.WORD	E_COLON			;Interpret following word sequence
4062   1AF0 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
4063   1AF2 C3 00       	.WORD	00C3h			;Jump instruction
4064   1AF4 7C 0A       	.WORD	C_CCOMMA		;Save as 8 bit value
4065   1AF6 C4 01       	.WORD	C_LIT			;Puts next 2 bytes on the stack
4066   1AF8 9E 01       	.WORD	NEXT			;The address of NEXT
4067   1AFA 6B 0A       	.WORD	C_COMMA			;Reserve 2 bytes and save n
4068   1AFC C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
4069   1AFE             
4070   1AFE             W_LLOAD:
4071   1AFE 854C4C4F41C4	.BYTE	85h,"LLOA",'D'+80h
4072   1B04             ;	.WORD	W_MON
4073   1B04 E7 1A       	.WORD	W_NEXT
4074   1B06             C_LLOAD:
4075   1B06 B4 06       	.WORD	E_COLON			;Interpret following word sequence
4076   1B08 55 15       	.WORD	C_BLOCK			;Get block address
4077   1B0A C4 01       	.WORD	C_LIT			;Enter loop with null
4078   1B0C 00 00       	.WORD	0000h			;
4079   1B0E             LL_BEGIN:
4080   1B0E E7 05       	.WORD	C_DUP			;Dup key
4081   1B10 00 02       	.WORD	C_0BRANCH		;If null then don't store
4082   1B12 28 00       	.WORD	LL_NULL-$		;
4083   1B14 E7 05       	.WORD	C_DUP			;Dup key again
4084   1B16 C4 01       	.WORD	C_LIT			;Compare to [CR]
4085   1B18 0D 00       	.WORD	000Dh			;
4086   1B1A A1 0A       	.WORD	C_EQUALS		;
4087   1B1C 00 02       	.WORD	C_0BRANCH		;If not [CR] then jump
4088   1B1E 12 00       	.WORD	LL_STORE-$		;
4089   1B20 BE 05       	.WORD	C_DROP			;Drop the [CR]
4090   1B22 56 07       	.WORD	C_CL			;Get characters per line
4091   1B24 4B 05       	.WORD	C_PLUS			;Add to current addr
4092   1B26 56 07       	.WORD	C_CL			;Make CL MOD value
4093   1B28 7B 05       	.WORD	C_NEGATE		;Form 2s complement of n
4094   1B2A 3E 04       	.WORD	C_AND			;Mask out bits
4095   1B2C E8 01       	.WORD	C_BRANCH		;Done this bit so jump
4096   1B2E 06 00       	.WORD	NO_STORE-$
4097   1B30             LL_STORE:
4098   1B30 AF 05       	.WORD	C_OVER			;Get address to store at
4099   1B32 71 06       	.WORD	C_STORE			;Save chr
4100   1B34             NO_STORE:
4101   1B34 1B 0A       	.WORD	C_1PLUS			;Next addres
4102   1B36 E8 01       	.WORD	C_BRANCH		;Done so jump
4103   1B38 04 00       	.WORD	LL_CHAR-$		;
4104   1B3A             LL_NULL:
4105   1B3A BE 05       	.WORD	C_DROP			;Was null so drop it
4106   1B3C             LL_CHAR:
4107   1B3C 63 03       	.WORD	C_KEY			;Get key
4108   1B3E E7 05       	.WORD	C_DUP			;Duplicate it
4109   1B40 C4 01       	.WORD	C_LIT			;Compare with [CTRL] Z
4110   1B42 1A 00       	.WORD	001Ah			;
4111   1B44 A1 0A       	.WORD	C_EQUALS		;
4112   1B46 00 02       	.WORD	C_0BRANCH		;If not EOF then jump
4113   1B48 C6 FF       	.WORD	LL_BEGIN-$		;
4114   1B4A BE 05       	.WORD	C_DROP			;Drop EOF character
4115   1B4C BE 05       	.WORD	C_DROP			;Drop next address
4116   1B4E C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
4117   1B50             
4118   1B50             W_TASK:
4119   1B50 84544153CB  	.BYTE	84h,"TAS",'K'+80h
4120   1B55 FE 1A       	.WORD	W_LLOAD
4121   1B57             C_TASK:
4122   1B57 B4 06       	.WORD	E_COLON			;Interpret following word sequence
4123   1B59 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
4124   1B5B             W_TASKEND:
4125   1B5B             
4126   1B5B             W_EDITI:
4127   1B5B             
4128   1B5B             W_CLEAR:				;Clear block n
4129   1B5B 85434C4541D2	.BYTE	85h,"CLEA",'R'+80h
4130   1B61 50 1B       	.WORD	W_TASK
4131   1B63             C_CLEAR:
4132   1B63 B4 06       	.WORD	E_COLON			;Interpret following word sequence
4133   1B65 E7 05       	.WORD	C_DUP			;Duplicate number
4134   1B67 1C 08       	.WORD	C_SCR			;Get SCR addr
4135   1B69 71 06       	.WORD	C_STORE			;Store screen number
4136   1B6B 55 15       	.WORD	C_BLOCK			;Get the address of the block
4137   1B6D 86 07       	.WORD	C_BBUF			;Put number of bytes/block on stack
4138   1B6F F2 0E       	.WORD	C_ERASE			;Clear the block
4139   1B71 C2 04       	.WORD	C_STOP			;Pop BC from return stack (=next)
4140   1B73             
4141   1B73             CF_UKEY:				;Get key onto stack
4142   1B73 75 1B       	.WORD	2+$			;Vector to code
4143   1B75 CD AE 1B    	CALL	CHR_RD			;User key in routine
4144   1B78 6F          	LD	L,A			;Put key on stack
4145   1B79 26 00       	LD	H,00h			;
4146   1B7B C3 9D 01    	JP	NEXTS1			;Save & NEXT
4147   1B7E             
4148   1B7E             CF_UEMIT:				;Chr from stack to output
4149   1B7E 80 1B       	.WORD	2+$			;Vector to code
4150   1B80 E1          	POP	HL			;Get CHR to output
4151   1B81 7D          	LD	A,L			;Put in A
4152   1B82 C5          	PUSH	BC			;Save regs
4153   1B83 D5          	PUSH	DE			;
4154   1B84 CD B3 1B    	CALL	CHR_WR			;User output routine
4155   1B87 D1          	POP	DE			;Restore regs
4156   1B88 C1          	POP	BC			;
4157   1B89 C3 9E 01    	JP	NEXT			;
4158   1B8C             
4159   1B8C             CF_UCR:					;CR output
4160   1B8C 8E 1B       	.WORD	2+$			;Vector to code
4161   1B8E C5          	PUSH	BC			;Save regs
4162   1B8F D5          	PUSH	DE			;Just in case
4163   1B90 3E 0D       	LD	A,0Dh			;Carrage return
4164   1B92 CD B3 1B    	CALL	CHR_WR			;User output routine
4165   1B95 3E 0A       	LD	A,0Ah			;Line feed
4166   1B97 CD B3 1B    	CALL	CHR_WR			;User output routine
4167   1B9A D1          	POP	DE			;Get regs back
4168   1B9B C1          	POP	BC			;
4169   1B9C C3 9E 01    	JP	NEXT			;Next
4170   1B9F             
4171   1B9F             CF_UQTERMINAL:				;Test for user break
4172   1B9F A1 1B       	.WORD	2+$			;Vector to code
4173   1BA1 C5          	PUSH	BC			;Save regs
4174   1BA2 D5          	PUSH	DE			;Just in case
4175   1BA3 CD B1 1B    	CALL	BREAKKEY		;User break test routine
4176   1BA6 D1          	POP	DE			;Get regs back
4177   1BA7 C1          	POP	BC			;
4178   1BA8 26 00       	LD	H,00h			;Clear H
4179   1BAA 6F          	LD	L,A			;Result in L
4180   1BAB C3 9D 01    	JP	NEXTS1			;Store it & Next
4181   1BAE             
4182   1BAE             ;==============================================================================
4183   1BAE             ; Serial I/O routines
4184   1BAE             ; Rachel - To use INT32K.ASM
4185   1BAE             ;==============================================================================
4186   1BAE             
4187   1BAE             CHR_RD:					;Character in
4188   1BAE D7          	RST 10h
4189   1BAF C9          	RET
4190   1BB0             NO_BUF_KEY:
4191   1BB0 C9          	RET				;
4192   1BB1             
4193   1BB1             BREAKKEY:
4194   1BB1             ; 	IN A,($80)
4195   1BB1             ; 	AND $01           		;Check if interupt due to read buffer full
4196   1BB1             ; 	JR Z,NO_KEY        		;if not, ignore
4197   1BB1             ; 	IN A,($81)
4198   1BB1             ; 	CP 27h				;Is it break
4199   1BB1             ; 	JR Z,WAS_BRK
4200   1BB1             NO_KEY:
4201   1BB1 AF           	XOR	A			;Wasn't break, or no key, so clear
4202   1BB2 C9          	RET
4203   1BB3             ;WAS_BRK:
4204   1BB3             ; 	LD	A,01h			;Was break so set flag
4205   1BB3             ; 	RET
4206   1BB3             
4207   1BB3             CHR_WR:					;Character out
4208   1BB3 E6 7F               AND 7Fh                         ;To knock off end of word marker
4209   1BB5 CF                  RST 08h
4210   1BB6 C9          	RET				;
4211   1BB7             
4212   1BB7             ;==============================================================================
4213   FE00             		.ORG	0FE00h	        ;Set up system variable addresses
4214   FE00             ;==============================================================================
4215   FE00             SYSTEM:					;Start of scratch pad area
4216   FE00             		.BLOCK	6		;User bytes
4217   FE06             S0:		.BLOCK	2		;Initial value of the data stack pointer
4218   FE08             R0:		.BLOCK	2		;Initial value of the return stack pointer
4219   FE0A             TIB:		.BLOCK	2		;Address of the terminal input buffer
4220   FE0C             WIDTH:		.BLOCK	2		;Number of letters saved in names
4221   FE0E             WARNING:	.BLOCK	2		;Error message control number
4222   FE10             FENCE:		.BLOCK	2		;Dictionary FORGET protection point
4223   FE12             DP:		.BLOCK	2		;The dictionary pointer
4224   FE14             VOC_LINK:	.BLOCK	2		;Most recently created vocabulary
4225   FE16             BLK:		.BLOCK	2		;Current block number under interpretation
4226   FE18             TOIN:		.BLOCK	2		;Offset in the current input text buffer
4227   FE1A             OUT:		.BLOCK	2		;Offset in the current output text buffer
4228   FE1C             SCR:		.BLOCK	2		;Screen number last referenced by LIST
4229   FE1E             OFFSET:		.BLOCK	2		;Block offset for disk drives
4230   FE20             CONTEXT:	.BLOCK	2		;Pointer to the vocabulary within which
4231   FE22             					;dictionary search will first begin
4232   FE22             CURRENT:	.BLOCK	2		;Pointer to the vocabulary within which
4233   FE24             					;new definitions are to be created
4234   FE24             STATE:		.BLOCK	2		;Contains state of compillation
4235   FE26             BASE:		.BLOCK	2		;Current I/O base address
4236   FE28             DPL:		.BLOCK	2		;Number of digits to the right of the
4237   FE2A             					;decimal point on double integer input
4238   FE2A             FLD:		.BLOCK	2		;Field width for formatted number output
4239   FE2C             CSP:		.BLOCK	2		;Check stack pointer
4240   FE2E             RHASH:		.BLOCK	2		;Location of editor cursor in a text bloxk
4241   FE30             HLD:		.BLOCK	2		;Address of current output
4242   FE32             FLAST:		.BLOCK	6		;FORTH vocabulary data initialised to FORTH
4243   FE38             					;vocabulary
4244   FE38             ELAST:		.BLOCK	6		;Editor vocabulary data initialised to
4245   FE3E             					;EDITOR vocabulary
4246   FE3E             CRFLAG:		.BLOCK	1		;Carriage return flag
4247   FE3F             		.BLOCK	1		;User byte
4248   FE40             PAT:		.BLOCK	3		;I/O port fetch routine (input)
4249   FE43             PST:		.BLOCK	3		;I/O port store routine (output)
4250   FE46             RPP:		.BLOCK	2		;Return stack pointer
4251   FE48             USE:		.BLOCK	2		;Mass storage buffer address to use
4252   FE4A             PREV:		.BLOCK	2		;Mass storage buffer address just used
4253   FE4C             INTFLAG:	.BLOCK	1		;Interrupt flag
4254   FE4D             		.BLOCK	1		;User byte
4255   FE4E             INTVECT:	.BLOCK	2		;Interrupt vector
4256   FE50             UTERMINAL:	.BLOCK	2		;Code field address of word ?TERMINAL
4257   FE52             UKEY:		.BLOCK	2		;Code field address of word KEY
4258   FE54             UEMIT:		.BLOCK	2		;Code field address of word EMIT
4259   FE56             UCR:		.BLOCK	2		;Code field address of word CR
4260   FE58             URW:		.BLOCK	2		;Code field address of word R/W
4261   FE5A             UABORT:		.BLOCK	2		;Code field address of word ABORT
4262   FE5C             UCL:		.BLOCK	2		;Number of characters per input line
4263   FE5E             UFIRST:		.BLOCK	2		;Start of pseudo disk buffer
4264   FE60             ULIMIT:		.BLOCK	2		;End of pseudo disk buffer
4265   FE62             UBBUF:		.BLOCK	2		;Number of bytes per block
4266   FE64             UBSCR:		.BLOCK	2		;Number of buffers per block
4267   FE66             KEYBUF:		.BLOCK	2		;Double key buffer
4268   FE68             RAF:		.BLOCK	2		;Register AF
4269   FE6A             RBC:		.BLOCK	2		;Register BC
4270   FE6C             RDE:		.BLOCK	2		;Register DE
4271   FE6E             RHL:		.BLOCK	2		;Register HL
4272   FE70             RIX:		.BLOCK	2		;Register IX
4273   FE72             RIY:		.BLOCK	2		;Register IY
4274   FE74             RAF2:		.BLOCK	2		;Register AF'
4275   FE76             RBC2:		.BLOCK	2		;Register BC'
4276   FE78             RDE2:		.BLOCK	2		;Register DE'
4277   FE7A             RHL2:		.BLOCK	2		;Register HL'
4278   FE7C             		.BLOCK	1		;User byte
4279   FE7D             JPCODE:		.BLOCK	1		;JMP code (C3) for word CALL
4280   FE7E             JPVECT:		.BLOCK	2		;JMP vector for word CALL
4281   FE80             		.BLOCK	32		;User bytes
4282   FEA0             
4283   FEA0             		.END
4284   FEA0             ;==============================================================================
tasm: Number of errors = 0
