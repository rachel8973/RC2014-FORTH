0001   0000             ;------------------------------------------------------------------------------
0002   0000             ; FORTH - V0
0003   0000             ;------------------------------------------------------------------------------
0004   0000             ;
0005   0000             ; This is not my source. I did not write this I only made it work on the
0006   0000             ; RC2014 so I would have something the mess around with.
0007   0000             ;
0008   0000             ; I found a simple FORTH buried in a ZIP file on the Z80 info site at ...
0009   0000             ;      http://www.z80.info/zip/z80asm.zip
0010   0000             ;
0011   0000             ; V0 - Included the source from Grant Searles simple 7 chip Z80 computer
0012   0000             ;      from here http://searle.hostei.com/grant/
0013   0000             ;      Modified the CHR_RD and CHR_WR to use the routines from INT32K.ROM
0014   0000             ;      Added a def so I can build as a ROM or RAM
0015   0000             ;      A few renames so I could build it with TASM.
0016   0000             ;
0017   0000             ;------------------------------------------------------------------------------
0018   0000             
0019   0000~            #IFDEF ROM
0020   0000~            #INCLUDE        "INT32K.ASM"
0021   0000             #ENDIF         ; ROM
0022   0000             
0023   0000             ;------------------------------------------------------------------------------
0024   0000             ; This is an implementation of FORTH for the Z80 that should be easily portable
0025   0000             ; to other Z80 systems. It assumes RAM from 9000h to 0FFFFh and a UART for
0026   0000             ; communication with the host or VDU.
0027   0000             
0028   0000             DATA_STACK:	.EQU	0FD80h		;Data stack grows down
0029   0000             VOCAB_BASE:	.EQU	0F000h		;Dictionary grows up from here
0030   0000             MASS_STORE:	.EQU	0FEA0h		;Mass storage buffer (default)
0031   0000             DISK_START:	.EQU	0A000h		;Pseudo disk buffer start
0032   0000             DISK_END:	.EQU	0F000h		;Pseudo disk buffer end
0033   0000             BLOCK_SIZE:	.EQU	0200h		;Pseudo disk block size
0034   0000             BUFFERS:	.EQU	0001h		;Pseudo disk buffers per block
0035   0000             
0036   0000~            #IFDEF ROM
0037   0000~            ;  No Monitor
0038   0000~            		.ORG	150h		;Start of ROM after BIOS
0039   0000             #ELSE
0040   0000             MONSTART:	.EQU	0153h		;Monitor entry address
0041   8200             		.ORG	8200h		;Start of RAM allowing for Monitor ROM
0042   8200             #ENDIF
0043   8200             
0044   8200             ; Start of FORTH code
0045   8200             
0046   8200 C3 87 93    	JP	X_COLD
0047   8203             
0048   8203~            #IFDEF ROM
0049   8203~            ;  No Monitor
0050   8203~            	.ORG	153h			;  WARM Start Point
0051   8203             #ENDIF
0052   8203 C3 75 93    	JP	C_WARM
0053   8206             
0054   8206             BACKSPACE:
0055   8206 08 00       	.WORD	0008h			;Backspace chr
0056   8208             
0057   8208             WORD1:
0058   8208 80 FD       	.WORD	DATA_STACK
0059   820A             DEF_SYSADDR:
0060   820A 00 FE       	.WORD	SYSTEM
0061   820C 80 FD       	.WORD	DATA_STACK
0062   820E 1F 00       	.WORD	001Fh			;Word name length (default 31)
0063   8210 00 00       	.WORD	0000h			;Error message control number
0064   8212 00 F0       	.WORD	VOCAB_BASE		;FORGET protection
0065   8214 0B F0       	.WORD	VOCAB_BASE+0Bh		;Dictionary pointer
0066   8216 E4 92       	.WORD	E_FORTH			;Most recently created vocab.
0067   8218             
0068   8218             START_TABLE:
0069   8218 81 A0       	.BYTE	81h,0A0h
0070   821A 00 F0       	.WORD	VOCAB_BASE
0071   821C 00 00       	.BYTE	00h,00h			;FLAST
0072   821E 81 A0       	.BYTE	81h,0A0h
0073   8220 0B 9C       	.WORD	W_EDITI
0074   8222 E4 92       	.WORD	E_FORTH			;ELAST
0075   8224 00          	.BYTE	00h			;CRFLAG
0076   8225 00          	.BYTE	00h			;Free
0077   8226 DB 00       	IN	A,(00h)			;I/O Port input
0078   8228 C9          	RET				;routine
0079   8229 D3 00       	OUT	(00h),A			;I/O Port output
0080   822B C9          	RET				;routine
0081   822C 00 FE       	.WORD	SYSTEM 			;Return stack pointer
0082   822E A0 FE       	.WORD	MASS_STORE		;Mass storage buffer to use
0083   8230 A0 FE       	.WORD	MASS_STORE		;Storage buffer just used
0084   8232 00          	.BYTE	00h			;Interrupt flag
0085   8233 00          	.BYTE	00h			;Free
0086   8234 44 93       	.WORD	C_ABORT			;Interrupt vector
0087   8236 4F 9C       	.WORD	CF_UQTERMINAL		;C field address ?TERMINAL
0088   8238 23 9C       	.WORD	CF_UKEY			;C field address KEY
0089   823A 2E 9C       	.WORD	CF_UEMIT		;C field address EMIT
0090   823C 3C 9C       	.WORD	CF_UCR			;C field address CR
0091   823E 2D 96       	.WORD	CF_URW			;C field address R/W
0092   8240 4E 93       	.WORD	CF_UABORT		;C field address ABORT
0093   8242 20 00       	.WORD	0020h			;CHRs per input line
0094   8244 00 A0       	.WORD	DISK_START		;Pseudo disk buf start
0095   8246 00 F0       	.WORD	DISK_END		;Pseudo disk buf end
0096   8248 00 02       	.WORD	BLOCK_SIZE		;Bytes per block
0097   824A 01 00       	.WORD	BUFFERS			;Buffers per block
0098   824C             
0099   824C             NEXTS2:
0100   824C D5          	PUSH	DE
0101   824D             NEXTS1:
0102   824D E5          	PUSH	HL
0103   824E             NEXT:
0104   824E 3A 4C FE    	LD	A,(INTFLAG)		;Interrupt flag
0105   8251 CB 7F       	BIT	7,A			;Check for interrupt
0106   8253 28 0E       	JR	Z,NOINT			;No interrupt
0107   8255 CB 77       	BIT	6,A			;Interrupt enabled ?
0108   8257 20 0A       	JR	NZ,NOINT		;No interrupt
0109   8259 2A 4E FE    	LD	HL,(INTVECT)		;Get nterrupt vector
0110   825C 3E 40       	LD	A,40h			;Clear flag byte
0111   825E 32 4C FE    	LD	(INTFLAG),A		;Interrupt flag into HL
0112   8261 18 06       	JR	NEXTADDR		;JP (HL)
0113   8263             NOINT:
0114   8263 0A          	LD	A,(BC)			;effectively LD HL,(BC)
0115   8264 03          	INC	BC			;
0116   8265 6F          	LD	L,A			;
0117   8266 0A          	LD	A,(BC)			;
0118   8267 03          	INC	BC			;BC now points to next vector
0119   8268 67          	LD	H,A			;HL has addr vector
0120   8269             NEXTADDR:
0121   8269 5E          	LD	E,(HL)			;effectively LD HL,(HL)
0122   826A 23          	INC	HL			;
0123   826B 56          	LD	D,(HL) 			;
0124   826C EB          	EX	DE,HL 			;
0125   826D E9          	JP	(HL) 			;Jump to it
0126   826E             
0127   826E             W_LIT:					;Puts next 2 bytes on the stack
0128   826E 83 4C 49 D4 	.BYTE	83h,"LI",'T'+80h
0129   8272 00 00       	.WORD	0000h			;First word in vocabulary
0130   8274             C_LIT:
0131   8274 76 82       	.WORD	2+$			;Vector to code
0132   8276 0A          	LD	A,(BC)			;Gets next word from (BC)
0133   8277 03          	INC	BC			;then increments BC to point
0134   8278 6F          	LD	L,A			;to the next addr. Pushes the
0135   8279 0A          	LD	A,(BC)			;result onto the stack.
0136   827A 03          	INC	BC			;
0137   827B 67          	LD	H,A			;
0138   827C C3 4D 82    	JP	NEXTS1			;Save & NEXT
0139   827F             
0140   827F             
0141   827F             W_EXECUTE:				;Jump to address on stack
0142   827F 874558454355	.BYTE	87h,"EXECUT",'E'+80h
0142   8285 54C5
0143   8287 6E 82       	.WORD	W_LIT
0144   8289             C_EXECUTE:
0145   8289 8B 82       	.WORD	2+$			;Vector to code
0146   828B E1          	POP	HL			;Get addr off data stack
0147   828C C3 69 82    	JP	NEXTADDR		;Basically JP (HL)
0148   828F             
0149   828F             
0150   828F             W_BRANCH:				;Add following offset to BC
0151   828F 864252414E43	.BYTE	86h,"BRANC",'H'+80h
0151   8295 C8
0152   8296 7F 82       	.WORD	W_EXECUTE
0153   8298             C_BRANCH:
0154   8298 9A 82       	.WORD	2+$			;Vector to code
0155   829A             X_BRANCH:
0156   829A 60          	LD	H,B			;Next pointer into HL
0157   829B 69          	LD	L,C			;
0158   829C 5E          	LD	E,(HL)			;Get word offset LD DE,(HL)
0159   829D 23          	INC	HL			;Incr to point at next byte
0160   829E 56          	LD	D,(HL)			;
0161   829F 2B          	DEC	HL 			;Restore HL
0162   82A0 19          	ADD	HL,DE			;Calculate new address
0163   82A1 4D          	LD	C,L			;Put it in BC
0164   82A2 44          	LD	B,H			;
0165   82A3 C3 4E 82    	JP	NEXT			;Go do it
0166   82A6             
0167   82A6             W_0BRANCH:				;Add offset to BC if stack top = 0
0168   82A6 87304252414E	.BYTE	87h,"0BRANC",'H'+80h	;Conditional branch
0168   82AC 43C8
0169   82AE 8F 82       	.WORD	W_BRANCH
0170   82B0             C_0BRANCH:
0171   82B0 B2 82       	.WORD	2+$			;Vector to code
0172   82B2 E1          	POP	HL			;Get value off stack
0173   82B3 7D          	LD	A,L			;Set flags
0174   82B4 B4          	OR	H			;
0175   82B5 28 E3       	JR	Z,X_BRANCH		;If zero then do the branch
0176   82B7 03          	INC	BC			;Else dump branch address
0177   82B8 03          	INC	BC			;
0178   82B9 C3 4E 82    	JP	NEXT			;Continue execution
0179   82BC             
0180   82BC             W_LLOOP:				;Increment loop & branch if not done
0181   82BC 863C4C4F4F50	.BYTE	86h,"<LOOP",'>'+80h
0181   82C2 BE
0182   82C3 A6 82       	.WORD	W_0BRANCH
0183   82C5             C_LLOOP:
0184   82C5 C7 82       	.WORD	2+$			;Vector to code
0185   82C7 11 01 00    	LD	DE,0001
0186   82CA             C_ILOOP:
0187   82CA 2A 46 FE    	LD	HL,(RPP)		;Get return stack pointer
0188   82CD 7E          	LD	A,(HL)			;Add DE to value on return stack
0189   82CE 83          	ADD	A,E			;
0190   82CF 77          	LD	(HL),A			;
0191   82D0 5F          	LD	E,A			;
0192   82D1 23          	INC	HL			;
0193   82D2 7E          	LD	A,(HL)			;
0194   82D3 8A          	ADC	A,D			;
0195   82D4 77          	LD	(HL),A			;
0196   82D5 23          	INC	HL			;HL now points to limit value
0197   82D6 14          	INC	D			;Get DS sign bit
0198   82D7 15          	DEC	D			;
0199   82D8 57          	LD	D,A			;Result now in DE
0200   82D9 FA E3 82    	JP	M,DECR_LOOP		;Decrement loop so check > limit
0201   82DC             					;otherwies check < limit
0202   82DC 7B          	LD	A,E			;Low byte back
0203   82DD 96          	SUB	(HL)			;Subtract limit low
0204   82DE 7A          	LD	A,D			;High byte back
0205   82DF 23          	INC	HL			;Point to limit high
0206   82E0 9E          	SBC	A,(HL)			;Subtract it
0207   82E1 18 05       	JR	TEST_LIMIT		;
0208   82E3             DECR_LOOP:
0209   82E3 7E          	LD	A,(HL)			;Get limit low
0210   82E4 93          	SUB	E			;Subtract index low
0211   82E5 23          	INC	HL			;Point to limit high
0212   82E6 7E          	LD	A,(HL)			;Get it
0213   82E7 9A          	SBC	A,D			;Subtract index high
0214   82E8             TEST_LIMIT:
0215   82E8 FA 9A 82    	JP	M,X_BRANCH		;Not reached limit so jump
0216   82EB 23          	INC	HL			;Drop index & limit from return stack
0217   82EC 22 46 FE    	LD	(RPP),HL		;Save stack pointer
0218   82EF 03          	INC	BC			;Skip branch offset
0219   82F0 03          	INC	BC			;
0220   82F1 C3 4E 82    	JP	NEXT
0221   82F4             
0222   82F4             W_PLOOP:				;Loop + stack & branch if not done
0223   82F4 873C2B4C4F4F	.BYTE	87h,"<+LOOP",'>'+80h
0223   82FA 50BE
0224   82FC BC 82       	.WORD	W_LLOOP
0225   82FE             C_PLOOP:
0226   82FE 00 83       	.WORD	2+$			;Vector to code
0227   8300 D1          	POP	DE			;Get value from stack
0228   8301 18 C7       	JR	C_ILOOP			;Go do loop increment
0229   8303             
0230   8303             W_LDO:					;Put start & end loop values on RPP
0231   8303 843C444FBE  	.BYTE	84h,"<DO",'>'+80h
0232   8308 F4 82       	.WORD	 W_PLOOP
0233   830A             C_LDO:
0234   830A 0C 83       	.WORD	 2+$
0235   830C 2A 46 FE    	LD	HL,(RPP)		;Get return stack pointer
0236   830F 2B          	DEC	HL			;Add space for two values
0237   8310 2B          	DEC	HL			;
0238   8311 2B          	DEC	HL			;
0239   8312 2B          	DEC	HL			;
0240   8313 22 46 FE    	LD	(RPP),HL		;Save new stack pointer
0241   8316 D1          	POP	DE			;Get start value &
0242   8317 73          	LD	(HL),E			;put on return stack top
0243   8318 23          	INC	HL			;
0244   8319 72          	LD	(HL),D			;
0245   831A 23          	INC	HL			;
0246   831B D1          	POP	DE			;Get end value &
0247   831C 73          	LD	(HL),E			;put on return stack - 1
0248   831D 23          	INC	HL			;
0249   831E 72          	LD	(HL),D			;
0250   831F C3 4E 82    	JP	NEXT
0251   8322             
0252   8322             W_I:					;Copy LOOP index to data stack
0253   8322 81 C9       	.BYTE	81h,'I'+80h
0254   8324 03 83       	.WORD	 W_LDO
0255   8326             C_I:
0256   8326 28 83       	.WORD	 2+$
0257   8328             X_I:
0258   8328 2A 46 FE    	LD	HL,(RPP)		;Get return stack pointer
0259   832B             X_I2:
0260   832B 5E          	LD	E,(HL)			;Get LOOP index off return stack
0261   832C 23          	INC	HL			;
0262   832D 56          	LD	D,(HL)			;
0263   832E D5          	PUSH	DE			;Push onto data stack
0264   832F C3 4E 82    	JP	NEXT
0265   8332             
0266   8332             W_DIGIT:				;Convert digit n2 using base n1
0267   8332 8544494749D4	.BYTE	85h,"DIGI",'T'+80h
0268   8338 22 83       	.WORD	 W_I
0269   833A             C_DIGIT:
0270   833A 3C 83       	.WORD	2+$
0271   833C E1          	POP	HL			;Get base to use
0272   833D D1          	POP	DE			;Get char
0273   833E 7B          	LD	A,E			;A = char
0274   833F D6 30       	SUB	30h			;Subtract 30h
0275   8341 FA 5B 83    	JP	M,NDIGIT		;
0276   8344 FE 0A       	CP	0Ah			;Greater than 9 ?
0277   8346 FA 50 83    	JP	M,LESS10		;If not then skip
0278   8349 D6 07       	SUB	07h			;Convert 'A' to 10
0279   834B FE 0A       	CP	0Ah			;Is it 10?
0280   834D FA 5B 83    	JP	M,NDIGIT		;If not an error occured
0281   8350             LESS10:
0282   8350 BD          	CP	L			;L is 1 digit limit
0283   8351 F2 5B 83    	JP	P,NDIGIT		;Out of range for digit
0284   8354 5F          	LD	E,A			;Result into DE
0285   8355 21 01 00    	LD	HL,0001			;Leave TRUE flag
0286   8358 C3 4C 82    	JP	NEXTS2			;Save both & NEXT
0287   835B             NDIGIT:
0288   835B 6C          	LD	L,H			;Leave FALSE flag
0289   835C C3 4D 82    	JP	NEXTS1			;Save & NEXT
0290   835F             
0291   835F             W_FIND:					;Find word & return vector,byte & flag
0292   835F 863C46494E44	.BYTE	86h,"<FIND",'>'+80h
0292   8365 BE
0293   8366 32 83       	.WORD	W_DIGIT
0294   8368             C_FIND:
0295   8368 6A 83       	.WORD	2+$			;Vector to code
0296   836A D1          	POP	DE			;Get pointer to next vocabulary word
0297   836B             COMPARE:
0298   836B E1          	POP	HL			;Copy pointer to word we're looking 4
0299   836C E5          	PUSH	HL			;
0300   836D 1A          	LD	A,(DE)			;Get 1st vocabulary word letter
0301   836E AE          	XOR	(HL)			;Compare with what we've got
0302   836F E6 3F       	AND	3Fh			;Ignore start flag
0303   8371 20 1F       	JR	NZ,NOT_END_CHR		;No match so skip to next word
0304   8373             MATCH_NO_END:
0305   8373 23          	INC	HL			;Compare next chr
0306   8374 13          	INC	DE			;
0307   8375 1A          	LD	A,(DE)			;
0308   8376 AE          	XOR	(HL)			;
0309   8377 87          	ADD	A,A			;Move bit 7 to C flag
0310   8378 20 16       	JR	NZ,NO_MATCH		;No match jump
0311   837A 30 F7       	JR	NC,MATCH_NO_END		;Match & not last, so next chr
0312   837C 21 05 00    	LD	HL,0005			;Offset to start of code
0313   837F 19          	ADD	HL,DE			;HL now points to code start for word
0314   8380 E3          	EX	(SP),HL			;Swap with value on stack
0315   8381             NOT_WORD_BYTE:
0316   8381 1B          	DEC	DE			;Search back for word type byte
0317   8382 1A          	LD	A,(DE)			;
0318   8383 B7          	OR	A			;
0319   8384 F2 81 83    	JP	P,NOT_WORD_BYTE		;Not yet so loop
0320   8387 5F          	LD	E,A			;Byte into DE
0321   8388 16 00       	LD	D,00			;
0322   838A 21 01 00    	LD	HL,0001			;Leave TRUE flag
0323   838D C3 4C 82    	JP	NEXTS2			;Save both & NEXT
0324   8390             NO_MATCH:
0325   8390 38 06       	JR	C,END_CHR		;If last chr then jump
0326   8392             NOT_END_CHR:
0327   8392 13          	INC	DE			;Next chr of this vocab word
0328   8393 1A          	LD	A,(DE)			;Get it
0329   8394 B7          	OR	A			;Set flags
0330   8395 F2 92 83    	JP	P,NOT_END_CHR		;Loop if not end chr
0331   8398             END_CHR:
0332   8398 13          	INC	DE			;Now points to next word vector
0333   8399 EB          	EX	DE,HL			;Swap
0334   839A 5E          	LD	E,(HL)			;Vector into DE
0335   839B 23          	INC	HL			;
0336   839C 56          	LD	D,(HL)			;
0337   839D 7A          	LD	A,D			;Check it's not last (first) word
0338   839E B3          	OR	E			;
0339   839F 20 CA       	JR	NZ,COMPARE		;No error so loop
0340   83A1 E1          	POP	HL			;Dump pointer
0341   83A2 21 00 00    	LD	HL,0000			;Flag error
0342   83A5 C3 4D 82    	JP	NEXTS1			;Save & NEXT
0343   83A8             
0344   83A8             W_ENCLOSE:
0345   83A8 87454E434C4F	.BYTE	87h,"ENCLOS",'E'+80h
0345   83AE 53C5
0346   83B0 5F 83       	.WORD	W_FIND
0347   83B2             C_ENCLOSE:
0348   83B2 B4 83       	.WORD	2+$			;Vector to code
0349   83B4 D1          	POP	DE			; get delimiter character
0350   83B5 E1          	POP	HL			; get address 1
0351   83B6 E5          	PUSH	HL			; duplicate it
0352   83B7 7B          	LD	A,E			; delimiter char into A
0353   83B8 57          	LD	D,A			; copy to D
0354   83B9 1E FF       	LD	E,00FFh			; -1 for offset
0355   83BB 2B          	DEC	HL			; to allow for first INCR
0356   83BC             J21E6:
0357   83BC 23          	INC	HL			; point to next chr
0358   83BD 1C          	INC	E			; next offset
0359   83BE BE          	CP	(HL)			; compare chr with (address)
0360   83BF 28 FB       	JR	Z,J21E6			; loop if = delimiter chr
0361   83C1 3E 0D       	LD	A,0Dh			; else set CR
0362   83C3 BE          	CP	(HL)			; compare with (address)
0363   83C4 7A          	LD	A,D			; restore delimiter chr
0364   83C5 28 F5       	JR	Z,J21E6			; loop if it was = CR
0365   83C7 16 00       	LD	D,00h			; zero high byte
0366   83C9 D5          	PUSH	DE			; save offset
0367   83CA 57          	LD	D,A			; restore delimiter chr
0368   83CB 7E          	LD	A,(HL)			; get byte from address
0369   83CC A7          	AND	A			; set the flags
0370   83CD 20 09       	JR	NZ,J2202		; branch if not null
0371   83CF 16 00       	LD	D,00h			; clear high byte
0372   83D1 1C          	INC	E			; point to next addr
0373   83D2 D5          	PUSH	DE			; save address
0374   83D3 1D          	DEC	E			; point to end
0375   83D4 D5          	PUSH	DE			; push address
0376   83D5 C3 4E 82    	JP	NEXT			; done
0377   83D8             J2202:
0378   83D8 7A          	LD	A,D			; restore delimiter chr
0379   83D9 23          	INC	HL			; increment address
0380   83DA 1C          	INC	E			; increment offset
0381   83DB BE          	CP	(HL)			; compare delimiter with (address)
0382   83DC 28 10       	JR	Z,J2218			; jump if =
0383   83DE 3E 0D       	LD	A,0Dh			; else get CR
0384   83E0 BE          	CP	(HL)			; compare with (address)
0385   83E1 28 0B       	JR	Z,J2218			; jump if =
0386   83E3 7E          	LD	A,(HL)			; else get byte
0387   83E4 A7          	AND	A			; set the flags
0388   83E5 20 F1       	JR	NZ,J2202		; loop if not null
0389   83E7 16 00       	LD	D,00h			; clear gigh byte
0390   83E9 D5          	PUSH	DE			; save address
0391   83EA D5          	PUSH	DE			; save address
0392   83EB C3 4E 82    	JP	NEXT			; done
0393   83EE             J2218:
0394   83EE 16 00       	LD	D,00h			; clear high byte
0395   83F0 D5          	PUSH	DE			; save address
0396   83F1 1C          	INC	E			; increment offset
0397   83F2 D5          	PUSH	DE			; save address
0398   83F3 C3 4E 82    	JP	NEXT			; done
0399   83F6             
0400   83F6             W_EMIT:					;Output CHR from stack
0401   83F6 84454D49D4  	.BYTE	84h,"EMI",'T'+80h
0402   83FB A8 83       	.WORD	W_ENCLOSE
0403   83FD             C_EMIT:
0404   83FD 64 87       	.WORD	E_COLON			;Interpret following word sequence
0405   83FF A4 89       	.WORD	C_UEMIT			;Put UEMIT addr on stack
0406   8401 EA 86       	.WORD	C_FETCH			;Get UEMIT code field address
0407   8403 89 82       	.WORD	C_EXECUTE		;Jump to address on stack
0408   8405 E3 87       	.WORD	C_1
0409   8407 C2 88       	.WORD	C_OUT
0410   8409 C5 86       	.WORD	C_PLUSSTORE
0411   840B 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
0412   840D             
0413   840D             W_KEY:					;Wait for key, value on stack
0414   840D 83 4B 45 D9 	.BYTE	83h,"KE",'Y'+80h
0415   8411 F6 83       	.WORD	W_EMIT
0416   8413             C_KEY:
0417   8413 15 84       	.WORD	2+$			;Vector to code
0418   8415 2A 52 FE    	LD	HL,(UKEY)		;Get the vector
0419   8418 E9          	JP	(HL)			;Jump to it
0420   8419             
0421   8419             W_TERMINAL:
0422   8419 893F5445524D	.BYTE	89h,"?TERMINA",'L'+80h
0422   841F 494E41CC
0423   8423 0D 84       	.WORD	W_KEY
0424   8425             C_TERMINAL:
0425   8425 64 87       	.WORD	E_COLON			;Interpret following word sequence
0426   8427 8D 89       	.WORD	C_UTERMINAL
0427   8429 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
0428   842B 89 82       	.WORD	C_EXECUTE		;Jump to address on stack
0429   842D 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
0430   842F             
0431   842F             W_CR:					    ;Output [CR][LF]
0432   842F 82 43 D2    	.BYTE	82h,'C','R'+80h
0433   8432 19 84       	.WORD	W_TERMINAL
0434   8434             C_CR:
0435   8434 64 87       	.WORD	E_COLON			;Interpret following word sequence
0436   8436 AE 89       	.WORD	C_UCR			;Push UCR addr
0437   8438 EA 86       	.WORD	C_FETCH			;Get UCR code field addr
0438   843A 89 82       	.WORD	C_EXECUTE		;Jump to address on stack
0439   843C 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
0440   843E             
0441   843E             W_CLS:					    ;Clear screen
0442   843E 83 43 4C D3 	.BYTE	83h,"CL",'S'+80h
0443   8442 2F 84       	.WORD	W_CR
0444   8444             C_CLS:
0445   8444 64 87       	.WORD	E_COLON			;Interpret following word sequence
0446   8446 74 82       	.WORD	C_LIT			;Put clear screen code on stack
0447   8448 0C 00       	.WORD	000Ch			;
0448   844A FD 83       	.WORD	C_EMIT			;Output it
0449   844C 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
0450   844E             
0451   844E             W_CMOVE:				;Move block
0452   844E 85434D4F56C5	.BYTE	85h,"CMOV",'E'+80h
0453   8454 3E 84       	.WORD	W_CLS
0454   8456             C_CMOVE:
0455   8456 58 84       	.WORD	2+$			;Vector to code
0456   8458 69          	LD	L,C			;Save BC for now
0457   8459 60          	LD	H,B			;
0458   845A C1          	POP	BC			;Get no. of bytes to move
0459   845B D1          	POP	DE			;Get destination address
0460   845C E3          	EX	(SP),HL			;Get source address
0461   845D 78          	LD	A,B			;Check it's not a 0 length block
0462   845E B1          	OR	C			;
0463   845F 28 02       	JR	Z,NO_BYTES		;If 0 length then do nothing
0464   8461 ED B0       	LDIR				;Move block
0465   8463             NO_BYTES:
0466   8463 C1          	POP	BC			;Get BC back
0467   8464 C3 4E 82    	JP	NEXT
0468   8467             
0469   8467             W_USTAR:				;Unsigned multiply
0470   8467 82 55 AA    	.BYTE	82h,'U','*'+80h
0471   846A 4E 84       	.WORD	W_CMOVE
0472   846C             C_USTAR:
0473   846C 6E 84       	.WORD	2+$			;Vector to code
0474   846E D1          	POP	DE			; get n2
0475   846F E1          	POP	HL			; get n1
0476   8470 C5          	PUSH	BC			; save BC for now
0477   8471 4C          	LD	C,H			; save H
0478   8472 7D          	LD	A,L			; low byte to multiply by
0479   8473 CD 8A 84    	CALL	HALF_TIMES		; HL = A * DE
0480   8476 E5          	PUSH	HL			; save partial result
0481   8477 67          	LD	H,A			; clear H
0482   8478 79          	LD	A,C			; high byte to multiply by
0483   8479 4C          	LD	C,H			; clear B
0484   847A CD 8A 84    	CALL	HALF_TIMES		; HL = A * DE
0485   847D D1          	POP	DE			; get last partial result
0486   847E 41          	LD	B,C			; add partial results
0487   847F 4A          	LD	C,D			; add partial results
0488   8480 09          	ADD	HL,BC			;
0489   8481 CE 00       	ADC	A,00h			;
0490   8483 55          	LD	D,L			;
0491   8484 6C          	LD	L,H			;
0492   8485 67          	LD	H,A			;
0493   8486 C1          	POP	BC			; get BC back
0494   8487 C3 4C 82    	JP	NEXTS2			; save 32 bit result & NEXT
0495   848A             
0496   848A             HALF_TIMES:				;
0497   848A 21 00 00    	LD	HL,0000h		; clear partial result
0498   848D 06 08       	LD	B,08h			; eight bits to do
0499   848F             NEXT_BIT:
0500   848F 29          	ADD	HL,HL			; result * 2
0501   8490 17          	RLA				; multiply bit into C
0502   8491 30 03       	JR	NC,NO_MUL		; branch if no multiply
0503   8493 19          	ADD	HL,DE			; add multiplicand
0504   8494 CE 00       	ADC	A,00h			; add in any carry
0505   8496             NO_MUL:
0506   8496 10 F7       	DJNZ	NEXT_BIT		; decr and loop if not done
0507   8498 C9          	RET				;
0508   8499             
0509   8499             W_UMOD:					;Unsigned divide & MOD
0510   8499 85552F4D4FC4	.BYTE	85h,"U/MO",'D'+80h
0511   849F 67 84       	.WORD	W_USTAR
0512   84A1             C_UMOD:
0513   84A1 A3 84       	.WORD	2+$			;Vector to code
0514   84A3 21 04 00    	LD	HL,0004
0515   84A6 39          	ADD	HL,SP
0516   84A7 5E          	LD	E,(HL)
0517   84A8 71          	LD	(HL),C
0518   84A9 23          	INC	HL
0519   84AA 56          	LD	D,(HL)
0520   84AB 70          	LD	(HL),B
0521   84AC C1          	POP	BC
0522   84AD E1          	POP	HL
0523   84AE 7D          	LD	A,L
0524   84AF 91          	SUB	C
0525   84B0 7C          	LD	A,H
0526   84B1 98          	SBC	A,B
0527   84B2 38 08       	JR	C,J22.BYTE
0528   84B4 21 FF FF    	LD	HL,0FFFFh
0529   84B7 11 FF FF    	LD	DE,0FFFFh
0530   84BA 18 26       	JR	J2301
0531   84BC             J22.BYTE:
0532   84BC 3E 10       	LD	A,10h
0533   84BE             J22DD:
0534   84BE 29          	ADD	HL,HL
0535   84BF 17          	RLA
0536   84C0 EB          	EX	DE,HL
0537   84C1 29          	ADD	HL,HL
0538   84C2 30 02       	JR	NC,J22E5
0539   84C4 13          	INC	DE
0540   84C5 A7          	AND	A
0541   84C6             J22E5:
0542   84C6 EB          	EX	DE,HL
0543   84C7 1F          	RRA
0544   84C8 F5          	PUSH	AF
0545   84C9 30 08       	JR	NC,J22F2
0546   84CB 7D          	LD	A,L
0547   84CC 91          	SUB	C
0548   84CD 6F          	LD	L,A
0549   84CE 7C          	LD	A,H
0550   84CF 98          	SBC	A,B
0551   84D0 67          	LD	H,A
0552   84D1 18 0A       	JR	J22FC
0553   84D3             J22F2:
0554   84D3 7D          	LD	A,L
0555   84D4 91          	SUB	C
0556   84D5 6F          	LD	L,A
0557   84D6 7C          	LD	A,H
0558   84D7 98          	SBC	A,B
0559   84D8 67          	LD	H,A
0560   84D9 30 02       	JR	NC,J22FC
0561   84DB 09          	ADD	HL,BC
0562   84DC 1B          	DEC	DE
0563   84DD             J22FC:
0564   84DD 13          	INC	DE
0565   84DE F1          	POP	AF
0566   84DF 3D          	DEC	A
0567   84E0 20 DC       	JR	NZ,J22DD
0568   84E2             J2301:
0569   84E2 C1          	POP	BC
0570   84E3 E5          	PUSH	HL
0571   84E4 D5          	PUSH	DE
0572   84E5 C3 4E 82    	JP	NEXT
0573   84E8             
0574   84E8             W_AND:					;AND
0575   84E8 83 41 4E C4 	.BYTE	83h,"AN",'D'+80h
0576   84EC 99 84       	.WORD	W_UMOD
0577   84EE             C_AND:
0578   84EE F0 84       	.WORD	2+$			;Vector to code
0579   84F0 D1          	POP	DE			;Get n1 off stack
0580   84F1 E1          	POP	HL			;Get n2 off stack
0581   84F2 7B          	LD	A,E			;AND lo bytes
0582   84F3 A5          	AND	L			;
0583   84F4 6F          	LD	L,A			;Result in L
0584   84F5 7A          	LD	A,D			;AND hi bytes
0585   84F6 A4          	AND	H			;
0586   84F7 67          	LD	H,A			;Result in H
0587   84F8 C3 4D 82    	JP	NEXTS1			;Save & next
0588   84FB             
0589   84FB             W_OR:					;OR
0590   84FB 82 4F D2    	.BYTE	82h,'O','R'+80h
0591   84FE E8 84       	.WORD	W_AND
0592   8500             C_OR:
0593   8500 02 85       	.WORD	2+$			;Vector to code
0594   8502 D1          	POP	DE			;Get n1 off stack
0595   8503 E1          	POP	HL			;Get n2 off stack
0596   8504 7B          	LD	A,E			;OR lo bytes
0597   8505 B5          	OR	L			;
0598   8506 6F          	LD	L,A			;Result in L
0599   8507 7A          	LD	A,D			;OR hi bytes
0600   8508 B4          	OR	H			;
0601   8509 67          	LD	H,A			;Result in H
0602   850A C3 4D 82    	JP	NEXTS1			;Save & next
0603   850D             
0604   850D             W_XOR:					;XOR
0605   850D 83 58 4F D2 	.BYTE	83h,"XO",'R'+80h
0606   8511 FB 84       	.WORD	W_OR
0607   8513             C_XOR:
0608   8513 15 85       	.WORD	2+$			;Vector to code
0609   8515 D1          	POP	DE			;Get n1 off stack
0610   8516 E1          	POP	HL			;Get n2 off stack
0611   8517 7B          	LD	A,E			;XOR lo bytes
0612   8518 AD          	XOR	L			;
0613   8519 6F          	LD	L,A			;Result in L
0614   851A 7A          	LD	A,D			;XOR hi bytes
0615   851B AC          	XOR	H			;
0616   851C 67          	LD	H,A			;Result in H
0617   851D C3 4D 82    	JP	NEXTS1			;Save & NEXT
0618   8520             
0619   8520             W_SPFETCH:				;Stack pointer onto stack
0620   8520 83 53 50 C0 	.BYTE	83h,"SP",'@'+80h
0621   8524 0D 85       	.WORD	W_XOR
0622   8526             C_SPFETCH:
0623   8526 28 85       	.WORD	2+$			;Vector to code
0624   8528 21 00 00    	LD	HL,0000			;No offset
0625   852B 39          	ADD	HL,SP			;Add SP to HL
0626   852C C3 4D 82    	JP	NEXTS1			;Save & NEXT
0627   852F             
0628   852F             W_SPSTORE:				;Set initial stack pointer value
0629   852F 83 53 50 A1 	.BYTE	83h,"SP",'!'+80h
0630   8533 20 85       	.WORD	W_SPFETCH
0631   8535             C_SPSTORE:
0632   8535 37 85       	.WORD	2+$			;Vector to code
0633   8537 2A 0A 82    	LD	HL,(DEF_SYSADDR)	;Get system base addr
0634   853A 11 06 00    	LD	DE,S0-SYSTEM		;Offset to stack pointer value (0006)
0635   853D 19          	ADD	HL,DE			;Add to base addr
0636   853E 5E          	LD	E,(HL)			;Get SP from ram
0637   853F 23          	INC	HL			;
0638   8540 56          	LD	D,(HL)			;
0639   8541 EB          	EX	DE,HL			;Put into HL
0640   8542 F9          	LD	SP,HL			;Set SP
0641   8543 C3 4E 82    	JP	NEXT
0642   8546             
0643   8546             W_RPFETCH:				;Get return stack pointer
0644   8546 83 52 50 C0 	.BYTE	83h,"RP",'@'+80h
0645   854A 2F 85       	.WORD	W_SPSTORE
0646   854C             C_RPFETCH:
0647   854C 4E 85       	.WORD	2+$			;Vector to code
0648   854E 2A 46 FE    	LD	HL,(RPP)		;Return stack pointer into HL
0649   8551 C3 4D 82    	JP	NEXTS1			;Save & NEXT
0650   8554             
0651   8554             W_RPSTORE:				;Set initial return stack pointer
0652   8554 83 52 50 A1 	.BYTE	83h,"RP",'!'+80h
0653   8558 46 85       	.WORD	W_RPFETCH
0654   855A             C_RPSTORE:
0655   855A 5C 85       	.WORD	2+$			;Vector to code
0656   855C 2A 0A 82    	LD	HL,(DEF_SYSADDR)	;Get system base addr
0657   855F 11 08 00    	LD	DE,0008			;Offset to return stack pointer value
0658   8562 19          	ADD	HL,DE			;Add to base addr
0659   8563 5E          	LD	E,(HL)			;Get SP from ram
0660   8564 23          	INC	HL			;
0661   8565 56          	LD	D,(HL)			;
0662   8566 EB          	EX	DE,HL			;Put into HL
0663   8567 22 46 FE    	LD	(RPP),HL		;Set return SP
0664   856A C3 4E 82    	JP	NEXT
0665   856D             
0666   856D             W_STOP:					;Pop BC from return stack (=next)
0667   856D 82 3B D3    	.BYTE	82h,';','S'+80h
0668   8570 54 85       	.WORD	W_RPSTORE
0669   8572             C_STOP:
0670   8572 74 85       	.WORD	2+$			;Vector to code
0671   8574             X_STOP:
0672   8574 2A 46 FE    	LD	HL,(RPP)		;Return stack pointer to HL
0673   8577 4E          	LD	C,(HL)			;Get low byte
0674   8578 23          	INC	HL			;
0675   8579 46          	LD	B,(HL)			;Get high byte
0676   857A 23          	INC	HL			;
0677   857B 22 46 FE    	LD	(RPP),HL		;Save stack pointer
0678   857E C3 4E 82    	JP	NEXT
0679   8581             
0680   8581             W_LEAVE:				;Quit loop by making index = limit
0681   8581 854C454156C5	.BYTE	85h,"LEAV",'E'+80h
0682   8587 6D 85       	.WORD	W_STOP
0683   8589             C_LEAVE:
0684   8589 8B 85       	.WORD	2+$			;Vector to code
0685   858B 2A 46 FE    	LD	HL,(RPP)		;Get return stack pointer
0686   858E 5E          	LD	E,(HL)			;Get loop limit low
0687   858F 23          	INC	HL			;
0688   8590 56          	LD	D,(HL)			;Get loop limit high
0689   8591 23          	INC	HL			;
0690   8592 73          	LD	(HL),E			;Set index low to loop limit
0691   8593 23          	INC	HL			;
0692   8594 72          	LD	(HL),D			;Set index high to loop limit
0693   8595 C3 4E 82    	JP	NEXT
0694   8598             
0695   8598             W_MOVER:				;Move from data to return stack
0696   8598 82 3E D2    	.BYTE	82h,'>','R'+80h
0697   859B 81 85       	.WORD	W_LEAVE
0698   859D             C_MOVER:
0699   859D 9F 85       	.WORD	2+$			;Vector to code
0700   859F D1          	POP	DE			;Get value
0701   85A0 2A 46 FE    	LD	HL,(RPP)		;Get return stack pointer
0702   85A3 2B          	DEC	HL			;Set new value
0703   85A4 2B          	DEC	HL			;
0704   85A5 22 46 FE    	LD	(RPP),HL		;Save it
0705   85A8 73          	LD	(HL),E			;Push low byte onto return stack
0706   85A9 23          	INC	HL			;
0707   85AA 72          	LD	(HL),D			;Push high byte onto return stack
0708   85AB C3 4E 82    	JP	NEXT
0709   85AE             
0710   85AE             W_RMOVE:				;Move word from return to data stack
0711   85AE 82 52 BE    	.BYTE	82h,'R','>'+80h
0712   85B1 98 85       	.WORD	W_MOVER
0713   85B3             C_RMOVE:
0714   85B3 B5 85       	.WORD	2+$			;Vector to code
0715   85B5 2A 46 FE    	LD	HL,(RPP)		;Get return stack pointer
0716   85B8 5E          	LD	E,(HL)			;Pop word off return stack
0717   85B9 23          	INC	HL			;
0718   85BA 56          	LD	D,(HL)			;
0719   85BB 23          	INC	HL			;
0720   85BC 22 46 FE    	LD	(RPP),HL		;Save new return stack pointer
0721   85BF D5          	PUSH	DE			;Push on data stack
0722   85C0 C3 4E 82    	JP	NEXT
0723   85C3             
0724   85C3             W_RFETCH:				;Return stack top to data stack
0725   85C3 82 52 C0    	.BYTE	82h,'R','@'+80h
0726   85C6 AE 85       	.WORD	W_RMOVE
0727   85C8             C_RFETCH:
0728   85C8 28 83       	.WORD	X_I			;Return stack top to data stack
0729   85CA             
0730   85CA             W_0EQUALS:				;=0
0731   85CA 82 30 BD    	.BYTE	82h,'0','='+80h
0732   85CD C3 85       	.WORD	W_RFETCH
0733   85CF             C_0EQUALS:
0734   85CF D1 85       	.WORD	2+$			;Vector to code
0735   85D1             X_0EQUALS:
0736   85D1 E1          	POP	HL			;Get value from stack
0737   85D2 7D          	LD	A,L			;set flags
0738   85D3 B4          	OR	H			;
0739   85D4 21 00 00    	LD	HL,0000			;Not = 0 flag
0740   85D7 20 01       	JR	NZ,NO_ZERO		;
0741   85D9 23          	INC	HL			;= 0 flag
0742   85DA             NO_ZERO:
0743   85DA C3 4D 82    	JP	NEXTS1			;Save & NEXT
0744   85DD             
0745   85DD             W_NOT:					;Convert flag, same as 0=
0746   85DD 83 4E 4F D4 	.BYTE	83h,"NO",'T'+80h
0747   85E1 CA 85       	.WORD	W_0EQUALS
0748   85E3             C_NOT:
0749   85E3 D1 85       	.WORD	X_0EQUALS
0750   85E5             
0751   85E5             W_0LESS:				;Less than 0
0752   85E5 82 30 BC    	.BYTE	82h,'0','<'+80h
0753   85E8 DD 85       	.WORD	W_NOT
0754   85EA             C_0LESS:
0755   85EA EC 85       	.WORD	2+$			;Vector to code
0756   85EC E1          	POP	HL			;Get value
0757   85ED 29          	ADD	HL,HL			;S bit into C
0758   85EE 21 00 00    	LD	HL,0000			;Wasn't < 0 flag
0759   85F1 30 01       	JR	NC,NOT_LT0		;
0760   85F3 23          	INC	HL			;Was < 0 flag
0761   85F4             NOT_LT0:				;
0762   85F4 C3 4D 82    	JP	NEXTS1			;Save & NEXT
0763   85F7             
0764   85F7             W_PLUS:					;n1 + n2
0765   85F7 81 AB       	.BYTE	81h,'+'+80h
0766   85F9 E5 85       	.WORD	W_0LESS
0767   85FB             C_PLUS:
0768   85FB FD 85       	.WORD	2+$			;Vector to code
0769   85FD D1          	POP	DE			;Get n2
0770   85FE E1          	POP	HL			;Get n1
0771   85FF 19          	ADD	HL,DE			;Add them
0772   8600 C3 4D 82    	JP	NEXTS1			;Save & NEXT
0773   8603             
0774   8603             W_DPLUS:				;32 bit add
0775   8603 82 44 AB    	.BYTE	82h,'D','+'+80h
0776   8606 F7 85       	.WORD	W_PLUS
0777   8608             C_DPLUS:
0778   8608 0A 86       	.WORD	2+$			;Vector to code
0779   860A 21 06 00    	LD	HL,0006			; offset to low word
0780   860D 39          	ADD	HL,SP			; add stack pointer
0781   860E 5E          	LD	E,(HL)			; get d1 low word low byte
0782   860F 71          	LD	(HL),C			; save BC low byte
0783   8610 23          	INC	HL			; point to high byte
0784   8611 56          	LD	D,(HL)			; get d1 low word high byte
0785   8612 70          	LD	(HL),B			; save BC high byte
0786   8613 C1          	POP	BC			; get high word d2
0787   8614 E1          	POP	HL			; get low word d2
0788   8615 19          	ADD	HL,DE			; add low wor.BLOCK
0789   8616 EB          	EX	DE,HL			; save result low word in DE
0790   8617 E1          	POP	HL			; get d1 high word
0791   8618 7D          	LD	A,L			; copy d1 high word low byte
0792   8619 89          	ADC	A,C			; add d2 high word low byte
0793   861A             					; + carry from low word add
0794   861A 6F          	LD	L,A			; result from high word low byte into L
0795   861B 7C          	LD	A,H			; copy d1 high word low byte
0796   861C 88          	ADC	A,B			; add d2 high word low byte
0797   861D             					; + carry from high word low byte add
0798   861D 67          	LD	H,A			; result from high word high byte into H
0799   861E C1          	POP	BC			; restore BC
0800   861F C3 4C 82    	JP	NEXTS2			;Save 32 bit result & NEXT
0801   8622             
0802   8622             W_NEGATE:				;Form 2s complement of n
0803   8622 864E45474154	.BYTE	86h,"NEGAT",'E'+80h
0803   8628 C5
0804   8629 03 86       	.WORD	W_DPLUS
0805   862B             C_NEGATE:
0806   862B 2D 86       	.WORD	2+$			;Vector to code
0807   862D E1          	POP	HL			;Get number
0808   862E 7D          	LD	A,L			;Low byte into A
0809   862F 2F          	CPL				;Complement it
0810   8630 6F          	LD	L,A			;Back into L
0811   8631 7C          	LD	A,H			;High byte into A
0812   8632 2F          	CPL				;Complement it
0813   8633 67          	LD	H,A			;Back into H
0814   8634 23          	INC	HL			;+1
0815   8635 C3 4D 82    	JP	NEXTS1			;Save & NEXT
0816   8638             
0817   8638             W_DNEGATE:				;Form 2s complement of 32 bit n
0818   8638 87444E454741	.BYTE	87h,"DNEGAT",'E'+80h
0818   863E 54C5
0819   8640 22 86       	.WORD	W_NEGATE
0820   8642             C_DNEGATE:
0821   8642 44 86       	.WORD	2+$			;Vector to code
0822   8644 E1          	POP	HL			; get high word
0823   8645 D1          	POP	DE			; get low word
0824   8646 97          	SUB	A			; clear A
0825   8647 93          	SUB	E			; negate low word low byte
0826   8648 5F          	LD	E,A			; copy back to E
0827   8649 3E 00       	LD	A,00h			; clear A
0828   864B 9A          	SBC	A,D			; negate low word high byte
0829   864C 57          	LD	D,A			; copy back to D
0830   864D 3E 00       	LD	A,00h			; clear A
0831   864F 9D          	SBC	A,L			; negate high word low byte
0832   8650 6F          	LD	L,A			; copy back to L
0833   8651 3E 00       	LD	A,00h			; clear A
0834   8653 9C          	SBC	A,H			; negate high word high byte
0835   8654 67          	LD	H,A			; copy back to H
0836   8655 C3 4C 82    	JP	NEXTS2			;Save 32 bit result & NEXT
0837   8658             
0838   8658             W_OVER:					;Copy 2nd down to top of stack
0839   8658 844F5645D2  	.BYTE	84h,"OVE",'R'+80h
0840   865D 38 86       	.WORD	W_DNEGATE
0841   865F             C_OVER:
0842   865F 61 86       	.WORD	2+$			;Vector to code
0843   8661 D1          	POP	DE			;Get top
0844   8662 E1          	POP	HL			;Get next
0845   8663 E5          	PUSH	HL			;Save it back
0846   8664 C3 4C 82    	JP	NEXTS2			;Save both & NEXT
0847   8667             
0848   8667             W_DROP:					;Drop top value from stack
0849   8667 8444524FD0  	.BYTE	84h,"DRO",'P'+80h
0850   866C 58 86       	.WORD	W_OVER
0851   866E             C_DROP:
0852   866E 70 86       	.WORD	2+$			;Vector to code
0853   8670 E1          	POP	HL			;Get top value
0854   8671 C3 4E 82    	JP	NEXT
0855   8674             
0856   8674             W_2DROP:				;Drop top two values from stack
0857   8674 853244524FD0	.BYTE	85h,"2DRO",'P'+80h
0858   867A 67 86       	.WORD	W_DROP
0859   867C             C_2DROP:
0860   867C 7E 86       	.WORD	2+$			;Vector to code
0861   867E E1          	POP	HL			;Get top value
0862   867F E1          	POP	HL			;Get top value
0863   8680 C3 4E 82    	JP	NEXT
0864   8683             
0865   8683             W_SWAP:					;Swap top 2 values on stack
0866   8683 84535741D0  	.BYTE	84h,"SWA",'P'+80h
0867   8688 74 86       	.WORD	W_2DROP
0868   868A             C_SWAP:
0869   868A 8C 86       	.WORD	2+$			;Vector to code
0870   868C E1          	POP	HL			;Get top value
0871   868D E3          	EX	(SP),HL			;Exchanhe with next down
0872   868E C3 4D 82    	JP	NEXTS1			;Save & NEXT
0873   8691             
0874   8691             W_DUP:					;Duplicate top value on stack
0875   8691 83 44 55 D0 	.BYTE	83h,"DU",'P'+80h
0876   8695 83 86       	.WORD	W_SWAP
0877   8697             C_DUP:
0878   8697 99 86       	.WORD	2+$			;Vector to code
0879   8699 E1          	POP	HL			;Get value off stack
0880   869A E5          	PUSH	HL			;Copy it back
0881   869B C3 4D 82    	JP	NEXTS1			;Save & NEXT
0882   869E             
0883   869E             W_2DUP:					;Dup top 2 values on stack
0884   869E 84324455D0  	.BYTE	84h,"2DU",'P'+80h
0885   86A3 91 86       	.WORD	W_DUP
0886   86A5             C_2DUP:
0887   86A5 A7 86       	.WORD	2+$			;Vector to code
0888   86A7 E1          	POP	HL			;Get top two values from stack
0889   86A8 D1          	POP	DE			;
0890   86A9 D5          	PUSH	DE			;Copy them back
0891   86AA E5          	PUSH	HL			;
0892   86AB C3 4C 82    	JP	NEXTS2			;Save both & NEXT
0893   86AE             
0894   86AE             W_BOUNDS:				;Convert address & n to start & end
0895   86AE 86424F554E44	.BYTE	86h,"BOUND",'S'+80h
0895   86B4 D3
0896   86B5 9E 86       	.WORD	W_2DUP
0897   86B7             C_BOUNDS:
0898   86B7 B9 86       	.WORD	2+$			;Vector to code
0899   86B9 E1          	POP	HL			; get n
0900   86BA D1          	POP	DE			; get addr
0901   86BB 19          	ADD	HL,DE			; add addr to n
0902   86BC EB          	EX	DE,HL			; swap them
0903   86BD C3 4C 82    	JP	NEXTS2			; save both & NEXT
0904   86C0             
0905   86C0             W_PLUSSTORE:				;Add n1 to addr
0906   86C0 82 2B A1    	.BYTE	82h,'+','!'+80h
0907   86C3 AE 86       	.WORD	W_BOUNDS
0908   86C5             C_PLUSSTORE:
0909   86C5 C7 86       	.WORD	2+$			;Vector to code
0910   86C7 E1          	POP	HL			;Get addr
0911   86C8 D1          	POP	DE			;Get DE
0912   86C9 7E          	LD	A,(HL)			;Add low bytes
0913   86CA 83          	ADD	A,E			;
0914   86CB 77          	LD	(HL),A			;Store result
0915   86CC 23          	INC	HL			;Point to high byte
0916   86CD 7E          	LD	A,(HL)			;Add high bytes
0917   86CE 8A          	ADC	A,D			;
0918   86CF 77          	LD	(HL),A			;Store result
0919   86D0 C3 4E 82    	JP	NEXT
0920   86D3             
0921   86D3             W_TOGGLE:				;XOR (addr) with byte
0922   86D3 86544F47474C	.BYTE	86h,"TOGGL",'E'+80h
0922   86D9 C5
0923   86DA C0 86       	.WORD	W_PLUSSTORE
0924   86DC             C_TOGGLE:
0925   86DC DE 86       	.WORD	2+$			;Vector to code
0926   86DE D1          	POP	DE			 	;Get byte
0927   86DF E1          	POP	HL				;Get addr
0928   86E0 7E          	LD	A,(HL)			;Get byte from addr
0929   86E1 AB          	XOR	E				;Toggle it
0930   86E2 77          	LD	(HL),A			;Save result
0931   86E3 C3 4E 82    	JP	NEXT
0932   86E6             
0933   86E6             W_FETCH:				;Get word from addr on stack
0934   86E6 81 C0       	.BYTE	81h,'@'+80h
0935   86E8 D3 86       	.WORD	W_TOGGLE
0936   86EA             C_FETCH:
0937   86EA EC 86       	.WORD	2+$			;Vector to code
0938   86EC E1          	POP	HL			;Get addr
0939   86ED 5E          	LD	E,(HL)			;Get low byte
0940   86EE 23          	INC	HL			;
0941   86EF 56          	LD	D,(HL)			;Get high byte
0942   86F0 D5          	PUSH	DE			;Save it
0943   86F1 C3 4E 82    	JP	NEXT
0944   86F4             
0945   86F4             W_CFETCH:				;Get byte from addr on stack
0946   86F4 82 43 C0    	.BYTE	82h,'C','@'+80h
0947   86F7 E6 86       	.WORD	W_FETCH
0948   86F9             C_CFETCH:
0949   86F9 FB 86       	.WORD	2+$			;Vector to code
0950   86FB E1          	POP	HL			;Get addr
0951   86FC 6E          	LD	L,(HL)			;Get byte
0952   86FD 26 00       	LD	H,00h			;Top byte = 0
0953   86FF C3 4D 82    	JP	NEXTS1			;Save & NEXT
0954   8702             
0955   8702             W_2FETCH:				;Get word from addr+2 and addr
0956   8702 82 32 C0    	.BYTE	82h,'2','@'+80h
0957   8705 F4 86       	.WORD	W_CFETCH
0958   8707             C_2FETCH:
0959   8707 09 87       	.WORD	2+$			;Vector to code
0960   8709 E1          	POP	HL			;Get addr
0961   870A 11 02 00    	LD	DE,0002			;Plus 2 bytes
0962   870D 19          	ADD	HL,DE			;Get 2nd word first
0963   870E 5E          	LD	E,(HL)			;Low byte
0964   870F 23          	INC	HL			;
0965   8710 56          	LD	D,(HL)			;High byte
0966   8711 D5          	PUSH	DE			;Save it
0967   8712 11 FD FF    	LD	DE,0FFFDh		;Minus 2 bytes
0968   8715 19          	ADD	HL,DE			;Get 1st word
0969   8716 5E          	LD	E,(HL)			;Low byte
0970   8717 23          	INC	HL			;
0971   8718 56          	LD	D,(HL)			;High byte
0972   8719 D5          	PUSH	DE			;Save it
0973   871A C3 4E 82    	JP	NEXT
0974   871D             
0975   871D             W_STORE:				;Store word at addr
0976   871D 81 A1       	.BYTE	81h,'!'+80h
0977   871F 02 87       	.WORD	W_2FETCH
0978   8721             C_STORE:
0979   8721 23 87       	.WORD	2+$			;Vector to code
0980   8723 E1          	POP	HL			;Get addr
0981   8724 D1          	POP	DE			;Get word
0982   8725 73          	LD	(HL),E			;Store low byte
0983   8726 23          	INC	HL			;
0984   8727 72          	LD	(HL),D			;Store high byte
0985   8728 C3 4E 82    	JP	NEXT
0986   872B             
0987   872B             W_CSTORE:				;Store byte at addr
0988   872B 82 43 A1    	.BYTE	82h,'C','!'+80h
0989   872E 1D 87       	.WORD	W_STORE
0990   8730             C_CSTORE:
0991   8730 32 87       	.WORD	2+$			;Vector to code
0992   8732 E1          	POP	HL			;Get addr
0993   8733 D1          	POP	DE			;Get byte
0994   8734 73          	LD	(HL),E			;Save it
0995   8735 C3 4E 82    	JP	NEXT
0996   8738             
0997   8738             W_2STORE:				;Store 2 words at addr (+2)
0998   8738 82 32 A1    	.BYTE	82h,'2','!'+80h
0999   873B 2B 87       	.WORD	W_CSTORE
1000   873D             C_2STORE:
1001   873D 3F 87       	.WORD	2+$			;Vector to code
1002   873F E1          	POP	HL			;Get addr
1003   8740 D1          	POP	DE			;Get word
1004   8741 73          	LD	(HL),E			;Save low byte
1005   8742 23          	INC	HL			;
1006   8743 72          	LD	(HL),D			;Save high byte
1007   8744 23          	INC	HL			;
1008   8745 D1          	POP	DE			;Get next word
1009   8746 73          	LD	(HL),E			;Save low byte
1010   8747 23          	INC	HL			;
1011   8748 72          	LD	(HL),D			;Save high byte
1012   8749 C3 4E 82    	JP	NEXT
1013   874C             
1014   874C             W_COLON:
1015   874C 81 BA       	.BYTE	81h,':'+80h
1016   874E 38 87       	.WORD	W_2STORE
1017   8750             C_COLON:
1018   8750 64 87       	.WORD	E_COLON			;Interpret following word sequence
1019   8752 BB 8C       	.WORD	C_QEXEC			;Error not if not in execute mode
1020   8754 76 8C       	.WORD	C_CSPSTORE		;Set current stack pointer value
1021   8756 F5 88       	.WORD	C_CURRENT		;Get CURRENT addr
1022   8758 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
1023   875A E7 88       	.WORD	C_CONTEXT		;Make CONTEXT current vocab
1024   875C 21 87       	.WORD	C_STORE			;Store word at addr
1025   875E 5F 91       	.WORD	C_XXX1			;Puts name into dictionary
1026   8760 40 8D       	.WORD	C_RIGHTBRKT		;Set STATE to compile
1027   8762 93 8D       	.WORD	C_CCODE			;Execute following machine code
1028   8764             
1029   8764             E_COLON:
1030   8764 2A 46 FE    	LD	HL,(RPP)		;Get return stack pointer
1031   8767 2B          	DEC	HL			;Put BC on return stack
1032   8768 70          	LD	(HL),B			;
1033   8769 2B          	DEC	HL			;
1034   876A 71          	LD	(HL),C			;
1035   876B 22 46 FE    	LD	(RPP),HL		;Save new pointer
1036   876E 13          	INC	DE
1037   876F 4B          	LD	C,E
1038   8770 42          	LD	B,D
1039   8771 C3 4E 82    	JP	NEXT
1040   8774             
1041   8774             W_SEMICOLON:				;Terminate compilation
1042   8774 C1 BB       	.BYTE	0C1h,';'+80h
1043   8776 4C 87       	.WORD	W_COLON
1044   8778             C_SEMICOLON:
1045   8778 64 87       	.WORD	E_COLON			;Interpret following word sequence
1046   877A A3 8C       	.WORD	C_QCOMP			;Check we're allready compiling
1047   877C E5 8C       	.WORD	C_WHATSTACK		;Check stack pointer, error if not ok
1048   877E 1C 8D       	.WORD	C_COMPILE		;Compile next word into dictionary
1049   8780 72 85       	.WORD	C_STOP			;
1050   8782 55 8D       	.WORD	C_SMUDGE		;Smudge bit to O.K.
1051   8784 32 8D       	.WORD	C_LEFTBRKT		;Set STATE to execute
1052   8786 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1053   8788             
1054   8788             W_CONSTANT:
1055   8788 88434F4E5354	.BYTE	88h,"CONSTAN",'T'+80h
1055   878E 414ED4
1056   8791 74 87       	.WORD	W_SEMICOLON
1057   8793             C_CONSTANT:
1058   8793 64 87       	.WORD	E_COLON			;Interpret following word sequence
1059   8795 5F 91       	.WORD	C_XXX1
1060   8797 55 8D       	.WORD	C_SMUDGE
1061   8799 1B 8B       	.WORD	C_COMMA			;Reserve 2 bytes and save n
1062   879B 93 8D       	.WORD	C_CCODE			;Execute following machine code
1063   879D             
1064   879D             X_CONSTANT:				;Put next word on stack
1065   879D 13          	INC	DE			;Adjust pointer
1066   879E EB          	EX	DE,HL			;Get next word
1067   879F 5E          	LD	E,(HL)			;
1068   87A0 23          	INC	HL			;
1069   87A1 56          	LD	D,(HL)			;
1070   87A2 D5          	PUSH	DE			;Put on stack
1071   87A3 C3 4E 82    	JP	NEXT
1072   87A6             
1073   87A6             W_VARIABLE:
1074   87A6 885641524941	.BYTE	88h,"VARIABL",'E'+80h
1074   87AC 424CC5
1075   87AF 88 87       	.WORD	W_CONSTANT
1076   87B1             C_VARIABLE:
1077   87B1 64 87       	.WORD	E_COLON			;Interpret following word sequence
1078   87B3 DB 87       	.WORD	C_ZERO			;Put zero on stack
1079   87B5 93 87       	.WORD	C_CONSTANT
1080   87B7 93 8D       	.WORD	C_CCODE			;Execute following machine code
1081   87B9             
1082   87B9             X_VARIABLE:
1083   87B9 13          	INC	DE
1084   87BA D5          	PUSH	DE
1085   87BB C3 4E 82    	JP	NEXT
1086   87BE             
1087   87BE             W_USER:
1088   87BE 84555345D2  	.BYTE	84h,"USE",'R'+80h
1089   87C3 A6 87       	.WORD	W_VARIABLE
1090   87C5             C_USER:
1091   87C5 64 87       	.WORD	E_COLON			;Interpret following word sequence
1092   87C7 93 87       	.WORD	C_CONSTANT
1093   87C9 93 8D       	.WORD	C_CCODE			;Execute following machine code
1094   87CB             
1095   87CB             X_USER:
1096   87CB 13          	INC	DE			;Adjust to next word
1097   87CC EB          	EX	DE,HL
1098   87CD 5E          	LD	E,(HL)
1099   87CE 23          	INC	HL
1100   87CF 56          	LD	D,(HL)
1101   87D0 2A 0A 82    	LD	HL,(DEF_SYSADDR)
1102   87D3 19          	ADD	HL,DE
1103   87D4 C3 4D 82    	JP	NEXTS1			;Save & NEXT
1104   87D7             
1105   87D7             W_ZERO:					;Put zero on stack
1106   87D7 81 B0       	.BYTE	81h,'0'+80h
1107   87D9 BE 87       	.WORD	W_USER
1108   87DB             C_ZERO:
1109   87DB 9D 87       	.WORD	X_CONSTANT		;Put next word on stack
1110   87DD 00 00       	.WORD	0000h
1111   87DF             
1112   87DF             W_1:					;Put 1 on stack
1113   87DF 81 B1       	.BYTE	81h,'1'+80h
1114   87E1 D7 87       	.WORD	W_ZERO
1115   87E3             C_1:
1116   87E3 9D 87       	.WORD	X_CONSTANT		;Put next word on stack
1117   87E5 01 00       	.WORD	0001h
1118   87E7             
1119   87E7             W_2:
1120   87E7 81 B2       	.BYTE	81h,'2'+80h
1121   87E9 DF 87       	.WORD	W_1
1122   87EB             C_2:
1123   87EB 9D 87       	.WORD	X_CONSTANT		;Put next word on stack
1124   87ED 02 00       	.WORD	0002h
1125   87EF             
1126   87EF             W_3:
1127   87EF 81 B3       	.BYTE	81h,'3'+80h
1128   87F1 E7 87       	.WORD	W_2
1129   87F3             C_3:
1130   87F3 9D 87       	.WORD	X_CONSTANT		;Put next word on stack
1131   87F5 03 00       	.WORD	0003h
1132   87F7             
1133   87F7             W_BL:					;Leaves ASCII for blank on stack
1134   87F7 82 42 CC    	.BYTE	82h,'B','L'+80h
1135   87FA EF 87       	.WORD	W_3
1136   87FC             C_BL:
1137   87FC 9D 87       	.WORD	X_CONSTANT		;Put next word on stack
1138   87FE 20 00       	.WORD	0020h
1139   8800             
1140   8800             W_CL:
1141   8800 83 43 2F CC 	.BYTE	83h,"C/",'L'+80h
1142   8804 F7 87       	.WORD	W_BL
1143   8806             C_CL:
1144   8806 64 87       	.WORD	E_COLON			;Interpret following word sequence
1145   8808 48 89       	.WORD	C_UCL
1146   880A EA 86       	.WORD	C_FETCH			;Get word from addr on stack
1147   880C 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1148   880E             
1149   880E             W_FIRST:
1150   880E 8546495253D4	.BYTE	85h,"FIRS",'T'+80h
1151   8814 00 88       	.WORD	W_CL
1152   8816             C_FIRST:
1153   8816 64 87       	.WORD	E_COLON			;Interpret following word sequence
1154   8818 55 89       	.WORD	C_UFIRST		;Put UFIRST addr on stack
1155   881A EA 86       	.WORD	C_FETCH			;Get word from addr on stack
1156   881C 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1157   881E             
1158   881E             W_LIMIT:
1159   881E 854C494D49D4	.BYTE	85h,"LIMI",'T'+80h
1160   8824 0E 88       	.WORD	W_FIRST
1161   8826             C_LIMIT:
1162   8826 64 87       	.WORD	E_COLON			;Interpret following word sequence
1163   8828 62 89       	.WORD	C_ULIMIT		;Put ULIMIT on stack
1164   882A EA 86       	.WORD	C_FETCH			;Get word from addr on stack
1165   882C 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1166   882E             
1167   882E             W_BBUF:
1168   882E 85422F4255C6	.BYTE	85h,"B/BU",'F'+80h
1169   8834 1E 88       	.WORD	W_LIMIT
1170   8836             C_BBUF:
1171   8836 64 87       	.WORD	E_COLON			;Interpret following word sequence
1172   8838 6F 89       	.WORD	C_UBBUF
1173   883A EA 86       	.WORD	C_FETCH			;Get word from addr on stack
1174   883C 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1175   883E             
1176   883E             W_BSCR:
1177   883E 85422F5343D2	.BYTE	85h,"B/SC",'R'+80h
1178   8844 2E 88       	.WORD	W_BBUF
1179   8846             C_BSCR:
1180   8846 64 87       	.WORD	E_COLON			;Interpret following word sequence
1181   8848 7C 89       	.WORD	C_UBSCR			;Number of buffers per block
1182   884A EA 86       	.WORD	C_FETCH			;Get word from addr on stack
1183   884C 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1184   884E             
1185   884E             W_S0:					;Push S0 (initial data stack pointer)
1186   884E 82 53 B0    	.BYTE	82h,'S','0'+80h
1187   8851 3E 88       	.WORD	W_BSCR
1188   8853             C_S0:
1189   8853 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1190   8855 06 00       	.WORD	S0-SYSTEM
1191   8857             
1192   8857             W_R0:
1193   8857 82 52 B0    	.BYTE	82h,'R','0'+80h
1194   885A 4E 88       	.WORD	W_S0
1195   885C             C_R0:
1196   885C CB 87       	.WORD	X_USER			;Put next word on stack then do next
1197   885E 08 00       	.WORD	R0-SYSTEM
1198   8860             
1199   8860             W_TIB:
1200   8860 83 54 49 C2 	.BYTE	83h,"TI",'B'+80h
1201   8864 57 88       	.WORD	W_R0
1202   8866             C_TIB:
1203   8866 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1204   8868 0A 00       	.WORD	TIB-SYSTEM
1205   886A             
1206   886A             W_WIDTH:
1207   886A 8557494454C8	.BYTE	85h,"WIDT",'H'+80h
1208   8870 60 88       	.WORD	W_TIB
1209   8872             C_WIDTH:
1210   8872 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1211   8874 0C 00       	.WORD	WIDTH-SYSTEM
1212   8876             
1213   8876             W_WARNING:				;Put WARNING addr on stack
1214   8876 875741524E49	.BYTE	87h,"WARNIN",'G'+80h
1214   887C 4EC7
1215   887E 6A 88       	.WORD	W_WIDTH
1216   8880             C_WARNING:
1217   8880 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1218   8882 0E 00       	.WORD	WARNING-SYSTEM
1219   8884             
1220   8884             W_FENCE:
1221   8884 8546454E43C5	.BYTE	85h,"FENC",'E'+80h
1222   888A 76 88       	  	.WORD	W_WARNING
1223   888C             C_FENCE:
1224   888C CB 87       	.WORD	X_USER			;Put next word on stack then do next
1225   888E 10 00       	.WORD	FENCE-SYSTEM
1226   8890             
1227   8890             W_DP:					;Dictionary pointer addr on stack
1228   8890 82 44 D0    	.BYTE	82h,'D','P'+80h
1229   8893 84 88       	.WORD	W_FENCE
1230   8895             C_DP:
1231   8895 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1232   8897 12 00       	.WORD	DP-SYSTEM
1233   8899             
1234   8899             W_VOC_LINK:
1235   8899 88564F432D4C	.BYTE	88h,"VOC-LIN",'K'+80h
1235   889F 494ECB
1236   88A2 90 88       	.WORD	W_DP
1237   88A4             C_VOC_LINK:
1238   88A4 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1239   88A6 14 00       	.WORD	VOC_LINK-SYSTEM
1240   88A8             
1241   88A8             W_BLK:
1242   88A8 83 42 4C CB 	.BYTE	83h,"BL",'K'+80h
1243   88AC 99 88       	.WORD	W_VOC_LINK
1244   88AE             C_BLK:
1245   88AE CB 87       	.WORD	X_USER			;Put next word on stack then do next
1246   88B0 16 00       	.WORD	BLK-SYSTEM
1247   88B2             
1248   88B2             W_TOIN:
1249   88B2 83 3E 49 CE 	.BYTE	83h,">I",'N'+80h
1250   88B6 A8 88       	.WORD	W_BLK
1251   88B8             C_TOIN:
1252   88B8 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1253   88BA 18 00       	.WORD	TOIN-SYSTEM
1254   88BC             
1255   88BC             W_OUT:					;Put OUT buffer count addr on stack
1256   88BC 83 4F 55 D4 	.BYTE	83h,"OU",'T'+80h
1257   88C0 B2 88       	.WORD	W_TOIN
1258   88C2             C_OUT:
1259   88C2 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1260   88C4 1A 00       	.WORD	OUT-SYSTEM
1261   88C6             
1262   88C6             W_SCR:
1263   88C6 83 53 43 D2 	.BYTE	83h,"SC",'R'+80h
1264   88CA BC 88       	.WORD	W_OUT
1265   88CC             C_SCR:
1266   88CC CB 87       	.WORD	X_USER			;Put next word on stack then do next
1267   88CE 1C 00       	.WORD	SCR-SYSTEM
1268   88D0             
1269   88D0             W_OFFSET:				;Put disk block offset on stack
1270   88D0 864F46465345	.BYTE	86h,"OFFSE",'T'+80h
1270   88D6 D4
1271   88D7 C6 88       	.WORD	W_SCR
1272   88D9             C_OFFSET:
1273   88D9 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1274   88DB 1E 00       	.WORD	OFFSET-SYSTEM
1275   88DD             
1276   88DD             W_CONTEXT:
1277   88DD 87434F4E5445	.BYTE	87h,"CONTEX",'T'+80h
1277   88E3 58D4
1278   88E5 D0 88       	.WORD	W_OFFSET
1279   88E7             C_CONTEXT:
1280   88E7 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1281   88E9 20 00       	.WORD	CONTEXT-SYSTEM
1282   88EB             
1283   88EB             W_CURRENT:
1284   88EB 874355525245	.BYTE	87h,"CURREN",'T'+80h
1284   88F1 4ED4
1285   88F3 DD 88       	.WORD	W_CONTEXT
1286   88F5             C_CURRENT:
1287   88F5 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1288   88F7 22 00       	.WORD	CURRENT-SYSTEM
1289   88F9             
1290   88F9             W_STATE:				;Push STATE addr
1291   88F9 8553544154C5	.BYTE	85h,"STAT",'E'+80h
1292   88FF EB 88       	.WORD	W_CURRENT
1293   8901             C_STATE:
1294   8901 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1295   8903 24 00       	.WORD	STATE-SYSTEM
1296   8905             
1297   8905             W_BASE:					;Put BASE addr on stack
1298   8905 84424153C5  	.BYTE	84h,"BAS",'E'+80h
1299   890A F9 88       	.WORD	W_STATE
1300   890C             C_BASE:
1301   890C CB 87       	.WORD	X_USER			;Put next word on stack then do next
1302   890E 26 00       	.WORD	BASE-SYSTEM
1303   8910             
1304   8910             W_DPL:
1305   8910 83 44 50 CC 	.BYTE	83h,"DP",'L'+80h
1306   8914 05 89       	.WORD	W_BASE
1307   8916             C_DPL:
1308   8916 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1309   8918 28 00       	.WORD	DPL-SYSTEM
1310   891A             
1311   891A             W_FLD:
1312   891A 83 46 4C C4 	.BYTE	83h,"FL",'D'+80h
1313   891E 10 89       	.WORD	W_DPL
1314   8920             C_FLD:
1315   8920 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1316   8922 2A 00       	.WORD	FLD-SYSTEM
1317   8924             
1318   8924             W_CSP:					;Push check stack pointer addr
1319   8924 83 43 53 D0 	.BYTE	83h,"CS",'P'+80h
1320   8928 1A 89       	.WORD	W_FLD
1321   892A             C_CSP:
1322   892A CB 87       	.WORD	X_USER			;Put next word on stack then do next
1323   892C 2C 00       	.WORD	CSP-SYSTEM
1324   892E             
1325   892E             W_RHASH:
1326   892E 82 52 A3    	.BYTE	82h,'R','#'+80h
1327   8931 24 89       	.WORD	W_CSP
1328   8933             C_RHASH:
1329   8933 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1330   8935 2E 00       	.WORD	RHASH-SYSTEM
1331   8937             
1332   8937             W_HLD:
1333   8937 83 48 4C C4 	.BYTE	83h,"HL",'D'+80h
1334   893B 2E 89       	.WORD	W_RHASH
1335   893D             C_HLD:
1336   893D CB 87       	.WORD	X_USER			;Put next word on stack then do next
1337   893F 30 00       	.WORD	HLD-SYSTEM
1338   8941             
1339   8941             W_UCL:
1340   8941 8455432FCC  	.BYTE	84h,"UC/",'L'+80h
1341   8946 37 89       	.WORD	W_HLD
1342   8948             C_UCL:
1343   8948 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1344   894A 5C 00       	.WORD	UCL-SYSTEM
1345   894C             
1346   894C             W_UFIRST:
1347   894C 865546495253	.BYTE	86h,"UFIRS",'T'+80h
1347   8952 D4
1348   8953 41 89       	.WORD	W_UCL
1349   8955             C_UFIRST:
1350   8955 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1351   8957 5E 00       	.WORD	UFIRST-SYSTEM
1352   8959             
1353   8959             W_ULIMIT:
1354   8959 86554C494D49	.BYTE	86h,"ULIMI",'T'+80h
1354   895F D4
1355   8960 4C 89       	.WORD	W_UFIRST
1356   8962             C_ULIMIT:
1357   8962 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1358   8964 60 00       	.WORD	ULIMIT-SYSTEM
1359   8966             
1360   8966             W_UBBUF:
1361   8966 8655422F4255	.BYTE	86h,"UB/BU",'F'+80h
1361   896C C6
1362   896D 59 89       	.WORD	W_ULIMIT
1363   896F             C_UBBUF:
1364   896F CB 87       	.WORD	X_USER			;Put next word on stack then do next
1365   8971 62 00       	.WORD	UBBUF-SYSTEM
1366   8973             
1367   8973             W_UBSCR:
1368   8973 8655422F5343	.BYTE	86h,"UB/SC",'R'+80h
1368   8979 D2
1369   897A 66 89       	.WORD	W_UBBUF
1370   897C             C_UBSCR:
1371   897C CB 87       	.WORD	X_USER			;Put next word on stack then do next
1372   897E 64 00       	.WORD	UBSCR-SYSTEM
1373   8980             
1374   8980             W_UTERMINAL:
1375   8980 8A553F544552	.BYTE	8Ah,"U?TERMINA",'L'+80h
1375   8986 4D494E41CC
1376   898B 73 89       	.WORD	W_UBSCR
1377   898D             C_UTERMINAL:
1378   898D CB 87       	.WORD	X_USER			;Put next word on stack then do next
1379   898F 50 00       	.WORD	UTERMINAL-SYSTEM
1380   8991             
1381   8991             W_UKEY:					;Put UKEY addr on stack
1382   8991 84554B45D9  	.BYTE	84h,"UKE",'Y'+80h
1383   8996 80 89       	.WORD	W_UTERMINAL
1384   8998             C_UKEY:
1385   8998 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1386   899A 52 00       	.WORD	UKEY-SYSTEM
1387   899C             
1388   899C             W_UEMIT:				;Put UEMIT addr on stack
1389   899C 8555454D49D4	.BYTE	85h,"UEMI",'T'+80h
1390   89A2 91 89       	.WORD	W_UKEY
1391   89A4             C_UEMIT:
1392   89A4 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1393   89A6 54 00       	.WORD	UEMIT-SYSTEM
1394   89A8             
1395   89A8             W_UCR:					;Push UCR addr
1396   89A8 83 55 43 D2 	.BYTE	83h,"UC",'R'+80h
1397   89AC 9C 89       	.WORD	W_UEMIT
1398   89AE             C_UCR:
1399   89AE CB 87       	.WORD	X_USER			;Put next word on stack then do next
1400   89B0 56 00       	.WORD	UCR-SYSTEM
1401   89B2             
1402   89B2             W_URW:
1403   89B2 8455522FD7  	.BYTE	84h,"UR/",'W'+80h
1404   89B7 A8 89       	.WORD	W_UCR
1405   89B9             C_URW:
1406   89B9 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1407   89BB 58 00       	.WORD	URW-SYSTEM
1408   89BD             
1409   89BD             W_UABORT:				;Put UABORT on stack
1410   89BD 865541424F52	.BYTE	86h,"UABOR",'T'+80h
1410   89C3 D4
1411   89C4 B2 89       	.WORD	W_URW
1412   89C6             C_UABORT:
1413   89C6 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1414   89C8 5A 00       	.WORD	UABORT-SYSTEM
1415   89CA             
1416   89CA             W_RAF:
1417   89CA 83 52 41 C6 	.BYTE	83h,"RA",'F'+80h
1418   89CE BD 89       	.WORD	W_UABORT
1419   89D0             C_RAF:
1420   89D0 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1421   89D2 68 00       	.WORD	RAF-SYSTEM
1422   89D4             
1423   89D4             W_RBC:
1424   89D4 83 52 42 C3 	.BYTE	83h,"RB",'C'+80h
1425   89D8 CA 89       	.WORD	W_RAF
1426   89DA             C_RBC:
1427   89DA CB 87       	.WORD	X_USER			;Put next word on stack then do next
1428   89DC 6A 00       	.WORD	RBC-SYSTEM
1429   89DE             
1430   89DE             W_RDE:
1431   89DE 83 52 44 C5 	.BYTE	83h,"RD",'E'+80h
1432   89E2 D4 89       	.WORD	W_RBC
1433   89E4             C_RDE
1434   89E4 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1435   89E6 6C 00       	.WORD	RDE-SYSTEM
1436   89E8             
1437   89E8             W_RHL:
1438   89E8 83 52 48 CC 	.BYTE	83h,"RH",'L'+80h
1439   89EC DE 89       	.WORD	W_RDE
1440   89EE             C_RHL:
1441   89EE CB 87       	.WORD	X_USER			;Put next word on stack then do next
1442   89F0 6E 00       	.WORD	RHL-SYSTEM
1443   89F2             
1444   89F2             W_RIX:
1445   89F2 83 52 49 D8 	.BYTE	83h,"RI",'X'+80h
1446   89F6 E8 89       	.WORD	W_RHL
1447   89F8             C_RIX:
1448   89F8 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1449   89FA 70 00       	.WORD	RIX-SYSTEM
1450   89FC             
1451   89FC             W_RIY:
1452   89FC 83 52 49 D9 	.BYTE	83h,"RI",'Y'+80h
1453   8A00 F2 89       	.WORD	W_RIX
1454   8A02             C_RIY:
1455   8A02 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1456   8A04 72 00       	.WORD	RIY-SYSTEM
1457   8A06             
1458   8A06             W_RAF2:
1459   8A06 84524146AC  	.BYTE	84h,"RAF",2Ch+80h
1460   8A0B FC 89       	.WORD	W_RIY
1461   8A0D             C_RAF2:
1462   8A0D CB 87       	.WORD	X_USER			;Put next word on stack then do next
1463   8A0F 74 00       	.WORD	RAF2-SYSTEM
1464   8A11             
1465   8A11             W_RBC2:
1466   8A11 84524243AC  	.BYTE	84h,"RBC",2Ch+80h
1467   8A16 06 8A       	.WORD	W_RAF2
1468   8A18             C_RBC2:
1469   8A18 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1470   8A1A 76 00       	.WORD	RBC2-SYSTEM
1471   8A1C             
1472   8A1C             W_RDE2:
1473   8A1C 84524445AC  	.BYTE	84h,"RDE",2Ch+80h
1474   8A21 11 8A       	.WORD	W_RBC2
1475   8A23             C_RDE2:
1476   8A23 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1477   8A25 78 00       	.WORD	RDE2-SYSTEM
1478   8A27             
1479   8A27             W_RHL2:
1480   8A27 8452484CAC  	.BYTE	84h,"RHL",2Ch+80h
1481   8A2C 1C 8A       	.WORD	W_RDE2
1482   8A2E             C_RHL2:
1483   8A2E CB 87       	.WORD	X_USER			;Put next word on stack then do next
1484   8A30 7A 00       	.WORD	RHL2-SYSTEM
1485   8A32             
1486   8A32             W_RA:
1487   8A32 82 52 C1    	.BYTE	82h,'R','A'+80h
1488   8A35 27 8A       	.WORD	W_RHL2
1489   8A37             C_RA:
1490   8A37 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1491   8A39 69 00       	.WORD	RAF+1-SYSTEM
1492   8A3B             
1493   8A3B             W_RF:
1494   8A3B 82 52 C6    	.BYTE	82h,'R','F'+80h
1495   8A3E 32 8A       	.WORD	W_RA
1496   8A40             C_RF:
1497   8A40 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1498   8A42 68 00       	.WORD	RAF-SYSTEM
1499   8A44             
1500   8A44             W_RB:
1501   8A44 82 52 C2    	.BYTE	82h,'R','B'+80h
1502   8A47 3B 8A       	.WORD	W_RF
1503   8A49             C_RB:
1504   8A49 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1505   8A4B 6B 00       	.WORD	RBC+1-SYSTEM
1506   8A4D             
1507   8A4D             W_RC:
1508   8A4D 82 52 C3    	.BYTE	82h,'R','C'+80h
1509   8A50 44 8A       	.WORD	W_RB
1510   8A52             C_RC:
1511   8A52 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1512   8A54 6A 00       	.WORD	RBC-SYSTEM
1513   8A56             
1514   8A56             W_RD:
1515   8A56 82 52 C4    	.BYTE	82h,'R','D'+80h
1516   8A59 4D 8A       	.WORD	W_RC
1517   8A5B             C_RD:
1518   8A5B CB 87       	.WORD	X_USER			;Put next word on stack then do next
1519   8A5D 6D 00       	.WORD	RDE+1-SYSTEM
1520   8A5F             
1521   8A5F             W_RE:
1522   8A5F 82 52 C5    	.BYTE	82h,'R','E'+80h
1523   8A62 56 8A       	.WORD	W_RD
1524   8A64             C_RE:
1525   8A64 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1526   8A66 6C 00       	.WORD	RDE-SYSTEM
1527   8A68             
1528   8A68             W_RH:
1529   8A68 82 52 C8    	.BYTE	82h,'R','H'+80h
1530   8A6B 5F 8A       	.WORD	W_RE
1531   8A6D             C_RH:
1532   8A6D CB 87       	.WORD	X_USER			;Put next word on stack then do next
1533   8A6F 6F 00       	.WORD	RHL+1-SYSTEM
1534   8A71             
1535   8A71             W_RL:
1536   8A71 82 52 CC    	.BYTE	82h,'R','L'+80h
1537   8A74 68 8A       	.WORD	W_RH
1538   8A76             C_RL:
1539   8A76 CB 87       	.WORD	X_USER			;Put next word on stack then do next
1540   8A78 6E 00       	.WORD	RHL-SYSTEM
1541   8A7A             
1542   8A7A             W_CALL:
1543   8A7A 8443414CCC  	.BYTE	84h,"CAL",'L'+80h
1544   8A7F 71 8A       	.WORD	W_RL
1545   8A81             C_CALL:
1546   8A81 83 8A       	.WORD	2+$			;Vector to code
1547   8A83 E1          	POP	HL			;Address of routine CALLed
1548   8A84 D5          	PUSH	DE			;Save register
1549   8A85 C5          	PUSH	BC			;Save register
1550   8A86 3E C3       	LD	A,0C3h			;Hex code for JMP
1551   8A88 32 7D FE    	LD	(JPCODE),A		;Save it
1552   8A8B 22 7E FE    	LD	(JPVECT),HL		;Save jump vector
1553   8A8E 2A 68 FE    	LD	HL,(RAF)		;Get register AF
1554   8A91 E5          	PUSH	HL			;Onto stack
1555   8A92 F1          	POP	AF			;POP into AF
1556   8A93 ED 4B 6A FE 	LD	BC,(RBC)		;Get register BC
1557   8A97 ED 5B 6C FE 	LD	DE,(RDE)		;Get register DE
1558   8A9B 2A 6E FE    	LD	HL,(RHL)		;Get register HL
1559   8A9E DD 2A 70 FE 	LD	IX,(RIX)		;Get register IX
1560   8AA2 FD 2A 72 FE 	LD	IY,(RIY)		;Get register IY
1561   8AA6 CD 7D FE    	CALL	JPCODE			;Call jump to code
1562   8AA9 FD 22 72 FE 	LD	(RIY),IY		;Save register IY
1563   8AAD DD 22 70 FE 	LD	(RIX),IX		;Save register IX
1564   8AB1 ED 43 6A FE 	LD	(RBC),BC		;Save register BC
1565   8AB5 ED 53 6C FE 	LD	(RDE),DE		;Save register DE
1566   8AB9 22 6E FE    	LD	(RHL),HL		;Save register HL
1567   8ABC F5          	PUSH	AF			;Save register AF
1568   8ABD E1          	POP	HL			;Into HL
1569   8ABE 22 68 FE    	LD	(RAF),HL		;Into memory
1570   8AC1 C1          	POP	BC			;Restore BC
1571   8AC2 D1          	POP	DE			;Restore DE
1572   8AC3 C3 4E 82    	JP	NEXT			;
1573   8AC6             
1574   8AC6             W_1PLUS:				;1 plus
1575   8AC6 82 31 AB    	.BYTE	82h,'1','+'+80h
1576   8AC9 7A 8A       	.WORD	W_CALL
1577   8ACB             C_1PLUS:
1578   8ACB CD 8A       	.WORD	2+$			;Vector to code
1579   8ACD E1          	POP	HL			; get n
1580   8ACE 23          	INC	HL			; add 1
1581   8ACF C3 4D 82    	JP	NEXTS1			; save result & NEXT
1582   8AD2             
1583   8AD2             W_2PLUS:				;2 plus
1584   8AD2 82 32 AB    	.BYTE	82h,'2','+'+80h
1585   8AD5 C6 8A       	.WORD	W_1PLUS
1586   8AD7             C_2PLUS:
1587   8AD7 D9 8A       	.WORD	2+$			;Vector to code
1588   8AD9 E1          	POP	HL			; get n
1589   8ADA 23          	INC	HL			; add 1
1590   8ADB 23          	INC	HL			; add 2
1591   8ADC C3 4D 82    	JP	NEXTS1			; save result & NEXT
1592   8ADF             
1593   8ADF             W_1MINUS:				;1 minus
1594   8ADF 82 31 AD    	.BYTE	82h,'1','-'+80h
1595   8AE2 D2 8A       	.WORD	W_2PLUS
1596   8AE4             C_1MINUS:
1597   8AE4 E6 8A       	.WORD	2+$			;Vector to code
1598   8AE6 E1          	POP	HL			; get n
1599   8AE7 2B          	DEC	HL			; add 1
1600   8AE8 C3 4D 82    	JP	NEXTS1			; save result & NEXT
1601   8AEB             
1602   8AEB             W_2MINUS:				;2 minus
1603   8AEB 82 32 AD    	.BYTE	82h,'2','-'+80h
1604   8AEE DF 8A       	.WORD	W_1MINUS
1605   8AF0             C_2MINUS:
1606   8AF0 F2 8A       	.WORD	2+$			;Vector to code
1607   8AF2 E1          	POP	HL			; get n
1608   8AF3 2B          	DEC	HL			; subtract 1
1609   8AF4 2B          	DEC	HL			; subtract 2
1610   8AF5 C3 4D 82    	JP	NEXTS1			; save result & NEXT
1611   8AF8             
1612   8AF8             W_HERE:					;Dictionary pointer onto stack
1613   8AF8 84484552C5  	.BYTE	84h,"HER",'E'+80h
1614   8AFD EB 8A       	.WORD	W_2MINUS
1615   8AFF             C_HERE:
1616   8AFF 64 87       	.WORD	E_COLON			;Interpret following word sequence
1617   8B01 95 88       	.WORD	C_DP			;Dictionary pointer addr on stack
1618   8B03 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
1619   8B05 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1620   8B07             
1621   8B07             W_ALLOT:
1622   8B07 85414C4C4FD4	.BYTE	85h,"ALLO",'T'+80h
1623   8B0D F8 8A       	.WORD	W_HERE
1624   8B0F             C_ALLOT:
1625   8B0F 64 87       	.WORD	E_COLON			;Interpret following word sequence
1626   8B11 95 88       	.WORD	C_DP			;Dictionary pointer addr on stack
1627   8B13 C5 86       	.WORD	C_PLUSSTORE		;Add n1 to addr
1628   8B15 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1629   8B17             
1630   8B17             W_COMMA:				;Reserve 2 bytes and save n
1631   8B17 81 AC       	.BYTE	81h,','+80h
1632   8B19 07 8B       	.WORD	W_ALLOT
1633   8B1B             C_COMMA:
1634   8B1B 64 87       	.WORD	E_COLON			;Interpret following word sequence
1635   8B1D FF 8A       	.WORD	C_HERE			;Next free dictionary pointer onto stack
1636   8B1F 21 87       	.WORD	C_STORE			;Store word at addr
1637   8B21 EB 87       	.WORD	C_2			;
1638   8B23 0F 8B       	.WORD	C_ALLOT			;Move pointer
1639   8B25 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1640   8B27             
1641   8B27             W_CCOMMA:
1642   8B27 82 43 AC    	.BYTE	82h,'C',','+80h
1643   8B2A 17 8B       	.WORD	W_COMMA
1644   8B2C             C_CCOMMA:
1645   8B2C 64 87       	.WORD	E_COLON			;Interpret following word sequence
1646   8B2E FF 8A       	.WORD	C_HERE			;Dictionary pointer onto stack
1647   8B30 30 87       	.WORD	C_CSTORE		;Store byte at addr
1648   8B32 E3 87       	.WORD	C_1			;Put 1 on stack
1649   8B34 0F 8B       	.WORD	C_ALLOT
1650   8B36 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1651   8B38             
1652   8B38             W_MINUS:
1653   8B38 81 AD       	.BYTE	81h,'-'+80h
1654   8B3A 27 8B       	.WORD	W_CCOMMA
1655   8B3C             C_MINUS:
1656   8B3C 3E 8B       	.WORD	2+$			;Vector to code
1657   8B3E D1          	POP	DE			; get n1
1658   8B3F E1          	POP	HL			; get n2
1659   8B40 CD 46 8B    	CALL	MINUS16			; call subtract routine
1660   8B43 C3 4D 82    	JP	NEXTS1			; save & NEXT
1661   8B46             
1662   8B46             MINUS16:
1663   8B46 7D          	LD	A,L			; gel low byte
1664   8B47 93          	SUB	E			; subtract low bytes
1665   8B48 6F          	LD	L,A			; save low byte result
1666   8B49 7C          	LD	A,H			; get high byte
1667   8B4A 9A          	SBC	A,D			; subtract high bytes
1668   8B4B 67          	LD	H,A			; save high byte result
1669   8B4C C9          	RET				;
1670   8B4D             
1671   8B4D             W_.EQUALS:
1672   8B4D 81 BD       	.BYTE	81h,'='+80h
1673   8B4F 38 8B       	.WORD	W_MINUS
1674   8B51             C_EQUALS:
1675   8B51 64 87       	.WORD	E_COLON			;Interpret following word sequence
1676   8B53 3C 8B       	.WORD	C_MINUS
1677   8B55 CF 85       	.WORD	C_0EQUALS		;=0
1678   8B57 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1679   8B59             
1680   8B59             W_LESSTHAN:
1681   8B59 81 BC       	.BYTE	81h,'<'+80h
1682   8B5B 4D 8B       	.WORD	W_.EQUALS
1683   8B5D             C_LESSTHAN:
1684   8B5D 5F 8B       	.WORD	2+$			;Vector to code
1685   8B5F D1          	POP	DE
1686   8B60 E1          	POP	HL
1687   8B61 7A          	LD	A,D
1688   8B62 AC          	XOR	H
1689   8B63 FA 69 8B    	JP	M,J298C
1690   8B66 CD 46 8B    	CALL	MINUS16
1691   8B69             J298C:
1692   8B69 24          	INC	H
1693   8B6A 25          	DEC	H
1694   8B6B FA 74 8B    	JP	M,J2997
1695   8B6E 21 00 00    	LD	HL,0000
1696   8B71 C3 4D 82    	JP	NEXTS1			;Save & NEXT
1697   8B74             J2997:
1698   8B74 21 01 00    	LD	HL,0001
1699   8B77 C3 4D 82    	JP	NEXTS1			;Save & NEXT
1700   8B7A             
1701   8B7A             W_ULESS:				;IF stack-1 < stack_top leave true flag
1702   8B7A 82 55 BC    	.BYTE	82h,'U','<'+80h
1703   8B7D 59 8B       	.WORD	W_LESSTHAN
1704   8B7F             C_ULESS:
1705   8B7F 64 87       	.WORD	E_COLON			;Interpret following word sequence
1706   8B81 A5 86       	.WORD	C_2DUP			;Dup top 2 values on stack
1707   8B83 13 85       	.WORD	C_XOR			;Exclusive OR them
1708   8B85 EA 85       	.WORD	C_0LESS			;Less than 0
1709   8B87 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
1710   8B89 0C 00       	.WORD	B0000-$			;000Ch
1711   8B8B 6E 86       	.WORD	C_DROP			;Drop top value from stack
1712   8B8D EA 85       	.WORD	C_0LESS			;Less than 0
1713   8B8F CF 85       	.WORD	C_0EQUALS		;=0
1714   8B91 98 82       	.WORD	C_BRANCH		;Add following offset to BC
1715   8B93 06 00       	.WORD	B0001-$			;0006h
1716   8B95             B0000:
1717   8B95 3C 8B       	.WORD	C_MINUS
1718   8B97 EA 85       	.WORD	C_0LESS			;Less than 0
1719   8B99             B0001:
1720   8B99 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1721   8B9B             
1722   8B9B             W_GREATER:
1723   8B9B 81 BE       	.BYTE	81h,'>'+80h
1724   8B9D 7A 8B       	.WORD	W_ULESS
1725   8B9F             C_GREATER:
1726   8B9F 64 87       	.WORD	E_COLON			;Interpret following word sequence
1727   8BA1 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
1728   8BA3 5D 8B       	.WORD	C_LESSTHAN
1729   8BA5 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1730   8BA7             
1731   8BA7             W_ROT:					;3rd valu down to top of stack
1732   8BA7 83 52 4F D4 	.BYTE	83h,"RO",'T'+80h
1733   8BAB 9B 8B       	.WORD	W_GREATER
1734   8BAD             C_ROT:
1735   8BAD AF 8B       	.WORD	2+$			;Vector to code
1736   8BAF D1          	POP	DE			;Top value
1737   8BB0 E1          	POP	HL			;Next one down
1738   8BB1 E3          	EX	(SP),HL			;Exchange with third
1739   8BB2 C3 4C 82    	JP	NEXTS2			;Save both & NEXT
1740   8BB5             
1741   8BB5             W_PICK:
1742   8BB5 84504943CB  	.BYTE	84h,"PIC",'K'+80h
1743   8BBA A7 8B       	.WORD	W_ROT
1744   8BBC             C_PICK:
1745   8BBC 64 87       	.WORD	E_COLON			;Interpret following word sequence
1746   8BBE 97 86       	.WORD	C_DUP			;Duplicate top value on stack
1747   8BC0 FB 85       	.WORD	C_PLUS			;n1 + n2
1748   8BC2 26 85       	.WORD	C_SPFETCH		;Stack pointer onto stack
1749   8BC4 FB 85       	.WORD	C_PLUS			;n1 + n2
1750   8BC6 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
1751   8BC8 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1752   8BCA             
1753   8BCA             W_SPACE:
1754   8BCA 8553504143C5	.BYTE	85h,"SPAC",'E'+80h
1755   8BD0 B5 8B       	.WORD	W_PICK
1756   8BD2             C_SPACE:
1757   8BD2 64 87       	.WORD	E_COLON			;Interpret following word sequence
1758   8BD4 FC 87       	.WORD	C_BL			;Leaves ASCII for space on stack
1759   8BD6 FD 83       	.WORD	C_EMIT			;Output CHR from stack
1760   8BD8 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1761   8BDA             
1762   8BDA             W_QUERYDUP:
1763   8BDA 843F4455D0  	.BYTE	84h,"?DU",'P'+80h
1764   8BDF CA 8B       	.WORD	W_SPACE
1765   8BE1             C_QUERYDUP:
1766   8BE1 64 87       	.WORD	E_COLON			;Interpret following word sequence
1767   8BE3 97 86       	.WORD	C_DUP			;Duplicate top value on stack
1768   8BE5 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
1769   8BE7 04 00       	.WORD	B0002-$			;0004h
1770   8BE9 97 86       	.WORD	C_DUP			;Duplicate top value on stack
1771   8BEB             B0002:
1772   8BEB 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1773   8BED             
1774   8BED             W_TRAVERSE:
1775   8BED 885452415645	.BYTE	88h,"TRAVERS",'E'+80h
1775   8BF3 5253C5
1776   8BF6 DA 8B       	.WORD	W_QUERYDUP
1777   8BF8             C_TRAVERSE:
1778   8BF8 64 87       	.WORD	E_COLON			;Interpret following word sequence
1779   8BFA 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
1780   8BFC             B0054:
1781   8BFC 5F 86       	.WORD	C_OVER			;Copy 2nd down to top of stack
1782   8BFE FB 85       	.WORD	C_PLUS			;n1 + n2
1783   8C00 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1784   8C02 7F 00       	.WORD	007Fh
1785   8C04 5F 86       	.WORD	C_OVER			;Copy 2nd down to top of stack
1786   8C06 F9 86       	.WORD	C_CFETCH		;Get byte from addr on stack
1787   8C08 5D 8B       	.WORD	C_LESSTHAN
1788   8C0A B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
1789   8C0C F0 FF       	.WORD	B0054-$			;FFF0h
1790   8C0E 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
1791   8C10 6E 86       	.WORD	C_DROP			;Drop top value from stack
1792   8C12 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1793   8C14             
1794   8C14             W_LATEST:
1795   8C14 864C41544553	.BYTE	86h,"LATES",'T'+80h
1795   8C1A D4
1796   8C1B ED 8B       	.WORD	W_TRAVERSE
1797   8C1D             C_LATEST:
1798   8C1D 64 87       	.WORD	E_COLON			;Interpret following word sequence
1799   8C1F F5 88       	.WORD	C_CURRENT
1800   8C21 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
1801   8C23 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
1802   8C25 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1803   8C27             
1804   8C27             W_LFA:
1805   8C27 83 4C 46 C1 	.BYTE	83h,"LF",'A'+80h
1806   8C2B 14 8C       	.WORD	W_LATEST
1807   8C2D             C_LFA:
1808   8C2D 64 87       	.WORD	E_COLON			;Interpret following word sequence
1809   8C2F 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1810   8C31 04 00       	.WORD	0004h
1811   8C33 3C 8B       	.WORD	C_MINUS
1812   8C35 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1813   8C37             
1814   8C37             W_CFA:
1815   8C37 83 43 46 C1 	.BYTE	83h,"CF",'A'+80h
1816   8C3B 27 8C       	.WORD	W_LFA
1817   8C3D             C_CFA:
1818   8C3D 3F 8C       	.WORD	2+$			;Vector to code
1819   8C3F E1          	POP	HL			    ; get n
1820   8C40 2B          	DEC	HL			    ; subtract 1
1821   8C41 2B          	DEC	HL			    ; subtract 2
1822   8C42 C3 4D 82    	JP	NEXTS1			; save result & NEXT
1823   8C45             W_NFA:
1824   8C45 83 4E 46 C1 	.BYTE	83h,"NF",'A'+80h
1825   8C49 37 8C       	.WORD	W_CFA
1826   8C4B             C_NFA:
1827   8C4B 64 87       	.WORD	E_COLON			;Interpret following word sequence
1828   8C4D 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1829   8C4F 05 00       	.WORD	0005h
1830   8C51 3C 8B       	.WORD	C_MINUS
1831   8C53 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1832   8C55 FF FF       	.WORD	0FFFFh
1833   8C57 F8 8B       	.WORD	C_TRAVERSE
1834   8C59 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1835   8C5B             
1836   8C5B             W_PFA:					    ;Convert NFA to PFA
1837   8C5B 83 50 46 C1 	.BYTE	83h,"PF",'A'+80h
1838   8C5F 45 8C       	.WORD	W_NFA
1839   8C61             C_PFA:
1840   8C61 64 87       	.WORD	E_COLON			;Interpret following word sequence
1841   8C63 E3 87       	.WORD	C_1			    ;Traverse up memory
1842   8C65 F8 8B       	.WORD	C_TRAVERSE		;End of name on stack
1843   8C67 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1844   8C69 05 00       	.WORD	0005h			;Offset to start of word code
1845   8C6B FB 85       	.WORD	C_PLUS			;n1 + n2
1846   8C6D 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1847   8C6F             
1848   8C6F             W_CSPSTORE:
1849   8C6F 84214353D0  	.BYTE	84h,"!CS",'P'+80h
1850   8C74 5B 8C       	.WORD	W_PFA
1851   8C76             C_CSPSTORE:
1852   8C76 64 87       	.WORD	E_COLON			;Interpret following word sequence
1853   8C78 26 85       	.WORD	C_SPFETCH		;Stack pointer onto stack
1854   8C7A 2A 89       	.WORD	C_CSP			;Push check stack pointer addr
1855   8C7C 21 87       	.WORD	C_STORE			;Store word at addr
1856   8C7E 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1857   8C80             
1858   8C80             W_QERROR:
1859   8C80 863F4552524F	.BYTE	86h,"?ERRO",'R'+80h
1859   8C86 D2
1860   8C87 6F 8C       	.WORD	W_CSPSTORE
1861   8C89             C_QERROR:
1862   8C89 64 87       	.WORD	E_COLON			;Interpret following word sequence
1863   8C8B 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
1864   8C8D B0 82       	.WORD	C_0BRANCH		;Branch if no error
1865   8C8F 08 00       	.WORD	B0003-$			;0008h
1866   8C91 1A 91       	.WORD	C_ERROR
1867   8C93 98 82       	.WORD	C_BRANCH		;Add following offset to BC
1868   8C95 04 00       	.WORD	B0004-$			;0004h
1869   8C97             B0003:
1870   8C97 6E 86       	.WORD	C_DROP			;Drop error no.
1871   8C99             B0004:
1872   8C99 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1873   8C9B             
1874   8C9B             W_QCOMP:				;Error if not in compile mode
1875   8C9B 853F434F4DD0	.BYTE	85h,"?COM",'P'+80h
1876   8CA1 80 8C       	.WORD	W_QERROR
1877   8CA3             C_QCOMP:
1878   8CA3 64 87       	.WORD	E_COLON			;Interpret following word sequence
1879   8CA5 01 89       	.WORD	C_STATE			;Push STATE addr
1880   8CA7 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
1881   8CA9 CF 85       	.WORD	C_0EQUALS		;=0
1882   8CAB 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1883   8CAD 11 00       	.WORD	0011h			;Error message number
1884   8CAF 89 8C       	.WORD	C_QERROR		;Error if state <> 0
1885   8CB1 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1886   8CB3             
1887   8CB3             W_QEXEC:				;Error not if not in execute mode
1888   8CB3 853F455845C3	.BYTE	85h,"?EXE",'C'+80h
1889   8CB9 9B 8C       	.WORD	W_QCOMP
1890   8CBB             C_QEXEC:
1891   8CBB 64 87       	.WORD	E_COLON			;Interpret following word sequence
1892   8CBD 01 89       	.WORD	C_STATE			;Push STATE addr
1893   8CBF EA 86       	.WORD	C_FETCH			;Get word from addr on stack
1894   8CC1 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1895   8CC3 12 00       	.WORD	0012h			;Error not if not in execute mode
1896   8CC5 89 8C       	.WORD	C_QERROR		;
1897   8CC7 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1898   8CC9             
1899   8CC9             W_QPAIRS:
1900   8CC9 863F50414952	.BYTE	86h,"?PAIR",'S'+80h
1900   8CCF D3
1901   8CD0 B3 8C       	.WORD	W_QEXEC
1902   8CD2             C_QPAIRS:
1903   8CD2 64 87       	.WORD	E_COLON			;Interpret following word sequence
1904   8CD4 3C 8B       	.WORD	C_MINUS
1905   8CD6 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1906   8CD8 13 00       	.WORD	0013h
1907   8CDA 89 8C       	.WORD	C_QERROR
1908   8CDC 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1909   8CDE             
1910   8CDE             W_WHATSTACK:				;Check stack pointer, error if not ok
1911   8CDE 843F4353D0  	.BYTE	84h,"?CS",'P'+80h
1912   8CE3 C9 8C       	.WORD	W_QPAIRS
1913   8CE5             C_WHATSTACK:
1914   8CE5 64 87       	.WORD	E_COLON			;Interpret following word sequence
1915   8CE7 26 85       	.WORD	C_SPFETCH		;Stack pointer onto stack
1916   8CE9 2A 89       	.WORD	C_CSP			;Push check stack pointer addr
1917   8CEB EA 86       	.WORD	C_FETCH			;Get check stack pointer
1918   8CED 3C 8B       	.WORD	C_MINUS			;If ok then result is 0
1919   8CEF 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1920   8CF1 14 00       	.WORD	0014h			;Error no if not ok
1921   8CF3 89 8C       	.WORD	C_QERROR		;Error if stack top -1 <> 0
1922   8CF5 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1923   8CF7             
1924   8CF7             W_QLOADING:
1925   8CF7 883F4C4F4144	.BYTE	88h,"?LOADIN",'G'+80h
1925   8CFD 494EC7
1926   8D00 DE 8C       	.WORD	W_WHATSTACK
1927   8D02             C_QLOADING:
1928   8D02 64 87       	.WORD	E_COLON			;Interpret following word sequence
1929   8D04 AE 88       	.WORD	C_BLK
1930   8D06 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
1931   8D08 CF 85       	.WORD	C_0EQUALS		;=0
1932   8D0A 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1933   8D0C 16 00       	.WORD	0016h
1934   8D0E 89 8C       	.WORD	C_QERROR
1935   8D10 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1936   8D12             
1937   8D12             W_COMPILE:
1938   8D12 87434F4D5049	.BYTE	87h,"COMPIL",'E'+80h
1938   8D18 4CC5
1939   8D1A F7 8C       	.WORD	W_QLOADING
1940   8D1C             C_COMPILE:
1941   8D1C 64 87       	.WORD	E_COLON			;Interpret following word sequence
1942   8D1E A3 8C       	.WORD	C_QCOMP			;Error if not in compile mode
1943   8D20 B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
1944   8D22 97 86       	.WORD	C_DUP			;Bump return address and put back
1945   8D24 D7 8A       	.WORD	C_2PLUS			;
1946   8D26 9D 85       	.WORD	C_MOVER			;
1947   8D28 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
1948   8D2A 1B 8B       	.WORD	C_COMMA			;Reserve 2 bytes and save n
1949   8D2C 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1950   8D2E             
1951   8D2E             W_LEFTBRKT:				;Set STATE to execute
1952   8D2E 81 DB       	.BYTE	81h,'['+80h
1953   8D30 12 8D       	.WORD	W_COMPILE
1954   8D32             C_LEFTBRKT:
1955   8D32 64 87       	.WORD	E_COLON			;Interpret following word sequence
1956   8D34 DB 87       	.WORD	C_ZERO			;Put zero on stack
1957   8D36 01 89       	.WORD	C_STATE			;Push STATE addr
1958   8D38 21 87       	.WORD	C_STORE			;Store word at addr
1959   8D3A 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1960   8D3C             
1961   8D3C             W_RIGHTBRKT:				;Set STATE to compile
1962   8D3C 81 DD       	.BYTE	81h,']'+80h
1963   8D3E 2E 8D       	.WORD	W_LEFTBRKT
1964   8D40             C_RIGHTBRKT:
1965   8D40 64 87       	.WORD	E_COLON			;Interpret following word sequence
1966   8D42 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1967   8D44 C0 00       	.WORD	00C0h
1968   8D46 01 89       	.WORD	C_STATE			;Push STATE addr
1969   8D48 21 87       	.WORD	C_STORE			;Set STATE to execute
1970   8D4A 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1971   8D4C             
1972   8D4C             W_SMUDGE:
1973   8D4C 86534D554447	.BYTE	86h,"SMUDG",'E'+80h
1973   8D52 C5
1974   8D53 3C 8D       	.WORD	W_RIGHTBRKT
1975   8D55             C_SMUDGE:
1976   8D55 64 87       	.WORD	E_COLON			;Interpret following word sequence
1977   8D57 1D 8C       	.WORD	C_LATEST		;Push top words NFA
1978   8D59 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1979   8D5B 20 00       	.WORD	0020h
1980   8D5D DC 86       	.WORD	C_TOGGLE		;XOR (addr) with byte
1981   8D5F 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1982   8D61             
1983   8D61             W_HEX:
1984   8D61 83 48 45 D8 	.BYTE	83h,"HE",'X'+80h
1985   8D65 4C 8D       	.WORD	W_SMUDGE
1986   8D67             C_HEX:
1987   8D67 64 87       	.WORD	E_COLON			;Interpret following word sequence
1988   8D69 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
1989   8D6B 10 00       	.WORD	0010h
1990   8D6D 0C 89       	.WORD	C_BASE			;Put BASE addr on stack
1991   8D6F 21 87       	.WORD	C_STORE			;Store word at addr
1992   8D71 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
1993   8D73             
1994   8D73             W_DECIMAL:				;Sets decimal mode
1995   8D73 87444543494D	.BYTE	87h,"DECIMA",'L'+80h
1995   8D79 41CC
1996   8D7B 61 8D       	.WORD	W_HEX
1997   8D7D             C_DECIMAL:
1998   8D7D 64 87       	.WORD	E_COLON			;Interpret following word sequence
1999   8D7F 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2000   8D81 0A 00       	.WORD	000Ah			;Sets decimal value
2001   8D83 0C 89       	.WORD	C_BASE			;Put BASE addr on stack
2002   8D85 21 87       	.WORD	C_STORE			;Store word at addr
2003   8D87 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2004   8D89             
2005   8D89             W_CCODE:				;Stop compillation & terminate word
2006   8D89 873C3B434F44	.BYTE	87h,"<;CODE",'>'+80h
2006   8D8F 45BE
2007   8D91 73 8D       	.WORD	W_DECIMAL
2008   8D93             C_CCODE:
2009   8D93 64 87       	.WORD	E_COLON			;Interpret following word sequence
2010   8D95 B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
2011   8D97 1D 8C       	.WORD	C_LATEST		;Push top words NFA
2012   8D99 61 8C       	.WORD	C_PFA			;Convert NFA to PFA
2013   8D9B 3D 8C       	.WORD	C_CFA			;Convert PFA to CFA
2014   8D9D 21 87       	.WORD	C_STORE			;Store word at addr
2015   8D9F 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2016   8DA1             
2017   8DA1             W_SCCODE:
2018   8DA1 C53B434F44C5	.BYTE	0C5h,";COD",'E'+80h
2019   8DA7 89 8D       	.WORD	W_CCODE
2020   8DA9             C_SCCODE:
2021   8DA9 64 87       	.WORD	E_COLON			;Interpret following word sequence
2022   8DAB E5 8C       	.WORD	C_WHATSTACK		;Check stack pointer, error if not ok
2023   8DAD 1C 8D       	.WORD	C_COMPILE		;Compile next word into dictionary
2024   8DAF 93 8D       	.WORD	C_CCODE
2025   8DB1 32 8D       	.WORD	C_LEFTBRKT		;Set STATE to execute
2026   8DB3 07 9C       	.WORD	C_TASK
2027   8DB5 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2028   8DB7             
2029   8DB7             W_CREATE:
2030   8DB7 864352454154	.BYTE	86h,"CREAT",'E'+80h
2030   8DBD C5
2031   8DBE A1 8D       	.WORD	W_SCCODE
2032   8DC0             C_CREATE:
2033   8DC0 64 87       	.WORD	E_COLON			;Interpret following word sequence
2034   8DC2 DB 87       	.WORD	C_ZERO			;Put zero on stack
2035   8DC4 93 87       	.WORD	C_CONSTANT
2036   8DC6 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2037   8DC8             
2038   8DC8             W_DOES:
2039   8DC8 85444F4553BE	.BYTE	85h,"DOES",'>'+80h
2040   8DCE B7 8D       	.WORD	W_CREATE
2041   8DD0             C_DOES:
2042   8DD0 64 87       	.WORD	E_COLON			;Interpret following word sequence
2043   8DD2 B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
2044   8DD4 1D 8C       	.WORD	C_LATEST		;Push top words NFA
2045   8DD6 61 8C       	.WORD	C_PFA			;Convert NFA to PFA
2046   8DD8 21 87       	.WORD	C_STORE			;Store word at addr
2047   8DDA 93 8D       	.WORD	C_CCODE			;Execute following machine code
2048   8DDC             
2049   8DDC             X_DOES:
2050   8DDC 2A 46 FE    	LD	HL,(RPP)		;Get return stack pointer
2051   8DDF 2B          	DEC	HL			;Push next pointer
2052   8DE0 70          	LD	(HL),B			;
2053   8DE1 2B          	DEC	HL			;
2054   8DE2 71          	LD	(HL),C			;
2055   8DE3 22 46 FE    	LD	(RPP),HL
2056   8DE6 13          	INC	DE
2057   8DE7 EB          	EX	DE,HL
2058   8DE8 4E          	LD	C,(HL)
2059   8DE9 23          	INC	HL
2060   8DEA 46          	LD	B,(HL)
2061   8DEB 23          	INC	HL
2062   8DEC C3 4D 82    	JP	NEXTS1			;Save & NEXT
2063   8DEF             
2064   8DEF             W_COUNT:				;Convert string at addr to addr + length
2065   8DEF 85434F554ED4	.BYTE	85h,"COUN",'T'+80h
2066   8DF5 C8 8D       	.WORD	W_DOES
2067   8DF7             C_COUNT:
2068   8DF7 64 87       	.WORD	E_COLON			;Interpret following word sequence
2069   8DF9 97 86       	.WORD	C_DUP			;Duplicate address
2070   8DFB CB 8A       	.WORD	C_1PLUS			;Add 1 (points to string start)
2071   8DFD 8A 86       	.WORD	C_SWAP			;Get address back
2072   8DFF F9 86       	.WORD	C_CFETCH		;Get byte from addr on stack
2073   8E01 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2074   8E03             
2075   8E03             W_TYPE:					    ;Output n bytes from addr
2076   8E03 84545950C5  	.BYTE	84h,"TYP",'E'+80h
2077   8E08 EF 8D       	.WORD	W_COUNT
2078   8E0A             C_TYPE:
2079   8E0A 64 87       	.WORD	E_COLON			;Interpret following word sequence
2080   8E0C E1 8B       	.WORD	C_QUERYDUP		;Copy length if length <> 0
2081   8E0E B0 82       	.WORD	C_0BRANCH		;Branch if length = 0
2082   8E10 18 00       	.WORD	B0005-$			;0018h
2083   8E12 5F 86       	.WORD	C_OVER			;Copy address to stack top
2084   8E14 FB 85       	.WORD	C_PLUS			;Add to length
2085   8E16 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
2086   8E18 0A 83       	.WORD	C_LDO			;Put start & end loop values on RPP
2087   8E1A             B004F:
2088   8E1A 26 83       	.WORD	C_I			    ;Copy LOOP index to data stack
2089   8E1C F9 86       	.WORD	C_CFETCH		;Get byte from string
2090   8E1E FD 83       	.WORD	C_EMIT			;Output CHR from stack
2091   8E20 C5 82       	.WORD	C_LLOOP			;Increment loop & branch if not done
2092   8E22 F8 FF       	.WORD	B004F-$			;FFF8h
2093   8E24 98 82       	.WORD	C_BRANCH		;Done so branch to next
2094   8E26 04 00       	.WORD	B0006-$			;0004h
2095   8E28             B0005:
2096   8E28 6E 86       	.WORD	C_DROP			;Drop string address
2097   8E2A             B0006:
2098   8E2A 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2099   8E2C             
2100   8E2C             W_TRAILING:
2101   8E2C 892D54524149	.BYTE	89h,"-TRAILIN",'G'+80h
2101   8E32 4C494EC7
2102   8E36 03 8E       	.WORD	W_TYPE
2103   8E38             C_TRAILING:
2104   8E38 64 87       	.WORD	E_COLON			;Interpret following word sequence
2105   8E3A 97 86       	.WORD	C_DUP			;Duplicate top value on stack
2106   8E3C DB 87       	.WORD	C_ZERO			;Put zero on stack
2107   8E3E 0A 83       	.WORD	C_LDO			;Put start & end loop values on RPP
2108   8E40             B0009:
2109   8E40 5F 86       	.WORD	C_OVER			;Copy 2nd down to top of stack
2110   8E42 5F 86       	.WORD	C_OVER			;Copy 2nd down to top of stack
2111   8E44 FB 85       	.WORD	C_PLUS			;n1 + n2
2112   8E46 E3 87       	.WORD	C_1			;Put 1 on stack
2113   8E48 3C 8B       	.WORD	C_MINUS
2114   8E4A F9 86       	.WORD	C_CFETCH		;Get byte from addr on stack
2115   8E4C FC 87       	.WORD	C_BL			;Leaves ASCII for space on stack
2116   8E4E 3C 8B       	.WORD	C_MINUS
2117   8E50 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2118   8E52 08 00       	.WORD	B0007-$			;0008h
2119   8E54 89 85       	.WORD	C_LEAVE			;Quit loop by making index = limit
2120   8E56 98 82       	.WORD	C_BRANCH		;Add following offset to BC
2121   8E58 06 00       	.WORD	B0008-$			;0006h
2122   8E5A             B0007:
2123   8E5A E3 87       	.WORD	C_1			;Put 1 on stack
2124   8E5C 3C 8B       	.WORD	C_MINUS
2125   8E5E             B0008:
2126   8E5E C5 82       	.WORD	C_LLOOP			;Increment loop & branch if not done
2127   8E60 E0 FF       	.WORD	B0009-$			;FFE0h
2128   8E62 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2129   8E64             
2130   8E64             W_CQUOTE:				;Output following string
2131   8E64 843C2E22BE  	.BYTE	84h,"<.",22h,'>'+80h
2132   8E69 2C 8E       	.WORD	W_TRAILING
2133   8E6B             C_CQUOTE:
2134   8E6B 64 87       	.WORD	E_COLON			;Interpret following word sequence
2135   8E6D C8 85       	.WORD	C_RFETCH		;Copy return stack top to data stack
2136   8E6F F7 8D       	.WORD	C_COUNT			;Convert string at addr to addr + length
2137   8E71 97 86       	.WORD	C_DUP			;Duplicate top value on stack
2138   8E73 CB 8A       	.WORD	C_1PLUS			;1 plus
2139   8E75 B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
2140   8E77 FB 85       	.WORD	C_PLUS			;Add length of string +1
2141   8E79 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
2142   8E7B 0A 8E       	.WORD	C_TYPE			;Output n bytes from addr
2143   8E7D 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2144   8E7F             
2145   8E7F             W_QUOTE:				;Accept following text
2146   8E7F C2 2E A2    	.BYTE	0C2h,'.',22h+80h
2147   8E82 64 8E       	.WORD	W_CQUOTE
2148   8E84             C_QUOTE:
2149   8E84 64 87       	.WORD	E_COLON			;Interpret following word sequence
2150   8E86 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2151   8E88 22 00       	.WORD	0022h
2152   8E8A 01 89       	.WORD	C_STATE			;Push STATE addr
2153   8E8C EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2154   8E8E B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2155   8E90 12 00       	.WORD	B000A-$			;0012h
2156   8E92 1C 8D       	.WORD	C_COMPILE		;Compile next word into dictionary
2157   8E94 6B 8E       	.WORD	C_CQUOTE		;
2158   8E96 ED 8F       	.WORD	C_WORD
2159   8E98 F9 86       	.WORD	C_CFETCH		;Get byte from addr on stack
2160   8E9A CB 8A       	.WORD	C_1PLUS			;1 plus
2161   8E9C 0F 8B       	.WORD	C_ALLOT
2162   8E9E 98 82       	.WORD	C_BRANCH		;Add following offset to BC
2163   8EA0 08 00       	.WORD	B000B-$			;0008h
2164   8EA2             B000A:
2165   8EA2 ED 8F       	.WORD	C_WORD
2166   8EA4 F7 8D       	.WORD	C_COUNT			;Convert string at addr to addr + length
2167   8EA6 0A 8E       	.WORD	C_TYPE			;Output n bytes from addr
2168   8EA8             B000B:
2169   8EA8 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2170   8EAA             
2171   8EAA             W_EXPECT:
2172   8EAA 864558504543	.BYTE	86h,"EXPEC",'T'+80h
2172   8EB0 D4
2173   8EB1 7F 8E       	.WORD	W_QUOTE
2174   8EB3             C_EXPECT:
2175   8EB3 64 87       	.WORD	E_COLON			;Interpret following word sequence
2176   8EB5 5F 86       	.WORD	C_OVER			;Copy buffer start addr
2177   8EB7 FB 85       	.WORD	C_PLUS			;Add to length to give start,end
2178   8EB9 5F 86       	.WORD	C_OVER			;Copy start
2179   8EBB 0A 83       	.WORD	C_LDO			;Put start & end loop values on RPP
2180   8EBD             B0012:
2181   8EBD 13 84       	.WORD	C_KEY			;Wait for key, value on stack
2182   8EBF 97 86       	.WORD	C_DUP			;Duplicate key value
2183   8EC1 74 82       	.WORD	C_LIT			;Push backspace addr
2184   8EC3 06 82       	.WORD	BACKSPACE		;
2185   8EC5 EA 86       	.WORD	C_FETCH			;Get backspace value
2186   8EC7 51 8B       	.WORD	C_EQUALS		;Was it backspace ?
2187   8EC9 B0 82       	.WORD	C_0BRANCH		;If not then jump
2188   8ECB 2A 00       	.WORD	B000C-$			;002Ah
2189   8ECD 6E 86       	.WORD	C_DROP			;Drop top value from stack
2190   8ECF 97 86       	.WORD	C_DUP			;Duplicate top value on stack
2191   8ED1 26 83       	.WORD	C_I			;Copy LOOP index to data stack
2192   8ED3 51 8B       	.WORD	C_EQUALS
2193   8ED5 97 86       	.WORD	C_DUP			;Duplicate top value on stack
2194   8ED7 B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
2195   8ED9 EB 87       	.WORD	C_2
2196   8EDB 3C 8B       	.WORD	C_MINUS
2197   8EDD FB 85       	.WORD	C_PLUS			;n1 + n2
2198   8EDF 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
2199   8EE1 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2200   8EE3 0A 00       	.WORD	B000D-$			;000Ah
2201   8EE5 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2202   8EE7 07 00       	.WORD	0007h
2203   8EE9 98 82       	.WORD	C_BRANCH		;Add following offset to BC
2204   8EEB 06 00       	.WORD	B000E-$			;0006h
2205   8EED             B000D:
2206   8EED 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2207   8EEF 08 00       	.WORD	0008h
2208   8EF1             B000E:
2209   8EF1 98 82       	.WORD	C_BRANCH		;Add following offset to BC
2210   8EF3 28 00       	.WORD	B000F-$			;0028h
2211   8EF5             B000C:
2212   8EF5 97 86       	.WORD	C_DUP			;Duplicate key value
2213   8EF7 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2214   8EF9 0D 00       	.WORD	000Dh			;CR
2215   8EFB 51 8B       	.WORD	C_EQUALS		;Was it cariage return
2216   8EFD B0 82       	.WORD	C_0BRANCH		;If not then jump
2217   8EFF 0E 00       	.WORD	B0010-$			;000Eh
2218   8F01 89 85       	.WORD	C_LEAVE			;Quit loop by making index = limit
2219   8F03 6E 86       	.WORD	C_DROP			;Drop top value from stack
2220   8F05 FC 87       	.WORD	C_BL			;Leaves ASCII for space on stack
2221   8F07 DB 87       	.WORD	C_ZERO			;Put zero on stack
2222   8F09 98 82       	.WORD	C_BRANCH		;Add following offset to BC
2223   8F0B 04 00       	.WORD	B0011-$			;0004h
2224   8F0D             B0010:
2225   8F0D 97 86       	.WORD	C_DUP			;Duplicate key value
2226   8F0F             B0011:
2227   8F0F 26 83       	.WORD	C_I			;Copy LOOP index to data stack
2228   8F11 30 87       	.WORD	C_CSTORE		;Store byte at addr
2229   8F13 DB 87       	.WORD	C_ZERO			;Put zero on stack
2230   8F15 26 83       	.WORD	C_I			;Copy LOOP index to data stack
2231   8F17 CB 8A       	.WORD	C_1PLUS			;1 plus
2232   8F19 21 87       	.WORD	C_STORE			;Store word at addr
2233   8F1B             B000F:
2234   8F1B FD 83       	.WORD	C_EMIT			;Output CHR from stack
2235   8F1D C5 82       	.WORD	C_LLOOP			;Increment loop & branch if not done
2236   8F1F 9E FF       	.WORD	B0012-$			;FF9Eh
2237   8F21 6E 86       	.WORD	C_DROP			;Drop top value from stack
2238   8F23 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2239   8F25             
2240   8F25             W_QUERY:
2241   8F25 8551554552D9	.BYTE	85h,"QUER",'Y'+80h
2242   8F2B AA 8E       	.WORD	W_EXPECT
2243   8F2D             C_QUERY:
2244   8F2D 64 87       	.WORD	E_COLON			;Interpret following word sequence
2245   8F2F 66 88       	.WORD	C_TIB			;Put TIB addr on stack
2246   8F31 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2247   8F33 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2248   8F35 50 00       	.WORD	0050h			;Max line length 50h
2249   8F37 B3 8E       	.WORD	C_EXPECT		;Get line
2250   8F39 DB 87       	.WORD	C_ZERO			;Put zero on stack
2251   8F3B B8 88       	.WORD	C_TOIN			;Current input buffer offset
2252   8F3D 21 87       	.WORD	C_STORE			;Store word at addr
2253   8F3F 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2254   8F41             
2255   8F41             W_NULL:
2256   8F41 C1 80       	.BYTE	0C1h,80h
2257   8F43 25 8F       	.WORD	W_QUERY
2258   8F45             C_NULL:
2259   8F45 64 87       	.WORD	E_COLON			;Interpret following word sequence
2260   8F47 AE 88       	.WORD	C_BLK
2261   8F49 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2262   8F4B B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2263   8F4D 2A 00       	.WORD	B0013-$			;002Ah
2264   8F4F E3 87       	.WORD	C_1			;Put 1 on stack
2265   8F51 AE 88       	.WORD	C_BLK
2266   8F53 C5 86       	.WORD	C_PLUSSTORE		;Add n1 to addr
2267   8F55 DB 87       	.WORD	C_ZERO			;Put zero on stack
2268   8F57 B8 88       	.WORD	C_TOIN			;Current input buffer offset
2269   8F59 21 87       	.WORD	C_STORE			;Store word at addr
2270   8F5B AE 88       	.WORD	C_BLK
2271   8F5D EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2272   8F5F 46 88       	.WORD	C_BSCR			;Number of buffers per block on stack
2273   8F61 E3 87       	.WORD	C_1			;Put 1 on stack
2274   8F63 3C 8B       	.WORD	C_MINUS
2275   8F65 EE 84       	.WORD	C_AND			;AND
2276   8F67 CF 85       	.WORD	C_0EQUALS		;=0
2277   8F69 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2278   8F6B 08 00       	.WORD	B0014-$			;0008h
2279   8F6D BB 8C       	.WORD	C_QEXEC			;Error not if not in execute mode
2280   8F6F B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
2281   8F71 6E 86       	.WORD	C_DROP			;Drop top value from stack
2282   8F73             B0014:
2283   8F73 98 82       	.WORD	C_BRANCH		;Add following offset to BC
2284   8F75 06 00       	.WORD	B0015-$			;0006h
2285   8F77             B0013:
2286   8F77 B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
2287   8F79 6E 86       	.WORD	C_DROP			;Drop top value from stack
2288   8F7B             B0015:
2289   8F7B 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2290   8F7D             
2291   8F7D             W_FILL:					;Fill with byte n bytes from addr
2292   8F7D 8446494CCC  	.BYTE	84h,"FIL",'L'+80h
2293   8F82 41 8F       	.WORD	W_NULL
2294   8F84             C_FILL:
2295   8F84 86 8F       	.WORD	2+$			;Vector to code
2296   8F86 69          	LD	L,C			;Save BC for now
2297   8F87 60          	LD	H,B			;
2298   8F88 D1          	POP	DE			; get byte
2299   8F89 C1          	POP	BC			; get n
2300   8F8A E3          	EX	(SP),HL			; get addr and save BC
2301   8F8B EB          	EX	DE,HL			;
2302   8F8C             NEXT_BYTE:
2303   8F8C 78          	LD	A,B			;Test count
2304   8F8D B1          	OR	C			;
2305   8F8E 28 06       	JR	Z,NO_COUNT		;If 0 we're done
2306   8F90 7D          	LD	A,L			;Byte into A
2307   8F91 12          	LD	(DE),A			;Save byte
2308   8F92 13          	INC	DE			;Next addr
2309   8F93 0B          	DEC	BC			;Decr count
2310   8F94 18 F6       	JR	NEXT_BYTE		;Loop
2311   8F96             NO_COUNT:
2312   8F96 C1          	POP	BC			;Get BC back
2313   8F97 C3 4E 82    	JP	NEXT
2314   8F9A             
2315   8F9A             W_ERASE:				;Fill addr & length from stack with 0
2316   8F9A 8545524153C5	.BYTE	85h,"ERAS",'E'+80h
2317   8FA0 7D 8F       	.WORD	W_FILL
2318   8FA2             C_ERASE:
2319   8FA2 64 87       	.WORD	E_COLON			;Interpret following word sequence
2320   8FA4 DB 87       	.WORD	C_ZERO			;Put zero on stack
2321   8FA6 84 8F       	.WORD	C_FILL			;Fill with byte n bytes from addr
2322   8FA8 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2323   8FAA             
2324   8FAA             W_BLANKS:				;Fill addr & length from stack with [SP]
2325   8FAA 86424C414E4B	.BYTE	86h,"BLANK",'S'+80h
2325   8FB0 D3
2326   8FB1 9A 8F       	.WORD	W_ERASE
2327   8FB3             C_BLANKS:
2328   8FB3 64 87       	.WORD	E_COLON			;Interpret following word sequence
2329   8FB5 FC 87       	.WORD	C_BL			;Leaves ASCII for space on stack
2330   8FB7 84 8F       	.WORD	C_FILL			;Fill with byte n bytes from addr
2331   8FB9 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2332   8FBB             
2333   8FBB             W_HOLD:
2334   8FBB 84484F4CC4  	.BYTE	84h,"HOL",'D'+80h
2335   8FC0 AA 8F       	.WORD	W_BLANKS
2336   8FC2             C_HOLD:
2337   8FC2 64 87       	.WORD	E_COLON			;Interpret following word sequence
2338   8FC4 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2339   8FC6 FF FF       	.WORD	0FFFFh
2340   8FC8 3D 89       	.WORD	C_HLD
2341   8FCA C5 86       	.WORD	C_PLUSSTORE		;Add n1 to addr
2342   8FCC 3D 89       	.WORD	C_HLD
2343   8FCE EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2344   8FD0 30 87       	.WORD	C_CSTORE		;Store byte at addr
2345   8FD2 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2346   8FD4             
2347   8FD4             W_PAD:
2348   8FD4 83 50 41 C4 	.BYTE	83h,"PA",'D'+80h
2349   8FD8 BB 8F       	.WORD	W_HOLD
2350   8FDA             C_PAD:
2351   8FDA 64 87       	.WORD	E_COLON			;Interpret following word sequence
2352   8FDC FF 8A       	.WORD	C_HERE			;Dictionary pointer onto stack
2353   8FDE 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2354   8FE0 44 00       	.WORD	0044h
2355   8FE2 FB 85       	.WORD	C_PLUS			;n1 + n2
2356   8FE4 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2357   8FE6             
2358   8FE6             W_WORD:
2359   8FE6 84574F52C4  	.BYTE	84h,"WOR",'D'+80h
2360   8FEB D4 8F       	.WORD	W_PAD
2361   8FED             C_WORD:
2362   8FED 64 87       	.WORD	E_COLON			;Interpret following word sequence
2363   8FEF AE 88       	.WORD	C_BLK
2364   8FF1 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2365   8FF3 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2366   8FF5 0C 00       	.WORD	B0016-$			;000Ch
2367   8FF7 AE 88       	.WORD	C_BLK
2368   8FF9 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2369   8FFB 05 96       	.WORD	C_BLOCK
2370   8FFD 98 82       	.WORD	C_BRANCH		;Add following offset to BC
2371   8FFF 06 00       	.WORD	B0017-$			;0006h
2372   9001             B0016:
2373   9001 66 88       	.WORD	C_TIB
2374   9003 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2375   9005             B0017:
2376   9005 B8 88       	.WORD	C_TOIN			;Current input buffer offset
2377   9007 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2378   9009 FB 85       	.WORD	C_PLUS			;n1 + n2
2379   900B 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
2380   900D B2 83       	.WORD	C_ENCLOSE
2381   900F FF 8A       	.WORD	C_HERE			;Dictionary pointer onto stack
2382   9011 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2383   9013 22 00       	.WORD	0022h
2384   9015 B3 8F       	.WORD	C_BLANKS
2385   9017 B8 88       	.WORD	C_TOIN			;Current input buffer offset
2386   9019 C5 86       	.WORD	C_PLUSSTORE		;Add n1 to addr
2387   901B 5F 86       	.WORD	C_OVER			;Copy 2nd down to top of stack
2388   901D 3C 8B       	.WORD	C_MINUS
2389   901F 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
2390   9021 C8 85       	.WORD	C_RFETCH		;Return stack top to data stack
2391   9023 FF 8A       	.WORD	C_HERE			;Dictionary pointer onto stack
2392   9025 30 87       	.WORD	C_CSTORE		;Store byte at addr
2393   9027 FB 85       	.WORD	C_PLUS			;n1 + n2
2394   9029 FF 8A       	.WORD	C_HERE			;Dictionary pointer onto stack
2395   902B CB 8A       	.WORD	C_1PLUS			;1 plus
2396   902D B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
2397   902F 56 84       	.WORD	C_CMOVE			;Move block
2398   9031 FF 8A       	.WORD	C_HERE			;Dictionary pointer onto stack
2399   9033 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2400   9035             
2401   9035             W_CONVERT:
2402   9035 87434F4E5645	.BYTE	87h,"CONVER",'T'+80h
2402   903B 52D4
2403   903D E6 8F       	.WORD	W_WORD
2404   903F             C_CONVERT:
2405   903F 64 87       	.WORD	E_COLON			;Interpret following word sequence
2406   9041             B001A:
2407   9041 CB 8A       	.WORD	C_1PLUS			;1 plus
2408   9043 97 86       	.WORD	C_DUP			;Duplicate top value on stack
2409   9045 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
2410   9047 F9 86       	.WORD	C_CFETCH		;Get byte from addr on stack
2411   9049 0C 89       	.WORD	C_BASE			;Put BASE addr on stack
2412   904B EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2413   904D 3A 83       	.WORD	C_DIGIT			;Convert digit n2 using base n1
2414   904F B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2415   9051 2C 00       	.WORD	B0018-$			;002Ch
2416   9053 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
2417   9055 0C 89       	.WORD	C_BASE			;Put BASE addr on stack
2418   9057 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2419   9059 6C 84       	.WORD	C_USTAR
2420   905B 6E 86       	.WORD	C_DROP			;Drop top value from stack
2421   905D AD 8B       	.WORD	C_ROT			;3rd value down to top of stack
2422   905F 0C 89       	.WORD	C_BASE			;Put BASE addr on stack
2423   9061 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2424   9063 6C 84       	.WORD	C_USTAR
2425   9065 08 86       	.WORD	C_DPLUS
2426   9067 16 89       	.WORD	C_DPL
2427   9069 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2428   906B CB 8A       	.WORD	C_1PLUS			;1 plus
2429   906D B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2430   906F 08 00       	.WORD	B0019-$			;0008h
2431   9071 E3 87       	.WORD	C_1			;Put 1 on stack
2432   9073 16 89       	.WORD	C_DPL
2433   9075 C5 86       	.WORD	C_PLUSSTORE		;Add n1 to addr
2434   9077             B0019:
2435   9077 B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
2436   9079 98 82       	.WORD	C_BRANCH		;Add following offset to BC
2437   907B C6 FF       	.WORD	B001A-$			;FFC6h
2438   907D             B0018:
2439   907D B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
2440   907F 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2441   9081             
2442   9081             W_NUMBER:
2443   9081 864E554D4245	.BYTE	86h,"NUMBE",'R'+80h
2443   9087 D2
2444   9088 35 90       	.WORD	W_CONVERT
2445   908A             C_NUMBER:
2446   908A 64 87       	.WORD	E_COLON			;Interpret following word sequence
2447   908C DB 87       	.WORD	C_ZERO			;Put zero on stack
2448   908E DB 87       	.WORD	C_ZERO			;Put zero on stack
2449   9090 AD 8B       	.WORD	C_ROT			;3rd value down to top of stack
2450   9092 97 86       	.WORD	C_DUP			;Duplicate top value on stack
2451   9094 CB 8A       	.WORD	C_1PLUS			;1 plus
2452   9096 F9 86       	.WORD	C_CFETCH		;Get byte from addr on stack
2453   9098 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2454   909A 2D 00       	.WORD	002Dh			;'-'
2455   909C 51 8B       	.WORD	C_EQUALS		;Is first chr = '-'
2456   909E 97 86       	.WORD	C_DUP			;Duplicate negative flag
2457   90A0 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
2458   90A2 FB 85       	.WORD	C_PLUS			;n1 + n2
2459   90A4 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2460   90A6 FF FF       	.WORD	0FFFFh			; -1
2461   90A8             B001C:
2462   90A8 16 89       	.WORD	C_DPL
2463   90AA 21 87       	.WORD	C_STORE			;Store word at addr
2464   90AC 3F 90       	.WORD	C_CONVERT
2465   90AE 97 86       	.WORD	C_DUP			;Duplicate top value on stack
2466   90B0 F9 86       	.WORD	C_CFETCH		;Get byte from addr on stack
2467   90B2 FC 87       	.WORD	C_BL			;Leaves ASCII for space on stack
2468   90B4 3C 8B       	.WORD	C_MINUS
2469   90B6 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2470   90B8 16 00       	.WORD	B001B-$			;0016h
2471   90BA 97 86       	.WORD	C_DUP			;Duplicate top value on stack
2472   90BC F9 86       	.WORD	C_CFETCH		;Get byte from addr on stack
2473   90BE 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2474   90C0 2E 00       	.WORD	002Eh			;'.'
2475   90C2 3C 8B       	.WORD	C_MINUS
2476   90C4 DB 87       	.WORD	C_ZERO			;Put zero on stack
2477   90C6 89 8C       	.WORD	C_QERROR
2478   90C8 DB 87       	.WORD	C_ZERO			;Put zero on stack
2479   90CA 98 82       	.WORD	C_BRANCH		;Add following offset to BC
2480   90CC DC FF       	.WORD	B001C-$			;FFDCh
2481   90CE             B001B:
2482   90CE 6E 86       	.WORD	C_DROP			;Drop top value from stack
2483   90D0 B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
2484   90D2 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2485   90D4 04 00       	.WORD	B001D-$			;0004h
2486   90D6 42 86       	.WORD	C_DNEGATE
2487   90D8             B001D:
2488   90D8 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2489   90DA             
2490   90DA             W_MFIND:
2491   90DA 852D46494EC4	.BYTE	85h,"-FIN",'D'+80h
2492   90E0 81 90       	.WORD	W_NUMBER
2493   90E2             C_MFIND:
2494   90E2 64 87       	.WORD	E_COLON			;Interpret following word sequence
2495   90E4 FC 87       	.WORD	C_BL			;Leaves ASCII for space on stack
2496   90E6 ED 8F       	.WORD	C_WORD
2497   90E8 E7 88       	.WORD	C_CONTEXT
2498   90EA EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2499   90EC EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2500   90EE 68 83       	.WORD	C_FIND			;Find word & return vector,byte & flag
2501   90F0 97 86       	.WORD	C_DUP			;Duplicate top value on stack
2502   90F2 CF 85       	.WORD	C_0EQUALS		;=0
2503   90F4 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2504   90F6 0A 00       	.WORD	B001E-$			;000Ah
2505   90F8 6E 86       	.WORD	C_DROP			;Drop top value from stack
2506   90FA FF 8A       	.WORD	C_HERE			;Dictionary pointer onto stack
2507   90FC 1D 8C       	.WORD	C_LATEST		;Push top words NFA
2508   90FE 68 83       	.WORD	C_FIND			;Find word & return vector,byte & flag
2509   9100             B001E:
2510   9100 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2511   9102             
2512   9102             W_CABORT:
2513   9102 873C41424F52	.BYTE	87h,"<ABORT",'>'+80h
2513   9108 54BE
2514   910A DA 90       	.WORD	W_MFIND
2515   910C             C_CABORT:
2516   910C 64 87       	.WORD	E_COLON			;Interpret following word sequence
2517   910E 44 93       	.WORD	C_ABORT
2518   9110 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2519   9112             
2520   9112             W_ERROR:
2521   9112 854552524FD2	.BYTE	85h,"ERRO",'R'+80h
2522   9118 02 91       	.WORD	W_CABORT
2523   911A             C_ERROR:
2524   911A 64 87       	.WORD	E_COLON			;Interpret following word sequence
2525   911C 80 88       	.WORD	C_WARNING		;Put WARNING addr on stack
2526   911E EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2527   9120 EA 85       	.WORD	C_0LESS			;Less than 0 leaves true
2528   9122 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2529   9124 04 00       	.WORD	B001F-$			;0004h
2530   9126 0C 91       	.WORD	C_CABORT
2531   9128             B001F:
2532   9128 FF 8A       	.WORD	C_HERE			;Dictionary pointer onto stack
2533   912A F7 8D       	.WORD	C_COUNT			;Convert string at addr to addr + length
2534   912C 0A 8E       	.WORD	C_TYPE			;Output n bytes from addr
2535   912E 6B 8E       	.WORD	C_CQUOTE		;Output following string
2536   9130 02          	.BYTE	S_END7-S_START7
2537   9131             S_START7:
2538   9131 3F 20       	.BYTE	"? "		;
2539   9133             S_END7:
2540   9133 4B 95       	.WORD	C_MESSAGE		;Output message
2541   9135 35 85       	.WORD	C_SPSTORE		;Set initial stack pointer value
2542   9137 AE 88       	.WORD	C_BLK
2543   9139 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2544   913B E1 8B       	.WORD	C_QUERYDUP
2545   913D B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2546   913F 08 00       	.WORD	B0020-$			;0008h
2547   9141 B8 88       	.WORD	C_TOIN			;Current input buffer offset
2548   9143 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2549   9145 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
2550   9147             B0020:
2551   9147 17 93       	.WORD	C_QUIT
2552   9149             
2553   9149             W_ID:					;Print definition name from name field addr
2554   9149 83 49 44 AE 	.BYTE	83h,"ID",'.'+80h
2555   914D 12 91       	.WORD	W_ERROR
2556   914F             C_ID:
2557   914F 64 87       	.WORD	E_COLON			;Interpret following word sequence
2558   9151 F7 8D       	.WORD	C_COUNT			;Convert string at addr to addr + length
2559   9153 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2560   9155 1F 00       	.WORD	001Fh			;Max length is 1Fh
2561   9157 EE 84       	.WORD	C_AND			;AND lenght with 1Fh
2562   9159 0A 8E       	.WORD	C_TYPE			;Output n bytes from addr
2563   915B D2 8B       	.WORD	C_SPACE			;Output space
2564   915D 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2565   915F             
2566   915F             C_XXX1:
2567   915F 64 87       	.WORD	E_COLON			;Interpret following word sequence
2568   9161 E2 90       	.WORD	C_MFIND			;Find name returns PFA,length,true or false
2569   9163 B0 82       	.WORD	C_0BRANCH		;Branch if name not found
2570   9165 10 00       	.WORD	B0021-$			;0010h
2571   9167 6E 86       	.WORD	C_DROP			;Drop length
2572   9169 4B 8C       	.WORD	C_NFA			;Convert PFA to NFA
2573   916B 4F 91       	.WORD	C_ID			;Print definition name from name field addr
2574   916D 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2575   916F 04 00       	.WORD	0004h			;Message 4, name defined twice
2576   9171 4B 95       	.WORD	C_MESSAGE		;Output message
2577   9173 D2 8B       	.WORD	C_SPACE			;Output space
2578   9175             B0021:
2579   9175 FF 8A       	.WORD	C_HERE			;Dictionary pointer onto stack
2580   9177 97 86       	.WORD	C_DUP			;Duplicate top value on stack
2581   9179 F9 86       	.WORD	C_CFETCH		;Get byte from addr on stack
2582   917B 72 88       	.WORD	C_WIDTH
2583   917D EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2584   917F 28 94       	.WORD	C_MIN
2585   9181 CB 8A       	.WORD	C_1PLUS			;1 plus
2586   9183 0F 8B       	.WORD	C_ALLOT			;Which ever is smallest width or namelength
2587   9185 97 86       	.WORD	C_DUP			;Duplicate top value on stack
2588   9187 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2589   9189 A0 00       	.WORD	00A0h
2590   918B DC 86       	.WORD	C_TOGGLE		;XOR (addr) with byte
2591   918D FF 8A       	.WORD	C_HERE			;Dictionary pointer onto stack
2592   918F E3 87       	.WORD	C_1			;Put 1 on stack
2593   9191 3C 8B       	.WORD	C_MINUS
2594   9193 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2595   9195 80 00       	.WORD	0080h
2596   9197 DC 86       	.WORD	C_TOGGLE		;XOR (addr) with byte
2597   9199 1D 8C       	.WORD	C_LATEST		;Push top words NFA
2598   919B 1B 8B       	.WORD	C_COMMA			;Reserve 2 bytes and save n
2599   919D F5 88       	.WORD	C_CURRENT
2600   919F EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2601   91A1 21 87       	.WORD	C_STORE			;Store word at addr
2602   91A3 FF 8A       	.WORD	C_HERE			;Dictionary pointer onto stack
2603   91A5 D7 8A       	.WORD	C_2PLUS			;2 plus
2604   91A7 1B 8B       	.WORD	C_COMMA			;Reserve 2 bytes and save n
2605   91A9 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2606   91AB             
2607   91AB             W_CCOMPILE:
2608   91AB 895B434F4D50	.BYTE	89h,"[COMPILE",']'+80h
2608   91B1 494C45DD
2609   91B5 49 91       	.WORD	W_ID
2610   91B7             C_CCOMPILE:
2611   91B7 64 87       	.WORD	E_COLON			;Interpret following word sequence
2612   91B9 E2 90       	.WORD	C_MFIND
2613   91BB CF 85       	.WORD	C_0EQUALS		;=0
2614   91BD DB 87       	.WORD	C_ZERO			;Put zero on stack
2615   91BF 89 8C       	.WORD	C_QERROR
2616   91C1 6E 86       	.WORD	C_DROP			;Drop top value from stack
2617   91C3 3D 8C       	.WORD	C_CFA			;Convert PFA to CFA
2618   91C5 1B 8B       	.WORD	C_COMMA			;Reserve 2 bytes and save n
2619   91C7 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2620   91C9             
2621   91C9             W_LITERAL:
2622   91C9 C74C49544552	.BYTE	0C7h,"LITERA",'L'+80h
2622   91CF 41CC
2623   91D1 AB 91       	.WORD	W_CCOMPILE
2624   91D3             C_LITERAL:
2625   91D3 64 87       	.WORD	E_COLON			;Interpret following word sequence
2626   91D5 01 89       	.WORD	C_STATE			;Push STATE addr
2627   91D7 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2628   91D9 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2629   91DB 08 00       	.WORD	B0022-$			;0008h
2630   91DD 1C 8D       	.WORD	C_COMPILE		;Compile next word into dictionary
2631   91DF 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2632   91E1 1B 8B       	.WORD	C_COMMA			;Reserve 2 bytes and save n
2633   91E3             B0022:
2634   91E3 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2635   91E5             
2636   91E5             W_DLITERAL:
2637   91E5 C8444C495445	.BYTE	0C8h,"DLITERA",'L'+80h
2637   91EB 5241CC
2638   91EE C9 91       	.WORD	W_LITERAL
2639   91F0             C_DLITERAL:
2640   91F0 64 87       	.WORD	E_COLON			;Interpret following word sequence
2641   91F2 01 89       	.WORD	C_STATE			;Push STATE addr
2642   91F4 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2643   91F6 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2644   91F8 08 00       	.WORD	B0023-$			;0008h
2645   91FA 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
2646   91FC D3 91       	.WORD	C_LITERAL
2647   91FE D3 91       	.WORD	C_LITERAL
2648   9200             B0023:
2649   9200 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2650   9202             
2651   9202             W_QSTACK:
2652   9202 863F53544143	.BYTE	86h,"?STAC",'K'+80h
2652   9208 CB
2653   9209 E5 91       	.WORD	W_DLITERAL
2654   920B             C_QSTACK:
2655   920B 64 87       	.WORD	E_COLON			;Interpret following word sequence
2656   920D 26 85       	.WORD	C_SPFETCH		;Stack pointer onto stack
2657   920F 53 88       	.WORD	C_S0			;Push S0 (initial data stack pointer)
2658   9211 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2659   9213 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
2660   9215 7F 8B       	.WORD	C_ULESS			;IF stack-1 < stack_top leave true flag
2661   9217 E3 87       	.WORD	C_1			;Put 1 on stack
2662   9219 89 8C       	.WORD	C_QERROR
2663   921B 26 85       	.WORD	C_SPFETCH		;Stack pointer onto stack
2664   921D FF 8A       	.WORD	C_HERE			;Dictionary pointer onto stack
2665   921F 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2666   9221 80 00       	.WORD	0080h
2667   9223 FB 85       	.WORD	C_PLUS			;n1 + n2
2668   9225 7F 8B       	.WORD	C_ULESS			;IF stack-1 < stack_top leave true flag
2669   9227 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2670   9229 07 00       	.WORD	0007h
2671   922B 89 8C       	.WORD	C_QERROR
2672   922D 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2673   922F             
2674   922F             W_INTERPRET:
2675   922F 89494E544552	.BYTE	89h,"INTERPRE",'T'+80h
2675   9235 505245D4
2676   9239 02 92       	.WORD	W_QSTACK
2677   923B             C_INTERPRET:
2678   923B 64 87       	.WORD	E_COLON			;Interpret following word sequence
2679   923D             B002A:
2680   923D E2 90       	.WORD	C_MFIND			;Find name returns PFA,length,true or false
2681   923F B0 82       	.WORD	C_0BRANCH		;Branch if name not found
2682   9241 1E 00       	.WORD	NO_NAME-$		;
2683   9243 01 89       	.WORD	C_STATE			;STATE addr on stack
2684   9245 EA 86       	.WORD	C_FETCH			;Get STATE
2685   9247 5D 8B       	.WORD	C_LESSTHAN		;Is it quit compile word ?
2686   9249 B0 82       	.WORD	C_0BRANCH		;If so then branch
2687   924B 0A 00       	.WORD	B0025-$			;
2688   924D 3D 8C       	.WORD	C_CFA			;Convert PFA to CFA
2689   924F 1B 8B       	.WORD	C_COMMA			;Reserve 2 bytes and save n
2690   9251 98 82       	.WORD	C_BRANCH		;Add following offset to BC
2691   9253 06 00       	.WORD	B0026-$			;
2692   9255             B0025:
2693   9255 3D 8C       	.WORD	C_CFA			;Convert PFA to CFA
2694   9257 89 82       	.WORD	C_EXECUTE		;Jump to address on stack
2695   9259             B0026:
2696   9259 0B 92       	.WORD	C_QSTACK		;Error message if stack underflow
2697   925B 98 82       	.WORD	C_BRANCH		;Add following offset to BC
2698   925D 1C 00       	.WORD	B0027-$			;
2699   925F             NO_NAME:
2700   925F FF 8A       	.WORD	C_HERE			;Dictionary pointer onto stack
2701   9261 8A 90       	.WORD	C_NUMBER		;Convert string at addr to double
2702   9263 16 89       	.WORD	C_DPL			;
2703   9265 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2704   9267 CB 8A       	.WORD	C_1PLUS			;1 plus
2705   9269 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2706   926B 08 00       	.WORD	B0028-$			;
2707   926D F0 91       	.WORD	C_DLITERAL
2708   926F 98 82       	.WORD	C_BRANCH		;Add following offset to BC
2709   9271 06 00       	.WORD	B0029-$			;
2710   9273             B0028:
2711   9273 6E 86       	.WORD	C_DROP			;Drop top value from stack
2712   9275 D3 91       	.WORD	C_LITERAL
2713   9277             B0029:
2714   9277 0B 92       	.WORD	C_QSTACK		;Error message if stack underflow
2715   9279             B0027:
2716   9279 98 82       	.WORD	C_BRANCH		;Add following offset to BC
2717   927B C2 FF       	.WORD	B002A-$			;FFC2h
2718   927D             
2719   927D             W_IMMEDIATE:
2720   927D 89494D4D4544	.BYTE	89h,"IMMEDIAT",'E'+80h
2720   9283 494154C5
2721   9287 2F 92       	.WORD	W_INTERPRET
2722   9289             C_IMMEDIATE:
2723   9289 64 87       	.WORD	E_COLON			;Interpret following word sequence
2724   928B 1D 8C       	.WORD	C_LATEST		;Push top words NFA
2725   928D 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2726   928F 40 00       	.WORD	0040h
2727   9291 DC 86       	.WORD	C_TOGGLE		;XOR (addr) with byte
2728   9293 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2729   9295             
2730   9295             W_VOCABULARY:
2731   9295 8A564F434142	.BYTE	8Ah,"VOCABULAR",'Y'+80h
2731   929B 554C4152D9
2732   92A0 7D 92       	.WORD	W_IMMEDIATE
2733   92A2             C_VOCABULARY:
2734   92A2 64 87       	.WORD	E_COLON			;Interpret following word sequence
2735   92A4 C0 8D       	.WORD	C_CREATE
2736   92A6 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2737   92A8 81 A0       	.WORD	0A081h
2738   92AA 1B 8B       	.WORD	C_COMMA			;Reserve 2 bytes and save n
2739   92AC F5 88       	.WORD	C_CURRENT
2740   92AE EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2741   92B0 3D 8C       	.WORD	C_CFA			;Convert PFA to CFA
2742   92B2 1B 8B       	.WORD	C_COMMA			;Reserve 2 bytes and save n
2743   92B4 FF 8A       	.WORD	C_HERE			;Dictionary pointer onto stack
2744   92B6 A4 88       	.WORD	C_VOC_LINK
2745   92B8 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2746   92BA 1B 8B       	.WORD	C_COMMA			;Reserve 2 bytes and save n
2747   92BC A4 88       	.WORD	C_VOC_LINK
2748   92BE 21 87       	.WORD	C_STORE			;Store word at addr
2749   92C0 D0 8D       	.WORD	C_DOES
2750   92C2 D7 8A       	.WORD	C_2PLUS			;2 plus
2751   92C4 E7 88       	.WORD	C_CONTEXT
2752   92C6 21 87       	.WORD	C_STORE			;Store word at addr
2753   92C8 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2754   92CA             
2755   92CA             C_LINK:
2756   92CA D7 8A       	.WORD	C_2PLUS			;2 plus
2757   92CC EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2758   92CE E7 88       	.WORD	C_CONTEXT
2759   92D0 21 87       	.WORD	C_STORE			;Store word at addr
2760   92D2 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2761   92D4             
2762   92D4             W_FORTH:
2763   92D4 C5464F5254C8	.BYTE	0C5h,"FORT",'H'+80h
2764   92DA 95 92       	.WORD	W_VOCABULARY
2765   92DC             C_FORTH:
2766   92DC DC 8D       	.WORD	X_DOES
2767   92DE CA 92       	.WORD	C_LINK
2768   92E0             
2769   92E0 81 20       	.BYTE	81h," "+80h
2770   92E2 34 FE       	.WORD	FLAST+2
2771   92E4             E_FORTH:
2772   92E4 00 00       	.WORD	0000h
2773   92E6             
2774   92E6             W_DEFINITIONS:				;Set CURRENT as CONTEXT vocabulary
2775   92E6 8B444546494E	.BYTE	8Bh,"DEFINITION",'S'+80h
2775   92EC 4954494F4ED3
2776   92F2 D4 92       	.WORD	W_FORTH
2777   92F4             C_DEFINITIONS:
2778   92F4 64 87       	.WORD	E_COLON			;Interpret following word sequence
2779   92F6 E7 88       	.WORD	C_CONTEXT		;Get CONTEXT addr
2780   92F8 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2781   92FA F5 88       	.WORD	C_CURRENT		;Get CURRENT addr
2782   92FC 21 87       	.WORD	C_STORE			;Set CURRENT as the context vocabulary
2783   92FE 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2784   9300             
2785   9300             W_OPENBRKT:
2786   9300 C1 A8       	.BYTE	0C1h,'('+80h
2787   9302 E6 92       	.WORD	W_DEFINITIONS
2788   9304             C_OPENBRKT:
2789   9304 64 87       	.WORD	E_COLON			;Interpret following word sequence
2790   9306 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2791   9308 29 00       	.WORD	0029h
2792   930A ED 8F       	.WORD	C_WORD
2793   930C 6E 86       	.WORD	C_DROP			;Drop top value from stack
2794   930E 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2795   9310             
2796   9310             ;		This it the last thing ever executed and is the interpreter
2797   9310             ;		outer loop. This NEVER quits.
2798   9310             
2799   9310             W_QUIT:
2800   9310 84515549D4  	.BYTE	84h,"QUI",'T'+80h
2801   9315 00 93       	.WORD	W_OPENBRKT
2802   9317             C_QUIT:
2803   9317 64 87       	.WORD	E_COLON			;Interpret following word sequence
2804   9319 DB 87       	.WORD	C_ZERO			;Put zero on stack
2805   931B AE 88       	.WORD	C_BLK			;Get current BLK pointer
2806   931D 21 87       	.WORD	C_STORE			;Set BLK to 0
2807   931F 32 8D       	.WORD	C_LEFTBRKT		;Set STATE to execute
2808   9321             B002C:
2809   9321 5A 85       	.WORD	C_RPSTORE		;Set initial return stack pointer
2810   9323 34 84       	.WORD	C_CR			;Output [CR][LF]
2811   9325 2D 8F       	.WORD	C_QUERY			;Get string from input, ends in CR
2812   9327 3B 92       	.WORD	C_INTERPRET		;Interpret input stream
2813   9329 01 89       	.WORD	C_STATE			;Push STATE addr
2814   932B EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2815   932D CF 85       	.WORD	C_0EQUALS		;=0
2816   932F B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2817   9331 07 00       	.WORD	S_END8-$		;0007h
2818   9333 6B 8E       	.WORD	C_CQUOTE		;Output following string
2819   9335 02          	.BYTE	S_END8-S_START8
2820   9336             S_START8:
2821   9336 4F 4B       	.BYTE	"OK"
2822   9338             S_END8:
2823   9338 98 82       	.WORD	C_BRANCH		;Add following offset to BC
2824   933A E7 FF       	.WORD	B002C-$			;FFE7h
2825   933C             
2826   933C             W_ABORT:
2827   933C 8541424F52D4	.BYTE	85h,"ABOR",'T'+80h
2828   9342 10 93       	.WORD	W_QUIT
2829   9344             C_ABORT:
2830   9344 64 87       	.WORD	E_COLON			;Interpret following word sequence
2831   9346 C6 89       	.WORD	C_UABORT		;Put UABORT on stack
2832   9348 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
2833   934A 89 82       	.WORD	C_EXECUTE		;Jump to address on stack
2834   934C 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2835   934E             
2836   934E             CF_UABORT:
2837   934E 64 87       	.WORD	E_COLON			;Interpret following word sequence
2838   9350 35 85       	.WORD	C_SPSTORE		;Set initial stack pointer value
2839   9352 7D 8D       	.WORD	C_DECIMAL		;Sets decimal mode
2840   9354 0B 92       	.WORD	C_QSTACK		;Error message if stack underflow
2841   9356 34 84       	.WORD	C_CR			;Output [CR][LF]
2842   9358 6B 8E       	.WORD	C_CQUOTE		;Output following string
2843   935A 0D          	.BYTE	S_END1-S_START1		;String length
2844   935B             S_START1:
2845   935B 2A205A383020	.BYTE	"* Z80 FORTH *"
2845   9361 464F525448202A
2846   9368             S_END1:
2847   9368 DC 92       	.WORD	C_FORTH
2848   936A F4 92       	.WORD	C_DEFINITIONS		;Set CURRENT as CONTEXT vocabulary
2849   936C 17 93       	.WORD	C_QUIT
2850   936E             
2851   936E             W_WARM:
2852   936E 84574152CD  	.BYTE	84h,"WAR",'M'+80h
2853   9373 3C 93       	.WORD	W_ABORT
2854   9375             C_WARM:
2855   9375 64 87       	.WORD	E_COLON			;Interpret following word sequence
2856   9377 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2857   9379 08 82       	.WORD	WORD1			;Start of detault table
2858   937B 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2859   937D 06 FE       	.WORD	S0			;S0 addr
2860   937F 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2861   9381 10 00       	.WORD	START_TABLE-WORD1	;(000Ch) Table length
2862   9383 56 84       	.WORD	C_CMOVE			;Move block
2863   9385 44 93       	.WORD	C_ABORT
2864   9387             
2865   9387             X_COLD:
2866   9387             
2867   9387 21 18 82    	LD	HL,START_TABLE	        ;Copy table to ram
2868   938A 11 32 FE    	LD	DE,FLAST		        ;Where the table's going
2869   938D 01 34 00    	LD	BC,NEXTS2-START_TABLE	;Bytes to copy
2870   9390 ED B0       	LDIR				   ;
2871   9392 21 00 9C    	LD	HL,W_TASK		   ; Copy TASK to ram
2872   9395 11 00 F0    	LD	DE,VOCAB_BASE	   ; Where it's going
2873   9398 01 0B 00    	LD	BC,W_TASKEND-W_TASK;Bytes to copy
2874   939B ED B0       	LDIR				   ;
2875   939D 01 A7 93    	LD	BC,FIRSTWORD	   ;BC to first forth word
2876   93A0 2A 08 82    	LD	HL,(WORD1)		;Get stack pointer
2877   93A3 F9          	LD	SP,HL			;Set it
2878   93A4 C3 4E 82    	JP	NEXT
2879   93A7             
2880   93A7             FIRSTWORD:
2881   93A7 B2 93       	.WORD	C_COLD
2882   93A9             
2883   93A9             W_COLD:
2884   93A9 84434F4CC4  	.BYTE	84h,"COL",'D'+80h
2885   93AE 6E 93       	.WORD	W_WARM
2886   93B0 87 93       	.WORD	X_COLD
2887   93B2             C_COLD:
2888   93B2 64 87       	.WORD	E_COLON			;Interpret following word sequence
2889   93B4 E0 95       	.WORD	C_EBUFFERS		;Clear pseudo disk buffer
2890   93B6 DB 87       	.WORD	C_ZERO			;Put zero on stack
2891   93B8 D9 88       	.WORD	C_OFFSET		;Put disk block offset on stack
2892   93BA 21 87       	.WORD	C_STORE			;Clear disk block offset
2893   93BC 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2894   93BE 08 82       	.WORD	WORD1			;Start of default table
2895   93C0 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2896   93C2 06 FE       	.WORD	S0			;S0 addr
2897   93C4 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
2898   93C6 10 00       	.WORD	START_TABLE-WORD1	;Block length on stack (0010h)
2899   93C8 56 84       	.WORD	C_CMOVE			;Move block
2900   93CA 44 93       	.WORD	C_ABORT
2901   93CC             
2902   93CC             W_SINGTODUB:				;Change single number to double
2903   93CC 84532D3EC4  	.BYTE	84h,"S->",'D'+80h
2904   93D1 A9 93       	.WORD	W_COLD
2905   93D3             C_SINGTODUB:
2906   93D3 D5 93       	.WORD	2+$			;Vector to code
2907   93D5 D1          	POP	DE			;Get number
2908   93D6 21 00 00    	LD	HL,0000h		;Assume +ve extend
2909   93D9 7A          	LD	A,D			;Check sign
2910   93DA E6 80       	AND	80h			;
2911   93DC 28 01       	JR	Z,IS_POS		;Really +ve so jump
2912   93DE 2B          	DEC	HL			;Make -ve extension
2913   93DF             IS_POS:
2914   93DF C3 4C 82    	JP	NEXTS2			;Save both & NEXT
2915   93E2             
2916   93E2             W_PLUSMINUS:
2917   93E2 82 2B AD    	.BYTE	82h,'+','-'+80h
2918   93E5 CC 93       	.WORD	W_SINGTODUB
2919   93E7             C_PLUSMINUS:
2920   93E7 64 87       	.WORD	E_COLON			;Interpret following word sequence
2921   93E9 EA 85       	.WORD	C_0LESS			;Less than 0
2922   93EB B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2923   93ED 04 00       	.WORD	B002D-$			;0004h
2924   93EF 2B 86       	.WORD	C_NEGATE		;Form 2s complement of n
2925   93F1             B002D:
2926   93F1 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2927   93F3             
2928   93F3             W_DPLUSMINUS:				;Add sign of n to double
2929   93F3 83 44 2B AD 	.BYTE	83h,"D+",'-'+80h
2930   93F7 E2 93       	.WORD	W_PLUSMINUS
2931   93F9             C_DPLUSMINUS:
2932   93F9 64 87       	.WORD	E_COLON			;Interpret following word sequence
2933   93FB EA 85       	.WORD	C_0LESS			;Less than 0
2934   93FD B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2935   93FF 04 00       	.WORD	B002E-$			;0004h
2936   9401 42 86       	.WORD	C_DNEGATE
2937   9403             B002E:
2938   9403 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2939   9405             
2940   9405             W_ABS:
2941   9405 83 41 42 D3 	.BYTE	83h,"AB",'S'+80h
2942   9409 F3 93       	.WORD	W_DPLUSMINUS
2943   940B             C_ABS:
2944   940B 64 87       	.WORD	E_COLON			;Interpret following word sequence
2945   940D 97 86       	.WORD	C_DUP			;Duplicate top value on stack
2946   940F E7 93       	.WORD	C_PLUSMINUS
2947   9411 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2948   9413             
2949   9413             W_DABS:
2950   9413 84444142D3  	.BYTE	84h,"DAB",'S'+80h
2951   9418 05 94       	.WORD	W_ABS
2952   941A             C_DABS:
2953   941A 64 87       	.WORD	E_COLON			;Interpret following word sequence
2954   941C 97 86       	.WORD	C_DUP			;Duplicate top value on stack
2955   941E F9 93       	.WORD	C_DPLUSMINUS		;Add sign of n to double
2956   9420 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2957   9422             
2958   9422             W_MIN:
2959   9422 83 4D 49 CE 	.BYTE	83h,"MI",'N'+80h
2960   9426 13 94       	.WORD	W_DABS
2961   9428             C_MIN:
2962   9428 64 87       	.WORD	E_COLON			;Interpret following word sequence
2963   942A A5 86       	.WORD	C_2DUP			;Dup top 2 values on stack
2964   942C 9F 8B       	.WORD	C_GREATER
2965   942E B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2966   9430 04 00       	.WORD	B002F-$			;0004h
2967   9432 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
2968   9434             B002F:
2969   9434 6E 86       	.WORD	C_DROP			;Drop top value from stack
2970   9436 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2971   9438             
2972   9438             W_MAX:
2973   9438 83 4D 41 D8 	.BYTE	83h,"MA",'X'+80h
2974   943C 22 94       	.WORD	W_MIN
2975   943E             C_MAX:
2976   943E 64 87       	.WORD	E_COLON			;Interpret following word sequence
2977   9440 A5 86       	.WORD	C_2DUP			;Dup top 2 values on stack
2978   9442 5D 8B       	.WORD	C_LESSTHAN
2979   9444 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
2980   9446 04 00       	.WORD	B0030-$			;0004h
2981   9448 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
2982   944A             B0030:
2983   944A 6E 86       	.WORD	C_DROP			;Drop top value from stack
2984   944C 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
2985   944E             
2986   944E             W_MTIMES:
2987   944E 82 4D AA    	.BYTE	82h,'M','*'+80h
2988   9451 38 94       	.WORD	W_MAX
2989   9453             C_MTIMES:
2990   9453 64 87       	.WORD	E_COLON			;Interpret following word sequence
2991   9455 A5 86       	.WORD	C_2DUP			;Dup top 2 values on stack
2992   9457 13 85       	.WORD	C_XOR			;Works out sign of result
2993   9459 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
2994   945B 0B 94       	.WORD	C_ABS
2995   945D 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
2996   945F 0B 94       	.WORD	C_ABS
2997   9461 6C 84       	.WORD	C_USTAR
2998   9463 B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
2999   9465 F9 93       	.WORD	C_DPLUSMINUS		;Add sign of n to double
3000   9467 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3001   9469             
3002   9469             W_MDIV:
3003   9469 82 4D AF    	.BYTE	82h,'M','/'+80h
3004   946C 4E 94       	.WORD	W_MTIMES
3005   946E             C_MDIV:
3006   946E 64 87       	.WORD	E_COLON			;Interpret following word sequence
3007   9470 5F 86       	.WORD	C_OVER			;Copy 2nd down to top of stack
3008   9472 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
3009   9474 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
3010   9476 1A 94       	.WORD	C_DABS
3011   9478 C8 85       	.WORD	C_RFETCH		;Return stack top to data stack
3012   947A 0B 94       	.WORD	C_ABS
3013   947C A1 84       	.WORD	C_UMOD			;Unsigned divide & MOD
3014   947E B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
3015   9480 C8 85       	.WORD	C_RFETCH		;Return stack top to data stack
3016   9482 13 85       	.WORD	C_XOR			;XOR
3017   9484 E7 93       	.WORD	C_PLUSMINUS
3018   9486 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
3019   9488 B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
3020   948A E7 93       	.WORD	C_PLUSMINUS
3021   948C 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
3022   948E 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3023   9490             
3024   9490             W_TIMES:
3025   9490 81 AA       	.BYTE	81h,'*'+80h
3026   9492 69 94       	.WORD	W_MDIV
3027   9494             C_TIMES:
3028   9494 64 87       	.WORD	E_COLON			;Interpret following word sequence
3029   9496 53 94       	.WORD	C_MTIMES
3030   9498 6E 86       	.WORD	C_DROP			;Drop top value from stack
3031   949A 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3032   949C             
3033   949C             W_DIVMOD:
3034   949C 842F4D4FC4  	.BYTE	84h,"/MO",'D'+80h
3035   94A1 90 94       	.WORD	W_TIMES
3036   94A3             C_DIVMOD:
3037   94A3 64 87       	.WORD	E_COLON			;Interpret following word sequence
3038   94A5 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
3039   94A7 D3 93       	.WORD	C_SINGTODUB		;Change single number to double
3040   94A9 B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
3041   94AB 6E 94       	.WORD	C_MDIV
3042   94AD 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3043   94AF             
3044   94AF             W_DIV:
3045   94AF 81 AF       	.BYTE	81h,'/'+80h
3046   94B1 9C 94       	.WORD	W_DIVMOD
3047   94B3             C_DIV:
3048   94B3 64 87       	.WORD	E_COLON			;Interpret following word sequence
3049   94B5 A3 94       	.WORD	C_DIVMOD
3050   94B7 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
3051   94B9 6E 86       	.WORD	C_DROP			;Drop top value from stack
3052   94BB 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3053   94BD             
3054   94BD             W_MOD:
3055   94BD 83 4D 4F C4 	.BYTE	83h,"MO",'D'+80h
3056   94C1 AF 94       	.WORD	W_DIV
3057   94C3             C_MOD:
3058   94C3 64 87       	.WORD	E_COLON			;Interpret following word sequence
3059   94C5 A3 94       	.WORD	C_DIVMOD
3060   94C7 6E 86       	.WORD	C_DROP			;Drop top value from stack
3061   94C9 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3062   94CB             
3063   94CB             W_TIMESDIVMOD:
3064   94CB 852A2F4D4FC4	.BYTE	85h,"*/MO",'D'+80h
3065   94D1 BD 94       	.WORD	W_MOD
3066   94D3             C_TIMESDIVMOD:
3067   94D3 64 87       	.WORD	E_COLON			;Interpret following word sequence
3068   94D5 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
3069   94D7 53 94       	.WORD	C_MTIMES
3070   94D9 B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
3071   94DB 6E 94       	.WORD	C_MDIV
3072   94DD 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3073   94DF             
3074   94DF             W_TIMESDIV:
3075   94DF 82 2A AF    	.BYTE	82h,'*','/'+80h
3076   94E2 CB 94       	.WORD	W_TIMESDIVMOD
3077   94E4             C_TIMESDIV:
3078   94E4 64 87       	.WORD	E_COLON			;Interpret following word sequence
3079   94E6 D3 94       	.WORD	C_TIMESDIVMOD
3080   94E8 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
3081   94EA 6E 86       	.WORD	C_DROP			;Drop top value from stack
3082   94EC 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3083   94EE             
3084   94EE             W_MDIVMOD:
3085   94EE 854D2F4D4FC4	.BYTE	85h,"M/MO",'D'+80h
3086   94F4 DF 94       	.WORD	W_TIMESDIV
3087   94F6             C_MDIVMOD:
3088   94F6 64 87       	.WORD	E_COLON			;Interpret following word sequence
3089   94F8 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
3090   94FA DB 87       	.WORD	C_ZERO			;Put zero on stack
3091   94FC C8 85       	.WORD	C_RFETCH		;Return stack top to data stack
3092   94FE A1 84       	.WORD	C_UMOD			;Unsigned divide & MOD
3093   9500 B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
3094   9502 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
3095   9504 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
3096   9506 A1 84       	.WORD	C_UMOD			;Unsigned divide & MOD
3097   9508 B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
3098   950A 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3099   950C             
3100   950C             W_CLINE:
3101   950C 863C4C494E45	.BYTE	86h,"<LINE",'>'+80h
3101   9512 BE
3102   9513 EE 94       	.WORD	W_MDIVMOD
3103   9515             C_CLINE:
3104   9515 64 87       	.WORD	E_COLON			;Interpret following word sequence
3105   9517 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
3106   9519 06 88       	.WORD	C_CL			;Put characters/line on stack
3107   951B 36 88       	.WORD	C_BBUF			;Put bytes per block on stack
3108   951D D3 94       	.WORD	C_TIMESDIVMOD
3109   951F B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
3110   9521 46 88       	.WORD	C_BSCR			;Number of buffers per block on stack
3111   9523 94 94       	.WORD	C_TIMES
3112   9525 FB 85       	.WORD	C_PLUS			;n1 + n2
3113   9527 05 96       	.WORD	C_BLOCK
3114   9529 FB 85       	.WORD	C_PLUS			;n1 + n2
3115   952B 06 88       	.WORD	C_CL			;Put characters/line on stack
3116   952D 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3117   952F             
3118   952F             W_DOTLINE:
3119   952F 852E4C494EC5	.BYTE	85h,".LIN",'E'+80h
3120   9535 0C 95       	.WORD	W_CLINE
3121   9537             C_DOTLINE:
3122   9537 64 87       	.WORD	E_COLON			;Interpret following word sequence
3123   9539 15 95       	.WORD	C_CLINE
3124   953B 38 8E       	.WORD	C_TRAILING
3125   953D 0A 8E       	.WORD	C_TYPE			;Output n bytes from addr
3126   953F 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3127   9541             
3128   9541             W_MESSAGE:
3129   9541 874D45535341	.BYTE	87h,"MESSAG",'E'+80h
3129   9547 47C5
3130   9549 2F 95       	.WORD	W_DOTLINE
3131   954B             C_MESSAGE:
3132   954B 64 87       	.WORD	E_COLON			;Interpret following word sequence
3133   954D 80 88       	.WORD	C_WARNING		;Put WARNING addr on stack
3134   954F EA 86       	.WORD	C_FETCH			;Get WARNING value
3135   9551 B0 82       	.WORD	C_0BRANCH		;If WARNING = 0 output MSG # n
3136   9553 1E 00       	.WORD	B0031-$			;001Eh
3137   9555 E1 8B       	.WORD	C_QUERYDUP
3138   9557 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3139   9559 14 00       	.WORD	B0032-$			;0014h
3140   955B 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3141   955D 04 00       	.WORD	0004h
3142   955F D9 88       	.WORD	C_OFFSET		;Put disk block offset on stack
3143   9561 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
3144   9563 46 88       	.WORD	C_BSCR			;Number of buffers per block on stack
3145   9565 B3 94       	.WORD	C_DIV
3146   9567 3C 8B       	.WORD	C_MINUS
3147   9569 37 95       	.WORD	C_DOTLINE		;Output line from screen
3148   956B D2 8B       	.WORD	C_SPACE			;Output space
3149   956D             B0032:
3150   956D 98 82       	.WORD	C_BRANCH		;Add following offset to BC
3151   956F 0D 00       	.WORD	B0033-$			;000Dh
3152   9571             B0031:
3153   9571 6B 8E       	.WORD	C_CQUOTE		;Output following string
3154   9573 06          		.BYTE	S_END2-S_START2
3155   9574             S_START2:
3156   9574 4D5347202320	.BYTE	"MSG # "
3157   957A             S_END2:
3158   957A 38 99       	.WORD	C_DOT
3159   957C             B0033:
3160   957C 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3161   957E             
3162   957E             W_PORTIN:				;Fetch data from port
3163   957E 82 50 C0    	.BYTE	82h,'P','@'+80h
3164   9581 41 95       	.WORD	W_MESSAGE
3165   9583             C_PORTIN:
3166   9583 85 95       	.WORD	2+$			;Vector to code
3167   9585 D1          	POP	DE			;Get port addr
3168   9586 21 41 FE    	LD	HL,PAT+1		;Save in port in code
3169   9589 73          	LD	(HL),E			;
3170   958A CD 40 FE    	CALL	PAT			;Call port in routine
3171   958D 6F          	LD	L,A			;Save result
3172   958E 26 00       	LD	H,00h			;
3173   9590 C3 4D 82    	JP	NEXTS1			;Save & NEXT
3174   9593             
3175   9593             W_PORTOUT:				;Save data to port
3176   9593 82 50 A1    	.BYTE	82h,'P','!'+80h
3177   9596 7E 95       	.WORD	W_PORTIN
3178   9598             C_PORTOUT:
3179   9598 9A 95       	.WORD	2+$			;Vector to code
3180   959A D1          	POP	DE			;Get port addr
3181   959B 21 44 FE    	LD	HL,PST+1		;Save in port out code
3182   959E 73          	LD	(HL),E			;
3183   959F E1          	POP	HL			;
3184   95A0 7D          	LD	A,L			;Byte to A
3185   95A1 CD 43 FE    	CALL	PST			;Call port out routine
3186   95A4 C3 4E 82    	JP	NEXT
3187   95A7             
3188   95A7             W_USE:
3189   95A7 83 55 53 C5 	.BYTE	83h,"US",'E'+80h
3190   95AB 93 95       	.WORD	W_PORTOUT
3191   95AD             C_USE:
3192   95AD CB 87       	.WORD	X_USER			;Put next word on stack then do next
3193   95AF 48 00       	.WORD	USE-SYSTEM
3194   95B1             
3195   95B1             W_PREV:
3196   95B1 84505245D6  	.BYTE	84h,"PRE",'V'+80h
3197   95B6 A7 95       	.WORD	W_USE
3198   95B8             C_PREV:
3199   95B8 CB 87       	.WORD	X_USER			;Put next word on stack then do next
3200   95BA 4A 00       	.WORD	PREV-SYSTEM
3201   95BC             
3202   95BC             W_PLUSBUF:
3203   95BC 842B4255C6  	.BYTE	84h,"+BU",'F'+80h
3204   95C1 B1 95       	.WORD	W_PREV
3205   95C3             C_PLUSBUF:
3206   95C3 4E 82       	.WORD	NEXT
3207   95C5             
3208   95C5             W_UPDATE:
3209   95C5 865550444154	.BYTE	86h,"UPDAT",'E'+80h
3209   95CB C5
3210   95CC BC 95       	.WORD	W_PLUSBUF
3211   95CE             C_UPDATE:
3212   95CE 4E 82       	.WORD	NEXT
3213   95D0             
3214   95D0             W_EBUFFERS:				;Clear pseudo disk buffer
3215   95D0 8D454D505459	.BYTE	8Dh,"EMPTY-BUFFER",'S'+80h
3215   95D6 2D425546464552D3
3216   95DE C5 95       	.WORD	W_UPDATE
3217   95E0             C_EBUFFERS:
3218   95E0 64 87       	.WORD	E_COLON			;Interpret following word sequence
3219   95E2 16 88       	.WORD	C_FIRST			;Start of pseudo disk onto stack
3220   95E4 26 88       	.WORD	C_LIMIT			;End of pseudo disk onto stack
3221   95E6 5F 86       	.WORD	C_OVER			;Start to top of stack
3222   95E8 3C 8B       	.WORD	C_MINUS			;Work out buffer length
3223   95EA A2 8F       	.WORD	C_ERASE			;Fill addr & length from stack with 0
3224   95EC 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3225   95EE             
3226   95EE             W_BUFFER:
3227   95EE 864255464645	.BYTE	86h,"BUFFE",'R'+80h
3227   95F4 D2
3228   95F5 D0 95       	.WORD	W_EBUFFERS
3229   95F7             C_BUFFER:
3230   95F7 64 87       	.WORD	E_COLON			;Interpret following word sequence
3231   95F9 05 96       	.WORD	C_BLOCK
3232   95FB 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3233   95FD             
3234   95FD             W_BLOCK:				;Put address of block n (+ offset) on stack
3235   95FD 85424C4F43CB	.BYTE	85h,"BLOC",'K'+80h
3236   9603 EE 95       	.WORD	W_BUFFER
3237   9605             C_BLOCK:
3238   9605 64 87       	.WORD	E_COLON			;Interpret following word sequence
3239   9607 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3240   9609 B1 FF       	.WORD	DISK_END/BLOCK_SIZE-DISK_START/BLOCK_SIZE
3241   960B             					;Max number of blocks
3242   960B C3 94       	.WORD	C_MOD			;MOD to max number
3243   960D D9 88       	.WORD	C_OFFSET		;Put address of disk block offset on stack
3244   960F EA 86       	.WORD	C_FETCH			;Get disk block offset
3245   9611 FB 85       	.WORD	C_PLUS			;Add offset to block #
3246   9613 36 88       	.WORD	C_BBUF			;Put bytes per block on stack
3247   9615 94 94       	.WORD	C_TIMES			;Bytes times block number
3248   9617 16 88       	.WORD	C_FIRST			;Put address of first block on stack
3249   9619 FB 85       	.WORD	C_PLUS			;Add address of first to byte offset
3250   961B 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3251   961D             
3252   961D             W_RW:
3253   961D 83 52 2F D7 	.BYTE	83h,"R/",'W'+80h
3254   9621 FD 95       	.WORD	W_BLOCK
3255   9623             C_RW:
3256   9623 64 87       	.WORD	E_COLON			;Interpret following word sequence
3257   9625 B9 89       	.WORD	C_URW			;
3258   9627 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
3259   9629 89 82       	.WORD	C_EXECUTE		;Jump to address on stack
3260   962B 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3261   962D             CF_URW:
3262   962D 64 87       	.WORD	E_COLON			;Interpret following word sequence
3263   962F 6E 86       	.WORD	C_DROP			;Drop top value from stack
3264   9631 6E 86       	.WORD	C_DROP			;Drop top value from stack
3265   9633 6E 86       	.WORD	C_DROP			;Drop top value from stack
3266   9635 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3267   9637             
3268   9637             W_FLUSH:
3269   9637 85464C5553C8	.BYTE	85h,"FLUS",'H'+80h
3270   963D 1D 96       	.WORD	W_RW
3271   963F             C_FLUSH:
3272   963F 64 87       	.WORD	E_COLON			;Interpret following word sequence
3273   9641 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3274   9643             
3275   9643             W_DUMP:
3276   9643 8444554DD0  	.BYTE	84h,"DUM",'P'+80h
3277   9648 37 96       	.WORD	W_FLUSH
3278   964A             C_DUMP:
3279   964A 64 87       	.WORD	E_COLON			;Interpret following word sequence
3280   964C DB 87       	.WORD	C_ZERO			;Put zero on stack
3281   964E 0A 83       	.WORD	C_LDO			;Put start & end loop values on RPP
3282   9650             B0051:
3283   9650 34 84       	.WORD	C_CR			;Output [CR][LF]
3284   9652 97 86       	.WORD	C_DUP			;Duplicate top value on stack
3285   9654 DB 87       	.WORD	C_ZERO			;Put zero on stack
3286   9656 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3287   9658 05 00       	.WORD	0005h
3288   965A F6 98       	.WORD	C_DDOTR
3289   965C D2 8B       	.WORD	C_SPACE			;Output space
3290   965E 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3291   9660 04 00       	.WORD	0004h
3292   9662 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
3293   9664 5F 86       	.WORD	C_OVER			;Copy 2nd down to top of stack
3294   9666 DB 87       	.WORD	C_ZERO			;Put zero on stack
3295   9668 0A 83       	.WORD	C_LDO			;Put start & end loop values on RPP
3296   966A             B0050:
3297   966A 97 86       	.WORD	C_DUP			;Duplicate top value on stack
3298   966C F9 86       	.WORD	C_CFETCH		;Get byte from addr on stack
3299   966E F3 87       	.WORD	C_3
3300   9670 19 99       	.WORD	C_DOTR
3301   9672 CB 8A       	.WORD	C_1PLUS			;1 plus
3302   9674 C5 82       	.WORD	C_LLOOP			;Increment loop & branch if not done
3303   9676 F4 FF       	.WORD	B0050-$			;FFF4h
3304   9678 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
3305   967A FE 82       	.WORD	C_PLOOP			;Loop + stack & branch if not done
3306   967C D4 FF       	.WORD	B0051-$			;FFD4h
3307   967E 6E 86       	.WORD	C_DROP			;Drop top value from stack
3308   9680 34 84       	.WORD	C_CR			;Output [CR][LF]
3309   9682 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3310   9684             
3311   9684             W_LOAD:
3312   9684 844C4F41C4  	.BYTE	84h,"LOA",'D'+80h
3313   9689 43 96       	.WORD	W_DUMP
3314   968B             C_LOAD:
3315   968B 64 87       	.WORD	E_COLON			;Interpret following word sequence
3316   968D AE 88       	.WORD	C_BLK			;Get current block number (0 = keyboard)
3317   968F EA 86       	.WORD	C_FETCH			;Get word from addr on stack
3318   9691 9D 85       	.WORD	C_MOVER			;Save it for now
3319   9693 B8 88       	.WORD	C_TOIN			;Current input buffer offset
3320   9695 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
3321   9697 9D 85       	.WORD	C_MOVER			;Save it for now
3322   9699 DB 87       	.WORD	C_ZERO			;Put zero on stack
3323   969B B8 88       	.WORD	C_TOIN			;Current input buffer offset
3324   969D 21 87       	.WORD	C_STORE			;Set to zero
3325   969F 46 88       	.WORD	C_BSCR			;Number of buffers per block on stack
3326   96A1 94 94       	.WORD	C_TIMES			;Multiply block to load by buffers/block
3327   96A3 AE 88       	.WORD	C_BLK			;Get BLK pointer
3328   96A5 21 87       	.WORD	C_STORE			;Make load block current input stream
3329   96A7 3B 92       	.WORD	C_INTERPRET		;Interpret input stream
3330   96A9 B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
3331   96AB B8 88       	.WORD	C_TOIN			;Current input buffer offset
3332   96AD 21 87       	.WORD	C_STORE			;Store word at addr
3333   96AF B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
3334   96B1 AE 88       	.WORD	C_BLK			;Current block
3335   96B3 21 87       	.WORD	C_STORE			;Store word at addr
3336   96B5 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3337   96B7             
3338   96B7             W_NEXTSCREEN:
3339   96B7 C3 2D 2D BE 	.BYTE	0C3h,"--",'>'+80h
3340   96BB 84 96       	.WORD	W_LOAD
3341   96BD             C_NEXTSCREEN:
3342   96BD 64 87       	.WORD	E_COLON			;Interpret following word sequence
3343   96BF 02 8D       	.WORD	C_QLOADING
3344   96C1 DB 87       	.WORD	C_ZERO			;Put zero on stack
3345   96C3 B8 88       	.WORD	C_TOIN			;Current input buffer offset
3346   96C5 21 87       	.WORD	C_STORE			;Store word at addr
3347   96C7 46 88       	.WORD	C_BSCR			;Number of buffers per block on stack
3348   96C9 AE 88       	.WORD	C_BLK
3349   96CB EA 86       	.WORD	C_FETCH			;Get word from addr on stack
3350   96CD 5F 86       	.WORD	C_OVER			;Copy 2nd down to top of stack
3351   96CF C3 94       	.WORD	C_MOD
3352   96D1 3C 8B       	.WORD	C_MINUS
3353   96D3 AE 88       	.WORD	C_BLK
3354   96D5 C5 86       	.WORD	C_PLUSSTORE		;Add n1 to addr
3355   96D7 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3356   96D9             
3357   96D9             W_TICK:
3358   96D9 81 AC       	.BYTE	81h,2Ch+80h
3359   96DB B7 96       	.WORD	W_NEXTSCREEN
3360   96DD             C_TICK:
3361   96DD 64 87       	.WORD	E_COLON			;Interpret following word sequence
3362   96DF E2 90       	.WORD	C_MFIND			;Find name returns PFA,length,true or false
3363   96E1 CF 85       	.WORD	C_0EQUALS		;=0
3364   96E3 DB 87       	.WORD	C_ZERO			;Put zero on stack
3365   96E5 89 8C       	.WORD	C_QERROR
3366   96E7 6E 86       	.WORD	C_DROP			;Drop top value from stack
3367   96E9 D3 91       	.WORD	C_LITERAL
3368   96EB 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3369   96ED             
3370   96ED             W_FORGET:
3371   96ED 86464F524745	.BYTE	86h,"FORGE",'T'+80h
3371   96F3 D4
3372   96F4 D9 96       	.WORD	W_TICK
3373   96F6             C_FORGET:
3374   96F6 64 87       	.WORD	E_COLON			;Interpret following word sequence
3375   96F8 F5 88       	.WORD	C_CURRENT
3376   96FA EA 86       	.WORD	C_FETCH			;Get word from addr on stack
3377   96FC E7 88       	.WORD	C_CONTEXT
3378   96FE EA 86       	.WORD	C_FETCH			;Get word from addr on stack
3379   9700 3C 8B       	.WORD	C_MINUS
3380   9702 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3381   9704 18 00       	.WORD	0018h
3382   9706 89 8C       	.WORD	C_QERROR
3383   9708 DD 96       	.WORD	C_TICK
3384   970A 97 86       	.WORD	C_DUP			;Duplicate top value on stack
3385   970C 8C 88       	.WORD	C_FENCE
3386   970E EA 86       	.WORD	C_FETCH			;Get word from addr on stack
3387   9710 5D 8B       	.WORD	C_LESSTHAN
3388   9712 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3389   9714 15 00       	.WORD	0015h
3390   9716 89 8C       	.WORD	C_QERROR
3391   9718 97 86       	.WORD	C_DUP			;Duplicate top value on stack
3392   971A 4B 8C       	.WORD	C_NFA			;Convert PFA to NFA
3393   971C 95 88       	.WORD	C_DP			;Dictionary pointer addr on stack
3394   971E 21 87       	.WORD	C_STORE			;Store word at addr
3395   9720 2D 8C       	.WORD	C_LFA
3396   9722 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
3397   9724 E7 88       	.WORD	C_CONTEXT
3398   9726 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
3399   9728 21 87       	.WORD	C_STORE			;Store word at addr
3400   972A 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3401   972C             
3402   972C             W_BACK:
3403   972C 84424143CB  	.BYTE	84h,"BAC",'K'+80h
3404   9731 ED 96       	.WORD	W_FORGET
3405   9733             C_BACK:
3406   9733 64 87       	.WORD	E_COLON			;Interpret following word sequence
3407   9735 FF 8A       	.WORD	C_HERE			;Dictionary pointer onto stack
3408   9737 3C 8B       	.WORD	C_MINUS
3409   9739 1B 8B       	.WORD	C_COMMA			;Reserve 2 bytes and save n
3410   973B 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3411   973D             
3412   973D             W_BEGIN:
3413   973D C542454749CE	.BYTE	0C5h,"BEGI",'N'+80h
3414   9743 2C 97       	.WORD	W_BACK
3415   9745             C_BEGIN:
3416   9745 64 87       	.WORD	E_COLON			;Interpret following word sequence
3417   9747 A3 8C       	.WORD	C_QCOMP			;Error if not in compile mode
3418   9749 FF 8A       	.WORD	C_HERE			;Dictionary pointer onto stack
3419   974B E3 87       	.WORD	C_1			;Put 1 on stack
3420   974D 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3421   974F             
3422   974F             W_ENDIF:
3423   974F C5454E4449C6	.BYTE	0C5h,"ENDI",'F'+80h
3424   9755 3D 97       	.WORD	W_BEGIN
3425   9757             C_ENDIF:
3426   9757 64 87       	.WORD	E_COLON			;Interpret following word sequence
3427   9759 A3 8C       	.WORD	C_QCOMP			;Error if not in compile mode
3428   975B EB 87       	.WORD	C_2
3429   975D D2 8C       	.WORD	C_QPAIRS
3430   975F FF 8A       	.WORD	C_HERE			;Dictionary pointer onto stack
3431   9761 5F 86       	.WORD	C_OVER			;Copy 2nd down to top of stack
3432   9763 3C 8B       	.WORD	C_MINUS
3433   9765 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
3434   9767 21 87       	.WORD	C_STORE			;Store word at addr
3435   9769 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3436   976B             
3437   976B             W_THEN:
3438   976B C4544845CE  	.BYTE	0C4h,"THE",'N'+80h
3439   9770 4F 97       	.WORD	W_ENDIF
3440   9772             C_THEN:
3441   9772 64 87       	.WORD	E_COLON			;Interpret following word sequence
3442   9774 57 97       	.WORD	C_ENDIF
3443   9776 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3444   9778             
3445   9778             W_DO:
3446   9778 C2 44 CF    	.BYTE	0C2h,'D','O'+80h
3447   977B 6B 97       	.WORD	W_THEN
3448   977D             C_DO:
3449   977D 64 87       	.WORD	E_COLON			;Interpret following word sequence
3450   977F 1C 8D       	.WORD	C_COMPILE		;Compile next word into dictionary
3451   9781 0A 83       	.WORD	C_LDO			;Put start & end loop values on RPP
3452   9783 FF 8A       	.WORD	C_HERE			;Dictionary pointer onto stack
3453   9785 F3 87       	.WORD	C_3
3454   9787 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3455   9789             
3456   9789             W_LOOP:
3457   9789 C44C4F4FD0  	.BYTE	0C4h,"LOO",'P'+80h
3458   978E 78 97       	.WORD	W_DO
3459   9790             C_LOOP:
3460   9790 64 87       	.WORD	E_COLON			;Interpret following word sequence
3461   9792 F3 87       	.WORD	C_3
3462   9794 D2 8C       	.WORD	C_QPAIRS
3463   9796 1C 8D       	.WORD	C_COMPILE		;Compile next word into dictionary
3464   9798 C5 82       	.WORD	C_LLOOP			;Increment loop & branch if not done
3465   979A 33 97       	.WORD	C_BACK
3466   979C 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3467   979E             
3468   979E             W_PLUSLOOP:
3469   979E C52B4C4F4FD0	.BYTE	0C5h,"+LOO",'P'+80h
3470   97A4 89 97       	.WORD	W_LOOP
3471   97A6             C_PLUSLOOP:
3472   97A6 64 87       	.WORD	E_COLON			;Interpret following word sequence
3473   97A8 F3 87       	.WORD	C_3
3474   97AA D2 8C       	.WORD	C_QPAIRS
3475   97AC 1C 8D       	.WORD	C_COMPILE		;Compile next word into dictionary
3476   97AE FE 82       	.WORD	C_PLOOP			;Loop + stack & branch if not done
3477   97B0 33 97       	.WORD	C_BACK
3478   97B2 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3479   97B4             
3480   97B4             W_UNTIL:
3481   97B4 C5554E5449CC	.BYTE	0C5h,"UNTI",'L'+80h
3482   97BA 9E 97       	.WORD	W_PLUSLOOP
3483   97BC             C_UNTIL:
3484   97BC 64 87       	.WORD	E_COLON			;Interpret following word sequence
3485   97BE E3 87       	.WORD	C_1			;Put 1 on stack
3486   97C0 D2 8C       	.WORD	C_QPAIRS
3487   97C2 1C 8D       	.WORD	C_COMPILE		;Compile next word into dictionary
3488   97C4 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3489   97C6 33 97       	.WORD	C_BACK
3490   97C8 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3491   97CA             
3492   97CA             W_END:
3493   97CA C3 45 4E C4 	.BYTE	0C3h,"EN",'D'+80h
3494   97CE B4 97       	.WORD	W_UNTIL
3495   97D0             C_END:
3496   97D0 64 87       	.WORD	E_COLON			;Interpret following word sequence
3497   97D2 BC 97       	.WORD	C_UNTIL
3498   97D4 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3499   97D6             
3500   97D6             W_AGAIN:
3501   97D6 C541474149CE	.BYTE	0C5h,"AGAI",'N'+80h
3502   97DC CA 97       	.WORD	W_END
3503   97DE             C_AGAIN:
3504   97DE 64 87       	.WORD	E_COLON			;Interpret following word sequence
3505   97E0 E3 87       	.WORD	C_1			;Put 1 on stack
3506   97E2 D2 8C       	.WORD	C_QPAIRS
3507   97E4 1C 8D       	.WORD	C_COMPILE		;Compile next word into dictionary
3508   97E6 98 82       	.WORD	C_BRANCH		;Add following offset to BC
3509   97E8 33 97       	.WORD	C_BACK
3510   97EA 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3511   97EC             
3512   97EC             W_REPEAT:
3513   97EC C65245504541	.BYTE	0C6h,"REPEA",'T'+80h
3513   97F2 D4
3514   97F3 D6 97       	.WORD	W_AGAIN
3515   97F5             C_REPEAT:
3516   97F5 64 87       	.WORD	E_COLON			;Interpret following word sequence
3517   97F7 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
3518   97F9 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
3519   97FB DE 97       	.WORD	C_AGAIN
3520   97FD B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
3521   97FF B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
3522   9801 EB 87       	.WORD	C_2
3523   9803 3C 8B       	.WORD	C_MINUS
3524   9805 57 97       	.WORD	C_ENDIF
3525   9807 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3526   9809             
3527   9809             W_IF:
3528   9809 C2 49 C6    	.BYTE	0C2h,'I','F'+80h
3529   980C EC 97       	.WORD	W_REPEAT
3530   980E             C_IF:
3531   980E 64 87       	.WORD	E_COLON			;Interpret following word sequence
3532   9810 1C 8D       	.WORD	C_COMPILE		;Compile next word into dictionary
3533   9812 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3534   9814 FF 8A       	.WORD	C_HERE			;Dictionary pointer onto stack
3535   9816 DB 87       	.WORD	C_ZERO			;Put zero on stack
3536   9818 1B 8B       	.WORD	C_COMMA			;Reserve 2 bytes and save n
3537   981A EB 87       	.WORD	C_2
3538   981C 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3539   981E             
3540   981E             W_ELSE:
3541   981E C4454C53C5  	.BYTE	0C4h,"ELS",'E'+80h
3542   9823 09 98       	.WORD	W_IF
3543   9825             C_ELSE:
3544   9825 64 87       	.WORD	E_COLON			;Interpret following word sequence
3545   9827 EB 87       	.WORD	C_2
3546   9829 D2 8C       	.WORD	C_QPAIRS
3547   982B 1C 8D       	.WORD	C_COMPILE		;Compile next word into dictionary
3548   982D 98 82       	.WORD	C_BRANCH		;Add following offset to BC
3549   982F FF 8A       	.WORD	C_HERE			;Dictionary pointer onto stack
3550   9831 DB 87       	.WORD	C_ZERO			;Put zero on stack
3551   9833 1B 8B       	.WORD	C_COMMA			;Reserve 2 bytes and save n
3552   9835 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
3553   9837 EB 87       	.WORD	C_2
3554   9839 57 97       	.WORD	C_ENDIF
3555   983B EB 87       	.WORD	C_2
3556   983D 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3557   983F             
3558   983F             W_WHILE:
3559   983F C55748494CC5	.BYTE	0C5h,"WHIL",'E'+80h
3560   9845 1E 98       	.WORD	W_ELSE
3561   9847             C_WHILE:
3562   9847 64 87       	.WORD	E_COLON			;Interpret following word sequence
3563   9849 0E 98       	.WORD	C_IF
3564   984B D7 8A       	.WORD	C_2PLUS			;2 plus
3565   984D 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3566   984F             
3567   984F             W_SPACES:
3568   984F 865350414345	.BYTE	86h,"SPACE",'S'+80h
3568   9855 D3
3569   9856 3F 98       	.WORD	W_WHILE
3570   9858             C_SPACES:
3571   9858 64 87       	.WORD	E_COLON			;Interpret following word sequence
3572   985A DB 87       	.WORD	C_ZERO			;Put zero on stack
3573   985C 3E 94       	.WORD	C_MAX
3574   985E E1 8B       	.WORD	C_QUERYDUP
3575   9860 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3576   9862 0C 00       	.WORD	B0034-$			;000Ch
3577   9864 DB 87       	.WORD	C_ZERO			;Put zero on stack
3578   9866 0A 83       	.WORD	C_LDO			;Put start & end loop values on RPP
3579   9868             B0035:
3580   9868 D2 8B       	.WORD	C_SPACE			;Output space
3581   986A C5 82       	.WORD	C_LLOOP			;Increment loop & branch if not done
3582   986C FC FF       	.WORD	B0035-$			;FFFCh
3583   986E             B0034:
3584   986E 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3585   9870             
3586   9870             W_LESSHARP:
3587   9870 82 3C A3    	.BYTE	82h,'<','#'+80h
3588   9873 4F 98       	.WORD	W_SPACES
3589   9875             C_LESSHARP:
3590   9875 64 87       	.WORD	E_COLON			;Interpret following word sequence
3591   9877 DA 8F       	.WORD	C_PAD			;Save intermediate string address
3592   9879 3D 89       	.WORD	C_HLD
3593   987B 21 87       	.WORD	C_STORE			;Store word at addr
3594   987D 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3595   987F             
3596   987F             W_SHARPGT:
3597   987F 82 23 BE    	.BYTE	82h,'#','>'+80h
3598   9882 70 98       	.WORD	W_LESSHARP
3599   9884             C_SHARPGT:
3600   9884 64 87       	.WORD	E_COLON			;Interpret following word sequence
3601   9886 6E 86       	.WORD	C_DROP			;Drop top value from stack
3602   9888 6E 86       	.WORD	C_DROP			;Drop top value from stack
3603   988A 3D 89       	.WORD	C_HLD
3604   988C EA 86       	.WORD	C_FETCH			;Get word from addr on stack
3605   988E DA 8F       	.WORD	C_PAD			;Save intermediate string address
3606   9890 5F 86       	.WORD	C_OVER			;Copy 2nd down to top of stack
3607   9892 3C 8B       	.WORD	C_MINUS
3608   9894 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3609   9896             
3610   9896             W_SIGN:
3611   9896 84534947CE  	.BYTE	84h,"SIG",'N'+80h
3612   989B 7F 98       	.WORD	W_SHARPGT
3613   989D             C_SIGN:
3614   989D 64 87       	.WORD	E_COLON			;Interpret following word sequence
3615   989F AD 8B       	.WORD	C_ROT			;3rd valu down to top of stack
3616   98A1 EA 85       	.WORD	C_0LESS			;Less than 0
3617   98A3 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3618   98A5 08 00       	.WORD	B0036-$			;0008h
3619   98A7 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3620   98A9 2D 00       	.WORD	002Dh
3621   98AB C2 8F       	.WORD	C_HOLD
3622   98AD             B0036:
3623   98AD 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3624   98AF             
3625   98AF             W_SHARP:
3626   98AF 81 A3       	.BYTE	81h,'#'+80h
3627   98B1 96 98       	.WORD	W_SIGN
3628   98B3             C_SHARP:
3629   98B3 64 87       	.WORD	E_COLON			;Interpret following word sequence
3630   98B5 0C 89       	.WORD	C_BASE			;Put BASE addr on stack
3631   98B7 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
3632   98B9 F6 94       	.WORD	C_MDIVMOD
3633   98BB AD 8B       	.WORD	C_ROT			;3rd valu down to top of stack
3634   98BD 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3635   98BF 09 00       	.WORD	0009h
3636   98C1 5F 86       	.WORD	C_OVER			;Copy 2nd down to top of stack
3637   98C3 5D 8B       	.WORD	C_LESSTHAN
3638   98C5 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3639   98C7 08 00       	.WORD	B0037-$			;0008h
3640   98C9 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3641   98CB 07 00       	.WORD	0007h
3642   98CD FB 85       	.WORD	C_PLUS			;n1 + n2
3643   98CF             B0037:
3644   98CF 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3645   98D1 30 00       	.WORD	0030h
3646   98D3 FB 85       	.WORD	C_PLUS			;n1 + n2
3647   98D5 C2 8F       	.WORD	C_HOLD
3648   98D7 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3649   98D9             
3650   98D9             W_SHARPS:
3651   98D9 82 23 D3    	.BYTE	82h,'#','S'+80h
3652   98DC AF 98       	.WORD	W_SHARP
3653   98DE             C_SHARPS:
3654   98DE 64 87       	.WORD	E_COLON			;Interpret following word sequence
3655   98E0             B0038:
3656   98E0 B3 98       	.WORD	C_SHARP
3657   98E2 5F 86       	.WORD	C_OVER			;Copy 2nd down to top of stack
3658   98E4 5F 86       	.WORD	C_OVER			;Copy 2nd down to top of stack
3659   98E6 00 85       	.WORD	C_OR			;OR
3660   98E8 CF 85       	.WORD	C_0EQUALS		;=0
3661   98EA B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3662   98EC F4 FF       	.WORD	B0038-$			;FFF4h
3663   98EE 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3664   98F0             
3665   98F0             W_DDOTR:
3666   98F0 83 44 2E D2 	.BYTE	83h,"D.",'R'+80h
3667   98F4 D9 98       	.WORD	W_SHARPS
3668   98F6             C_DDOTR:
3669   98F6 64 87       	.WORD	E_COLON			;Interpret following word sequence
3670   98F8 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
3671   98FA 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
3672   98FC 5F 86       	.WORD	C_OVER			;Copy 2nd down to top of stack
3673   98FE 1A 94       	.WORD	C_DABS
3674   9900 75 98       	.WORD	C_LESSHARP
3675   9902 DE 98       	.WORD	C_SHARPS
3676   9904 9D 98       	.WORD	C_SIGN
3677   9906 84 98       	.WORD	C_SHARPGT
3678   9908 B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
3679   990A 5F 86       	.WORD	C_OVER			;Copy 2nd down to top of stack
3680   990C 3C 8B       	.WORD	C_MINUS
3681   990E 58 98       	.WORD	C_SPACES
3682   9910 0A 8E       	.WORD	C_TYPE			;Output n bytes from addr
3683   9912 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3684   9914             
3685   9914             W_DOTR:
3686   9914 82 2E D2    	.BYTE	82h,'.','R'+80h
3687   9917 F0 98       	.WORD	W_DDOTR
3688   9919             C_DOTR:
3689   9919 64 87       	.WORD	E_COLON			;Interpret following word sequence
3690   991B 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
3691   991D D3 93       	.WORD	C_SINGTODUB		;Change single number to double
3692   991F B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
3693   9921 F6 98       	.WORD	C_DDOTR
3694   9923 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3695   9925             
3696   9925             W_DDOT:
3697   9925 82 44 AE    	.BYTE	82h,'D','.'+80h
3698   9928 14 99       	.WORD	W_DOTR
3699   992A             C_DDOT:
3700   992A 64 87       	.WORD	E_COLON			;Interpret following word sequence
3701   992C DB 87       	.WORD	C_ZERO			;Put zero on stack
3702   992E F6 98       	.WORD	C_DDOTR
3703   9930 D2 8B       	.WORD	C_SPACE			;Output space
3704   9932 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3705   9934             
3706   9934             W_DOT:
3707   9934 81 AE       	.BYTE	81h,'.'+80h
3708   9936 25 99       	.WORD	W_DDOT
3709   9938             C_DOT:
3710   9938 64 87       	.WORD	E_COLON			;Interpret following word sequence
3711   993A D3 93       	.WORD	C_SINGTODUB		;Change single number to double
3712   993C 2A 99       	.WORD	C_DDOT
3713   993E 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3714   9940             
3715   9940             W_QUESTION:
3716   9940 81 BF       	.BYTE	81h,'?'+80h
3717   9942 34 99       	.WORD	W_DOT
3718   9944             C_QUESTION:
3719   9944 64 87       	.WORD	E_COLON			;Interpret following word sequence
3720   9946 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
3721   9948 38 99       	.WORD	C_DOT
3722   994A 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3723   994C             
3724   994C             W_UDOT:					;Output as unsigned value
3725   994C 82 55 AE    	.BYTE	82h,'U','.'+80h
3726   994F 40 99       	.WORD	W_QUESTION
3727   9951             C_UDOT:
3728   9951 64 87       	.WORD	E_COLON			;Interpret following word sequence
3729   9953 DB 87       	.WORD	C_ZERO			;Put zero on stack
3730   9955 2A 99       	.WORD	C_DDOT			;Output double value
3731   9957 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3732   9959             
3733   9959             W_VLIST:
3734   9959 85564C4953D4	.BYTE	85h,"VLIS",'T'+80h
3735   995F 4C 99       	.WORD	W_UDOT
3736   9961             C_VLIST:
3737   9961 64 87       	.WORD	E_COLON			;Interpret following word sequence
3738   9963 E7 88       	.WORD	C_CONTEXT		;Leave vocab pointer on stack
3739   9965 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
3740   9967 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
3741   9969 34 84       	.WORD	C_CR			;Output [CR][LF]
3742   996B             B0039:
3743   996B 97 86       	.WORD	C_DUP			;Duplicate top value on stack
3744   996D 61 8C       	.WORD	C_PFA			;Convert NFA to PFA
3745   996F 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
3746   9971 4F 91       	.WORD	C_ID			;Print definition name from name field addr
3747   9973 2D 8C       	.WORD	C_LFA			;Convert param addr to link addr
3748   9975 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
3749   9977 97 86       	.WORD	C_DUP			;Duplicate top value on stack
3750   9979 CF 85       	.WORD	C_0EQUALS		;=0
3751   997B 25 84       	.WORD	C_TERMINAL		;Check for break key
3752   997D 00 85       	.WORD	C_OR			;OR
3753   997F B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3754   9981 EA FF       	.WORD	B0039-$			;FFE2h
3755   9983 6E 86       	.WORD	C_DROP			;Drop top value from stack
3756   9985 34 84       	.WORD	C_CR			;Output [CR][LF]
3757   9987 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3758   9989             
3759   9989             W_LIST:
3760   9989 844C4953D4  	.BYTE	84h,"LIS",'T'+80h
3761   998E 59 99       	.WORD	W_VLIST
3762   9990             C_LIST:
3763   9990 64 87       	.WORD	E_COLON			;Interpret following word sequence
3764   9992 0C 89       	.WORD	C_BASE			;Put BASE addr on stack
3765   9994 EA 86       	.WORD	C_FETCH			;Put current base on stack
3766   9996 8A 86       	.WORD	C_SWAP			;Get number of list screen to top
3767   9998 7D 8D       	.WORD	C_DECIMAL		;Sets decimal mode
3768   999A 34 84       	.WORD	C_CR			;Output [CR][LF]
3769   999C 97 86       	.WORD	C_DUP			;Duplicate top value on stack
3770   999E CC 88       	.WORD	C_SCR			;Set most recently listed
3771   99A0 21 87       	.WORD	C_STORE			;Store word at addr
3772   99A2 6B 8E       	.WORD	C_CQUOTE		;Output following string
3773   99A4 06          	.BYTE	S_END3-S_START3
3774   99A5             S_START3:
3775   99A5 534352202320	.BYTE	"SCR # "
3776   99AB             S_END3:
3777   99AB 38 99       	.WORD	C_DOT			;Output the screen number
3778   99AD 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3779   99AF 10 00       	.WORD	0010h			;16 lines to do
3780   99B1 DB 87       	.WORD	C_ZERO			;From 0 to 15
3781   99B3 0A 83       	.WORD	C_LDO			;Put start & end loop values on RPP
3782   99B5             DO_LINE:
3783   99B5 34 84       	.WORD	C_CR			;Output [CR][LF]
3784   99B7 26 83       	.WORD	C_I		    	;Line number onto data stack
3785   99B9 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3786   99BB 03 00       	.WORD	0003h			;Fromat right justified 3 characters
3787   99BD 19 99       	.WORD	C_DOTR			;Output formatted
3788   99BF D2 8B       	.WORD	C_SPACE			;Output space
3789   99C1 26 83       	.WORD	C_I		     	;Line number onto data stack
3790   99C3 CC 88       	.WORD	C_SCR			;Get screen number
3791   99C5 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
3792   99C7 37 95       	.WORD	C_DOTLINE		;Output line from screen
3793   99C9 25 84       	.WORD	C_TERMINAL		;Check for break key
3794   99CB B0 82       	.WORD	C_0BRANCH		;Jump if no break key
3795   99CD 04 00       	.WORD	NO_BRK-$		;
3796   99CF 89 85       	.WORD	C_LEAVE			;Else set loop index to limit (quit loop)
3797   99D1             NO_BRK:
3798   99D1 C5 82       	.WORD	C_LLOOP			;Increment loop & branch if not done
3799   99D3 E2 FF       	.WORD	DO_LINE-$		;
3800   99D5 34 84       	.WORD	C_CR			;Output [CR][LF]
3801   99D7 0C 89       	.WORD	C_BASE			;Put BASE addr on stack
3802   99D9 21 87       	.WORD	C_STORE			;Restore original base
3803   99DB 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3804   99DD             
3805   99DD             W_INDEX:
3806   99DD 85494E4445D8	.BYTE	85h,"INDE",'X'+80h
3807   99E3 89 99       	.WORD	W_LIST
3808   99E5             C_INDEX:
3809   99E5 64 87       	.WORD	E_COLON			;Interpret following word sequence
3810   99E7 CB 8A       	.WORD	C_1PLUS			;1 plus
3811   99E9 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
3812   99EB 0A 83       	.WORD	C_LDO			;Put start & end loop values on RPP
3813   99ED             B003D:
3814   99ED 34 84       	.WORD	C_CR			;Output [CR][LF]
3815   99EF 26 83       	.WORD	C_I			;Copy LOOP index to data stack
3816   99F1 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3817   99F3 03 00       	.WORD	0003h
3818   99F5 19 99       	.WORD	C_DOTR
3819   99F7 D2 8B       	.WORD	C_SPACE			;Output space
3820   99F9 DB 87       	.WORD	C_ZERO			;Put zero on stack
3821   99FB 26 83       	.WORD	C_I			;Copy LOOP index to data stack
3822   99FD 37 95       	.WORD	C_DOTLINE		;Output line from screen
3823   99FF 25 84       	.WORD	C_TERMINAL		;Check for break key
3824   9A01 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3825   9A03 04 00       	.WORD	B003C-$			;0004h
3826   9A05 89 85       	.WORD	C_LEAVE			;Quit loop by making index = limit
3827   9A07             B003C:
3828   9A07 C5 82       	.WORD	C_LLOOP			;Increment loop & branch if not done
3829   9A09 E4 FF       	.WORD	B003D-$			;FFE4h
3830   9A0B 34 84       	.WORD	C_CR			;Output [CR][LF]
3831   9A0D 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3832   9A0F             
3833   9A0F             W_INT:
3834   9A0F C43B494ED4  	.BYTE	0C4h,";IN",'T'+80h
3835   9A14 DD 99       	.WORD	W_INDEX
3836   9A16             C_INT:
3837   9A16 64 87       	.WORD	E_COLON			;Interpret following word sequence
3838   9A18 E5 8C       	.WORD	C_WHATSTACK		;Check stack pointer, error if not ok
3839   9A1A 1C 8D       	.WORD	C_COMPILE		;Compile next word into dictionary
3840   9A1C 24 9A       	.WORD	X_INT
3841   9A1E 32 8D       	.WORD	C_LEFTBRKT		;Set STATE to execute
3842   9A20 55 8D       	.WORD	C_SMUDGE
3843   9A22 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3844   9A24             
3845   9A24             X_INT:
3846   9A24 26 9A       	.WORD	2+$			;Vector to code
3847   9A26 21 4C FE    	LD	HL,INTFLAG
3848   9A29 CB B6       	RES	6,(HL)
3849   9A2B FB          	EI
3850   9A2C C3 74 85    	JP	X_STOP
3851   9A2F             
3852   9A2F             W_INTFLAG:
3853   9A2F 87494E54464C	.BYTE	87h,"INTFLA",'G'+80h
3853   9A35 41C7
3854   9A37 0F 9A       	.WORD	W_INT
3855   9A39             C_INTFLAG:
3856   9A39 CB 87       	.WORD	X_USER			;Put next word on stack then do next
3857   9A3B 4C 00       	.WORD	INTFLAG-SYSTEM
3858   9A3D             
3859   9A3D             W_INTVECT:
3860   9A3D 87494E545645	.BYTE	87h,"INTVEC",'T'+80h
3860   9A43 43D4
3861   9A45 2F 9A       	.WORD	W_INTFLAG
3862   9A47             C_INTVECT:
3863   9A47 CB 87       	.WORD	X_USER			;Put next word on stack then do next
3864   9A49 4E 00       	.WORD	INTVECT-SYSTEM
3865   9A4B             
3866   9A4B             W_CPU:
3867   9A4B 842E4350D5  	.BYTE	84h,".CP",'U'+80h
3868   9A50 3D 9A       	.WORD	W_INTVECT
3869   9A52             C_CPU:
3870   9A52 64 87       	.WORD	E_COLON			;Interpret following word sequence
3871   9A54 6B 8E       	.WORD	C_CQUOTE		;Output following string
3872   9A56 04          	.BYTE	S_END4-S_START4
3873   9A57             S_START4:
3874   9A57 5A 38 30 20 	.BYTE	"Z80 "
3875   9A5B             S_END4:
3876   9A5B 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3877   9A5D             
3878   9A5D             W_2SWAP:
3879   9A5D 8532535741D0	.BYTE	85h,"2SWA",'P'+80h
3880   9A63 4B 9A       	.WORD	W_CPU
3881   9A65             C_2SWAP:
3882   9A65 64 87       	.WORD	E_COLON			;Interpret following word sequence
3883   9A67 AD 8B       	.WORD	C_ROT			;3rd valu down to top of stack
3884   9A69 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
3885   9A6B AD 8B       	.WORD	C_ROT			;3rd valu down to top of stack
3886   9A6D B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
3887   9A6F 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3888   9A71             
3889   9A71             W_2OVER:
3890   9A71 85324F5645D2	.BYTE	85h,"2OVE",'R'+80h
3891   9A77 5D 9A       	.WORD	W_2SWAP
3892   9A79             C_2OVER:
3893   9A79 64 87       	.WORD	E_COLON			;Interpret following word sequence
3894   9A7B 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
3895   9A7D 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
3896   9A7F A5 86       	.WORD	C_2DUP			;Dup top 2 values on stack
3897   9A81 B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
3898   9A83 B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
3899   9A85 65 9A       	.WORD	C_2SWAP
3900   9A87 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3901   9A89             
3902   9A89             W_EXIT:
3903   9A89 84455849D4  	.BYTE	84h,"EXI",'T'+80h
3904   9A8E 71 9A       	.WORD	W_2OVER
3905   9A90             C_EXIT:
3906   9A90 74 85       	.WORD	X_STOP
3907   9A92             
3908   9A92             W_J:					;Push outer loop value on stack
3909   9A92 81 CA       	.BYTE	81h,'J'+80h
3910   9A94 89 9A       	.WORD	W_EXIT
3911   9A96             C_J:
3912   9A96 98 9A       	.WORD	2+$			;Vector to code
3913   9A98 2A 46 FE    	LD	HL,(RPP)		;Get return stack pointer
3914   9A9B 23          	INC	HL			;Skip inner loop values
3915   9A9C 23          	INC	HL			;
3916   9A9D 23          	INC	HL			;
3917   9A9E 23          	INC	HL			;
3918   9A9F C3 2B 83    	JP	X_I2
3919   9AA2             
3920   9AA2             W_ROLL:
3921   9AA2 84524F4CCC  	.BYTE	84h,"ROL",'L'+80h
3922   9AA7 92 9A       	.WORD	W_J
3923   9AA9             C_ROLL:
3924   9AA9 64 87       	.WORD	E_COLON			;Interpret following word sequence
3925   9AAB 97 86       	.WORD	C_DUP			;Duplicate top value on stack
3926   9AAD DB 87       	.WORD	C_ZERO			;Put zero on stack
3927   9AAF 9F 8B       	.WORD	C_GREATER
3928   9AB1 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3929   9AB3 2C 00       	.WORD	B003E-$			;002Ch
3930   9AB5 97 86       	.WORD	C_DUP			;Duplicate top value on stack
3931   9AB7 9D 85       	.WORD	C_MOVER			;Move value from data to return stack
3932   9AB9 BC 8B       	.WORD	C_PICK
3933   9ABB B3 85       	.WORD	C_RMOVE			;Move word from return to data stack
3934   9ABD DB 87       	.WORD	C_ZERO			;Put zero on stack
3935   9ABF 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
3936   9AC1 0A 83       	.WORD	C_LDO			;Put start & end loop values on RPP
3937   9AC3             B003F:
3938   9AC3 26 85       	.WORD	C_SPFETCH		;Stack pointer onto stack
3939   9AC5 26 83       	.WORD	C_I			;Copy LOOP index to data stack
3940   9AC7 97 86       	.WORD	C_DUP			;Duplicate top value on stack
3941   9AC9 FB 85       	.WORD	C_PLUS			;n1 + n2
3942   9ACB FB 85       	.WORD	C_PLUS			;n1 + n2
3943   9ACD 97 86       	.WORD	C_DUP			;Duplicate top value on stack
3944   9ACF F0 8A       	.WORD	C_2MINUS		;2 minus
3945   9AD1 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
3946   9AD3 8A 86       	.WORD	C_SWAP			;Swap top 2 values on stack
3947   9AD5 21 87       	.WORD	C_STORE			;Store word at addr
3948   9AD7 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
3949   9AD9 FF FF       	.WORD	0FFFFh
3950   9ADB FE 82       	.WORD	C_PLOOP			;Loop + stack & branch if not done
3951   9ADD E6 FF       	.WORD	B003F-$			;FFE6h
3952   9ADF             B003E:
3953   9ADF 6E 86       	.WORD	C_DROP			;Drop top value from stack
3954   9AE1 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3955   9AE3             
3956   9AE3             W_DEPTH:
3957   9AE3 8544455054C8	.BYTE	85h,"DEPT",'H'+80h
3958   9AE9 A2 9A       	.WORD	W_ROLL
3959   9AEB             C_DEPTH:
3960   9AEB 64 87       	.WORD	E_COLON			;Interpret following word sequence
3961   9AED 53 88       	.WORD	C_S0			;Push S0 (initial data stack pointer)
3962   9AEF EA 86       	.WORD	C_FETCH			;Get word from addr on stack
3963   9AF1 26 85       	.WORD	C_SPFETCH		;Stack pointer onto stack
3964   9AF3 3C 8B       	.WORD	C_MINUS
3965   9AF5 EB 87       	.WORD	C_2
3966   9AF7 B3 94       	.WORD	C_DIV
3967   9AF9 E4 8A       	.WORD	C_1MINUS		;1 minus
3968   9AFB 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3969   9AFD             
3970   9AFD             W_DLESSTHAN:
3971   9AFD 82 44 BC    	.BYTE	82h,'D','<'+80h
3972   9B00 E3 9A       	.WORD	W_DEPTH
3973   9B02             C_DLESSTHAN:
3974   9B02 64 87       	.WORD	E_COLON			;Interpret following word sequence
3975   9B04 AD 8B       	.WORD	C_ROT			;3rd valu down to top of stack
3976   9B06 A5 86       	.WORD	C_2DUP			;Dup top 2 values on stack
3977   9B08 51 8B       	.WORD	C_EQUALS
3978   9B0A B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
3979   9B0C 0A 00       	.WORD	B0040-$			;000Ah
3980   9B0E 7C 86       	.WORD	C_2DROP			;Drop top two values from stack
3981   9B10 7F 8B       	.WORD	C_ULESS			;IF stack-1 < stack_top leave true flag
3982   9B12 98 82       	.WORD	C_BRANCH		;Add following offset to BC
3983   9B14 08 00       	.WORD	B0041-$			;0008h
3984   9B16             B0040:
3985   9B16 65 9A       	.WORD	C_2SWAP
3986   9B18 7C 86       	.WORD	C_2DROP			;Drop top two values from stack
3987   9B1A 9F 8B       	.WORD	C_GREATER
3988   9B1C             B0041:
3989   9B1C 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3990   9B1E             
3991   9B1E             W_0GREATER:
3992   9B1E 82 30 BE    	.BYTE	82h,'0','>'+80h
3993   9B21 FD 9A       	.WORD	W_DLESSTHAN
3994   9B23             C_0GREATER:
3995   9B23 64 87       	.WORD	E_COLON			;Interpret following word sequence
3996   9B25 DB 87       	.WORD	C_ZERO			;Put zero on stack
3997   9B27 9F 8B       	.WORD	C_GREATER
3998   9B29 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
3999   9B2B             
4000   9B2B             W_DOTS:
4001   9B2B 82 2E D3    	.BYTE	82h,'.','S'+80h
4002   9B2E 1E 9B       	.WORD	W_0GREATER
4003   9B30             C_DOTS
4004   9B30 64 87       	.WORD	E_COLON			;Interpret following word sequence
4005   9B32 34 84       	.WORD	C_CR			;Output [CR][LF]
4006   9B34 EB 9A       	.WORD	C_DEPTH
4007   9B36 B0 82       	.WORD	C_0BRANCH		;Add offset to BC if stack top = 0
4008   9B38 20 00       	.WORD	B0042-$			;0020h
4009   9B3A 26 85       	.WORD	C_SPFETCH		;Stack pointer onto stack
4010   9B3C F0 8A       	.WORD	C_2MINUS		;2 minus
4011   9B3E 53 88       	.WORD	C_S0			;Push S0 (initial data stack pointer)
4012   9B40 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
4013   9B42 F0 8A       	.WORD	C_2MINUS		;2 minus
4014   9B44 0A 83       	.WORD	C_LDO			;Put start & end loop values on RPP
4015   9B46             B0043:
4016   9B46 26 83       	.WORD	C_I			;Copy LOOP index to data stack
4017   9B48 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
4018   9B4A 38 99       	.WORD	C_DOT
4019   9B4C 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
4020   9B4E FE FF       	.WORD	0FFFEh
4021   9B50 FE 82       	.WORD	C_PLOOP			;Loop + stack & branch if not done
4022   9B52 F4 FF       	.WORD	B0043-$			;FFF4h
4023   9B54 98 82       	.WORD	C_BRANCH		;Add following offset to BC
4024   9B56 11 00       	.WORD	S_END5-$		;0011h
4025   9B58             B0042:
4026   9B58 6B 8E       	.WORD	C_CQUOTE		;Output following string
4027   9B5A 0C          	.BYTE	S_END5-S_START5
4028   9B5B             S_START5:
4029   9B5B 535441434B20	.BYTE	"STACK EMPTY "
4029   9B61 454D50545920
4030   9B67             S_END5:
4031   9B67 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
4032   9B69             
4033   9B69             W_CODE:
4034   9B69 84434F44C5  	.BYTE	84h,"COD",'E'+80h
4035   9B6E 2B 9B       	.WORD	W_DOTS
4036   9B70             C_CODE:
4037   9B70 64 87       	.WORD	E_COLON			;Interpret following word sequence
4038   9B72 BB 8C       	.WORD	C_QEXEC			;Error not if not in execute mode
4039   9B74 5F 91       	.WORD	C_XXX1
4040   9B76 35 85       	.WORD	C_SPSTORE		;Set initial stack pointer value
4041   9B78 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
4042   9B7A             
4043   9B7A             W_ENDCODE:
4044   9B7A 88454E442D43	.BYTE	88h,"END-COD",'E'+80h
4044   9B80 4F44C5
4045   9B83 69 9B       	.WORD	W_CODE
4046   9B85             C_ENDCODE:
4047   9B85 64 87       	.WORD	E_COLON			;Interpret following word sequence
4048   9B87 F5 88       	.WORD	C_CURRENT
4049   9B89 EA 86       	.WORD	C_FETCH			;Get word from addr on stack
4050   9B8B E7 88       	.WORD	C_CONTEXT
4051   9B8D 21 87       	.WORD	C_STORE			;Store word at addr
4052   9B8F BB 8C       	.WORD	C_QEXEC			;Error not if not in execute mode
4053   9B91 E5 8C       	.WORD	C_WHATSTACK		;Check stack pointer, error if not ok
4054   9B93 55 8D       	.WORD	C_SMUDGE
4055   9B95 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
4056   9B97             
4057   9B97             W_NEXT:
4058   9B97 C44E4558D4  	.BYTE	0C4h,"NEX",'T'+80h
4059   9B9C 7A 9B       	.WORD	W_ENDCODE
4060   9B9E             C_NEXT:
4061   9B9E 64 87       	.WORD	E_COLON			;Interpret following word sequence
4062   9BA0 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
4063   9BA2 C3 00       	.WORD	00C3h			;Jump instruction
4064   9BA4 2C 8B       	.WORD	C_CCOMMA		;Save as 8 bit value
4065   9BA6 74 82       	.WORD	C_LIT			;Puts next 2 bytes on the stack
4066   9BA8 4E 82       	.WORD	NEXT			;The address of NEXT
4067   9BAA 1B 8B       	.WORD	C_COMMA			;Reserve 2 bytes and save n
4068   9BAC 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
4069   9BAE             
4070   9BAE             W_LLOAD:
4071   9BAE 854C4C4F41C4	.BYTE	85h,"LLOA",'D'+80h
4072   9BB4             ;	.WORD	W_MON
4073   9BB4 97 9B       	.WORD	W_NEXT
4074   9BB6             C_LLOAD:
4075   9BB6 64 87       	.WORD	E_COLON			;Interpret following word sequence
4076   9BB8 05 96       	.WORD	C_BLOCK			;Get block address
4077   9BBA 74 82       	.WORD	C_LIT			;Enter loop with null
4078   9BBC 00 00       	.WORD	0000h			;
4079   9BBE             LL_BEGIN:
4080   9BBE 97 86       	.WORD	C_DUP			;Dup key
4081   9BC0 B0 82       	.WORD	C_0BRANCH		;If null then don't store
4082   9BC2 28 00       	.WORD	LL_NULL-$		;
4083   9BC4 97 86       	.WORD	C_DUP			;Dup key again
4084   9BC6 74 82       	.WORD	C_LIT			;Compare to [CR]
4085   9BC8 0D 00       	.WORD	000Dh			;
4086   9BCA 51 8B       	.WORD	C_EQUALS		;
4087   9BCC B0 82       	.WORD	C_0BRANCH		;If not [CR] then jump
4088   9BCE 12 00       	.WORD	LL_STORE-$		;
4089   9BD0 6E 86       	.WORD	C_DROP			;Drop the [CR]
4090   9BD2 06 88       	.WORD	C_CL			;Get characters per line
4091   9BD4 FB 85       	.WORD	C_PLUS			;Add to current addr
4092   9BD6 06 88       	.WORD	C_CL			;Make CL MOD value
4093   9BD8 2B 86       	.WORD	C_NEGATE		;Form 2s complement of n
4094   9BDA EE 84       	.WORD	C_AND			;Mask out bits
4095   9BDC 98 82       	.WORD	C_BRANCH		;Done this bit so jump
4096   9BDE 06 00       	.WORD	NO_STORE-$
4097   9BE0             LL_STORE:
4098   9BE0 5F 86       	.WORD	C_OVER			;Get address to store at
4099   9BE2 21 87       	.WORD	C_STORE			;Save chr
4100   9BE4             NO_STORE:
4101   9BE4 CB 8A       	.WORD	C_1PLUS			;Next addres
4102   9BE6 98 82       	.WORD	C_BRANCH		;Done so jump
4103   9BE8 04 00       	.WORD	LL_CHAR-$		;
4104   9BEA             LL_NULL:
4105   9BEA 6E 86       	.WORD	C_DROP			;Was null so drop it
4106   9BEC             LL_CHAR:
4107   9BEC 13 84       	.WORD	C_KEY			;Get key
4108   9BEE 97 86       	.WORD	C_DUP			;Duplicate it
4109   9BF0 74 82       	.WORD	C_LIT			;Compare with [CTRL] Z
4110   9BF2 1A 00       	.WORD	001Ah			;
4111   9BF4 51 8B       	.WORD	C_EQUALS		;
4112   9BF6 B0 82       	.WORD	C_0BRANCH		;If not EOF then jump
4113   9BF8 C6 FF       	.WORD	LL_BEGIN-$		;
4114   9BFA 6E 86       	.WORD	C_DROP			;Drop EOF character
4115   9BFC 6E 86       	.WORD	C_DROP			;Drop next address
4116   9BFE 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
4117   9C00             
4118   9C00             W_TASK:
4119   9C00 84544153CB  	.BYTE	84h,"TAS",'K'+80h
4120   9C05 AE 9B       	.WORD	W_LLOAD
4121   9C07             C_TASK:
4122   9C07 64 87       	.WORD	E_COLON			;Interpret following word sequence
4123   9C09 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
4124   9C0B             W_TASKEND:
4125   9C0B             
4126   9C0B             W_EDITI:
4127   9C0B             
4128   9C0B             W_CLEAR:				;Clear block n
4129   9C0B 85434C4541D2	.BYTE	85h,"CLEA",'R'+80h
4130   9C11 00 9C       	.WORD	W_TASK
4131   9C13             C_CLEAR:
4132   9C13 64 87       	.WORD	E_COLON			;Interpret following word sequence
4133   9C15 97 86       	.WORD	C_DUP			;Duplicate number
4134   9C17 CC 88       	.WORD	C_SCR			;Get SCR addr
4135   9C19 21 87       	.WORD	C_STORE			;Store screen number
4136   9C1B 05 96       	.WORD	C_BLOCK			;Get the address of the block
4137   9C1D 36 88       	.WORD	C_BBUF			;Put number of bytes/block on stack
4138   9C1F A2 8F       	.WORD	C_ERASE			;Clear the block
4139   9C21 72 85       	.WORD	C_STOP			;Pop BC from return stack (=next)
4140   9C23             
4141   9C23             CF_UKEY:				;Get key onto stack
4142   9C23 25 9C       	.WORD	2+$			;Vector to code
4143   9C25 CD 5E 9C    	CALL	CHR_RD			;User key in routine
4144   9C28 6F          	LD	L,A			;Put key on stack
4145   9C29 26 00       	LD	H,00h			;
4146   9C2B C3 4D 82    	JP	NEXTS1			;Save & NEXT
4147   9C2E             
4148   9C2E             CF_UEMIT:				;Chr from stack to output
4149   9C2E 30 9C       	.WORD	2+$			;Vector to code
4150   9C30 E1          	POP	HL			;Get CHR to output
4151   9C31 7D          	LD	A,L			;Put in A
4152   9C32 C5          	PUSH	BC			;Save regs
4153   9C33 D5          	PUSH	DE			;
4154   9C34 CD 63 9C    	CALL	CHR_WR			;User output routine
4155   9C37 D1          	POP	DE			;Restore regs
4156   9C38 C1          	POP	BC			;
4157   9C39 C3 4E 82    	JP	NEXT			;
4158   9C3C             
4159   9C3C             CF_UCR:					;CR output
4160   9C3C 3E 9C       	.WORD	2+$			;Vector to code
4161   9C3E C5          	PUSH	BC			;Save regs
4162   9C3F D5          	PUSH	DE			;Just in case
4163   9C40 3E 0D       	LD	A,0Dh			;Carrage return
4164   9C42 CD 63 9C    	CALL	CHR_WR			;User output routine
4165   9C45 3E 0A       	LD	A,0Ah			;Line feed
4166   9C47 CD 63 9C    	CALL	CHR_WR			;User output routine
4167   9C4A D1          	POP	DE			;Get regs back
4168   9C4B C1          	POP	BC			;
4169   9C4C C3 4E 82    	JP	NEXT			;Next
4170   9C4F             
4171   9C4F             CF_UQTERMINAL:				;Test for user break
4172   9C4F 51 9C       	.WORD	2+$			;Vector to code
4173   9C51 C5          	PUSH	BC			;Save regs
4174   9C52 D5          	PUSH	DE			;Just in case
4175   9C53 CD 61 9C    	CALL	BREAKKEY		;User break test routine
4176   9C56 D1          	POP	DE			;Get regs back
4177   9C57 C1          	POP	BC			;
4178   9C58 26 00       	LD	H,00h			;Clear H
4179   9C5A 6F          	LD	L,A			;Result in L
4180   9C5B C3 4D 82    	JP	NEXTS1			;Store it & Next
4181   9C5E             
4182   9C5E             ;==============================================================================
4183   9C5E             ; Serial I/O routines
4184   9C5E             ; Rachel - To use INT32K.ASM
4185   9C5E             ;==============================================================================
4186   9C5E             
4187   9C5E             CHR_RD:					;Character in
4188   9C5E D7          	RST 10h
4189   9C5F C9          	RET
4190   9C60             NO_BUF_KEY:
4191   9C60 C9          	RET				;
4192   9C61             
4193   9C61             BREAKKEY:
4194   9C61             ; 	IN A,($80)
4195   9C61             ; 	AND $01           		;Check if interupt due to read buffer full
4196   9C61             ; 	JR Z,NO_KEY        		;if not, ignore
4197   9C61             ; 	IN A,($81)
4198   9C61             ; 	CP 27h				;Is it break
4199   9C61             ; 	JR Z,WAS_BRK
4200   9C61             NO_KEY:
4201   9C61 AF           	XOR	A			;Wasn't break, or no key, so clear
4202   9C62 C9          	RET
4203   9C63             ;WAS_BRK:
4204   9C63             ; 	LD	A,01h			;Was break so set flag
4205   9C63             ; 	RET
4206   9C63             
4207   9C63             CHR_WR:					;Character out
4208   9C63 E6 7F               AND 7Fh                         ;To knock off end of word marker
4209   9C65 CF                  RST 08h
4210   9C66 C9          	RET				;
4211   9C67             
4212   9C67             ;==============================================================================
4213   FE00             		.ORG	0FE00h	        ;Set up system variable addresses
4214   FE00             ;==============================================================================
4215   FE00             SYSTEM:					;Start of scratch pad area
4216   FE00             		.BLOCK	6		;User bytes
4217   FE06             S0:		.BLOCK	2		;Initial value of the data stack pointer
4218   FE08             R0:		.BLOCK	2		;Initial value of the return stack pointer
4219   FE0A             TIB:		.BLOCK	2		;Address of the terminal input buffer
4220   FE0C             WIDTH:		.BLOCK	2		;Number of letters saved in names
4221   FE0E             WARNING:	.BLOCK	2		;Error message control number
4222   FE10             FENCE:		.BLOCK	2		;Dictionary FORGET protection point
4223   FE12             DP:		.BLOCK	2		;The dictionary pointer
4224   FE14             VOC_LINK:	.BLOCK	2		;Most recently created vocabulary
4225   FE16             BLK:		.BLOCK	2		;Current block number under interpretation
4226   FE18             TOIN:		.BLOCK	2		;Offset in the current input text buffer
4227   FE1A             OUT:		.BLOCK	2		;Offset in the current output text buffer
4228   FE1C             SCR:		.BLOCK	2		;Screen number last referenced by LIST
4229   FE1E             OFFSET:		.BLOCK	2		;Block offset for disk drives
4230   FE20             CONTEXT:	.BLOCK	2		;Pointer to the vocabulary within which
4231   FE22             					;dictionary search will first begin
4232   FE22             CURRENT:	.BLOCK	2		;Pointer to the vocabulary within which
4233   FE24             					;new definitions are to be created
4234   FE24             STATE:		.BLOCK	2		;Contains state of compillation
4235   FE26             BASE:		.BLOCK	2		;Current I/O base address
4236   FE28             DPL:		.BLOCK	2		;Number of digits to the right of the
4237   FE2A             					;decimal point on double integer input
4238   FE2A             FLD:		.BLOCK	2		;Field width for formatted number output
4239   FE2C             CSP:		.BLOCK	2		;Check stack pointer
4240   FE2E             RHASH:		.BLOCK	2		;Location of editor cursor in a text bloxk
4241   FE30             HLD:		.BLOCK	2		;Address of current output
4242   FE32             FLAST:		.BLOCK	6		;FORTH vocabulary data initialised to FORTH
4243   FE38             					;vocabulary
4244   FE38             ELAST:		.BLOCK	6		;Editor vocabulary data initialised to
4245   FE3E             					;EDITOR vocabulary
4246   FE3E             CRFLAG:		.BLOCK	1		;Carriage return flag
4247   FE3F             		.BLOCK	1		;User byte
4248   FE40             PAT:		.BLOCK	3		;I/O port fetch routine (input)
4249   FE43             PST:		.BLOCK	3		;I/O port store routine (output)
4250   FE46             RPP:		.BLOCK	2		;Return stack pointer
4251   FE48             USE:		.BLOCK	2		;Mass storage buffer address to use
4252   FE4A             PREV:		.BLOCK	2		;Mass storage buffer address just used
4253   FE4C             INTFLAG:	.BLOCK	1		;Interrupt flag
4254   FE4D             		.BLOCK	1		;User byte
4255   FE4E             INTVECT:	.BLOCK	2		;Interrupt vector
4256   FE50             UTERMINAL:	.BLOCK	2		;Code field address of word ?TERMINAL
4257   FE52             UKEY:		.BLOCK	2		;Code field address of word KEY
4258   FE54             UEMIT:		.BLOCK	2		;Code field address of word EMIT
4259   FE56             UCR:		.BLOCK	2		;Code field address of word CR
4260   FE58             URW:		.BLOCK	2		;Code field address of word R/W
4261   FE5A             UABORT:		.BLOCK	2		;Code field address of word ABORT
4262   FE5C             UCL:		.BLOCK	2		;Number of characters per input line
4263   FE5E             UFIRST:		.BLOCK	2		;Start of pseudo disk buffer
4264   FE60             ULIMIT:		.BLOCK	2		;End of pseudo disk buffer
4265   FE62             UBBUF:		.BLOCK	2		;Number of bytes per block
4266   FE64             UBSCR:		.BLOCK	2		;Number of buffers per block
4267   FE66             KEYBUF:		.BLOCK	2		;Double key buffer
4268   FE68             RAF:		.BLOCK	2		;Register AF
4269   FE6A             RBC:		.BLOCK	2		;Register BC
4270   FE6C             RDE:		.BLOCK	2		;Register DE
4271   FE6E             RHL:		.BLOCK	2		;Register HL
4272   FE70             RIX:		.BLOCK	2		;Register IX
4273   FE72             RIY:		.BLOCK	2		;Register IY
4274   FE74             RAF2:		.BLOCK	2		;Register AF'
4275   FE76             RBC2:		.BLOCK	2		;Register BC'
4276   FE78             RDE2:		.BLOCK	2		;Register DE'
4277   FE7A             RHL2:		.BLOCK	2		;Register HL'
4278   FE7C             		.BLOCK	1		;User byte
4279   FE7D             JPCODE:		.BLOCK	1		;JMP code (C3) for word CALL
4280   FE7E             JPVECT:		.BLOCK	2		;JMP vector for word CALL
4281   FE80             		.BLOCK	32		;User bytes
4282   FEA0             
4283   FEA0             		.END
4284   FEA0             ;==============================================================================
tasm: Number of errors = 0
